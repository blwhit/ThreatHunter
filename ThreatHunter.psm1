#requires -version 5.0
# ----------------------------------------------------------------
# ThreatHunter
# ------------------------
# [ Module Manifest ]
# ======================
# []    Hunt-ForensicDump
# [...] Hunt-Logs
# [X]   Hunt-Files 
# [X]   Hunt-Persistence
# [X]   Hunt-Browser
# [X]   Hunt-VirusTotal
# [X]   Hunt-Services
# [X]   Hunt-Tasks
# [X]   Hunt-Registry
# -----------------------------

#   Function Reviews and Future Features:
# ========================================
# - Hunt-ForensicDump: could add a filtering type of feature, where you can color rows... right click and color red or green, etc... then add filter button to show all filtered... excel style
# - Hunt-ForensicDump: add a base64 string of the Compressed Arrchive of all EVTX logs? That way you will always have all event logs..... is this possible?
# - Hunt-ForensicDump: Review CSV Output files for formatting/etc.
# - Hunt-Logs: add a native "-Page" or "-Paging" switch to the Hunt-Logs (and maybe Hunt-Files) function (paging ability while keeping coloring)
# - Hunt-Files: Add 'Caching' functionality for file searches


#   Final/Full Review & To Do
# --------------------------------------------

# - Hunt-ForensicDump: Add something to enumerate local admins (which accounts have Administrator privileges?)
# - Hunt-ForensicDump: Random error "Error rendering table: Cannot read properties of undefined (reading 'toLocaleString')" <--- Random unknown log table in 'Event Logs' tab [its happening with multiple tables, might just be blank tables erroring out]
# - Hunt-ForensicDump: Add PID and TID to event logs..
# - Hunt-ForensicDump: research and add any more interesting Registry Key/Values to the reg colelction. Pretty thin now. e.g. UAC values, RDP settings, etc.... User profile list? Firewall or antivirus settings? Services?
# - Hunt-ForensicDump: In the Persistence tab, move the "Flag" field to the front, and sort by it (non null values at the top)
# - Hunt-ForensicDump: remove the 'Settings' tab "Max Rows Per Table" control. it doesnt do anything helpful-- atleast tell users you can only go down... the "Max Chars Per Cell" does however work...
# - Hunt-ForensicDump: Might want to reorganize the tabs. Put the most used first... least used towards the right side...
# - Hunt-ForensicDump: make sure all new sub function features are implemented corrrectly... validate that updated and new sub-functions work comprehensively 

# - Make Wiki
# - Review each funtion: Full description, Every parameter/feature/sub-function (with examples)
# - Full review of usage and every parameter/feature audit

# - Finalize suspicious/IOC string lists

# - Rename and standardize any variable names (loadtool vs loadbrowsertool, etc.)
# - Review and update all Synopsis/Parameters/Notes/Examples sections

# - Validate CSV output for each function

# ----------------------------------------------------------------
# ----------------------------------------------------------------
# ----------------------------------------------------------------


# Script Variables
# -------------------
# Hunt-Persistence
$script:SuspiciousStringIOCs = @(
    "client32.exe",
    "client32.ini", 
    "xmrig",
    "onestart",
    "update.js"
)

$script:AggressiveStringIOCs = @(
    "-ExecutionPolicy Bypass", "-ep bypass", "-ex bypass",
    "-WindowStyle Hidden", "-w hidden",
    "-NoProfile", "-nop",
    "-NonInteractive", "-noni",
    "-EncodedCommand", "-enc",
    "-Command", "-c ",
    "IEX ", "Invoke-Expression",
    "DownloadString", "DownloadFile",
    "Net.WebClient", "System.Net.WebClient",
    "BitsTransfer", "Start-BitsTransfer",
    "Invoke-WebRequest", "iwr ",
    "Invoke-RestMethod", "irm ",
    "FromBase64String",
    "IO.Compression", "IO.MemoryStream",
    "Reflection.Assembly", "::Load",
    "Runtime.InteropServices", "Runtime.InteropServices.Marshal",
    "-noexit -c", "add-type"
)

$script:InsaneStringIOCs = @(
    # Custom        
    "-e ",

    # Common PowerShell Base64 prefixes
    "-e JAB", "-e SUVYI", "-e aWV4", "-e cwB0AGE",
    "-enc JAB", "-enc SUVYI", "-enc aWV4", "-enc cwB0AGE",
    
    # Suspicious command combinations
    "cmd /c powershell", "cmd.exe /c echo", "powershell -c cmd",
    
    # Remote execution indicators - UNC paths
    "\\*\\c$", "\\*\\admin$", "\\*\\ipc$",
    "\\*\\C$", "\\*\\ADMIN$", "\\*\\IPC$",
    
    # Temp + execution combo
    "*\\Temp\\*.exe", "*\\Temp\\*.bat", "*\\Temp\\*.vbs", "*\\Temp\\*.ps1",
    "*\\AppData\\Local\\Temp\\*.exe",
    "*\\Users\\*\\AppData\\Local\\Temp\\*",
    
    # Suspicious downloads to temp
    "http*\\Temp*", "https*\\AppData*",
    
    # Process injection/hollowing indicators
    "VirtualAlloc", "WriteProcessMemory", "CreateRemoteThread",
    "NtCreateThreadEx", "RtlCreateUserThread", "QueueUserAPC"
)

$script:suspiciousFileExt = @(
    '.vbs', '.js', '.bat', '.cmd', '.ps1', '.wsf', '.hta', '.jar', '.py', '.pl', '.conf',
    '.jse', '.vbe',
    '.psc1', '.psm1',
    '.application',
    '.gadget',
    '.msi', '.msp',
    '.scr',
    '.lnk',
    '.url',
    '.sct', '.wsh',
    '.reg',
    #'.inf',
    '.cpl'
)

$script:suspiciousPaths = @(
    '\Temp\', '\TMP\',
    '\AppData\', '\Local\Temp\',
    '\Downloads\',
    '\Public\',
    '\ProgramData\',
    'C:\Windows\Temp\',
    'system32\config\',
    'system32\drivers\',
    '\$Recycle.Bin\',
    '\Recovery\',
    '\System Volume Information\',
    '\INetCache\',
    '\Temp\Low\',
    '\INetCookies\',
    'C:\Intel\',
    'C:\PerfLogs\',
    'C:\Recovery\',
    '\Start Menu\',
    '\Startup\',
    '\Recent\',
    '\SendTo\'
)

$script:executionBinaries = @(
    'PowerShell.exe', 'pwsh.exe',
    'CMD.exe',
    'wscript.exe', 'cscript.exe',
    'mshta.exe', 'rundll32.exe', 'regsvr32.exe', 'certutil.exe',
    'bitsadmin.exe', 'msiexec.exe', 'installutil.exe',
    'regasm.exe', 'regsvcs.exe', 'msxsl.exe',
    'forfiles.exe', 'pcalua.exe', 'SyncAppvPublishingServer.exe',
    'odbcconf.exe', 'ieexec.exe', 'xwizard.exe',
    'Node.exe', 'python.exe', 'perl.exe', 'ruby.exe', 'java.exe', 'javaw.exe',
    'psexec.exe', 'psexesvc.exe', 'paexec.exe',
    'winrm.exe', 'winrs.exe', 'wmic.exe',
    'wget.exe', 'curl.exe', 'aria2c.exe',
    '7z.exe', 'rar.exe', 'winrar.exe', 'zip.exe'
)

# Browser Related (Hunt-Browser)
$script:suspiciousBrowserStrings = @(
    # Direct IP access patterns
    'http://*.*.*.*', 'https://*.*.*.*',
    'http://10.*', 'http://172.*', 'http://192.168.*',
    'http://127.0.0.1*', 'http://localhost*',
    
    # Local file execution - fixed triple slashes
    'file:///*exe', 'file:///*bat', 'file:///*cmd', 'file:///*ps1',
    'file:///*vbs', 'file:///*js', 'file:///*hta', 'file:///*scr',
    'file:///*jar', 'file:///*msi',
    
    # Suspicious paths in URLs
    '*/temp/*.exe', '*/temp/*.zip', '*/temp/*.rar', '*/temp/*.7z',
    '*/tmp/*.exe', '*/tmp/*.ps1', '*/tmp/*.bat',
    '*/cache/*.exe', '*/cache/*.dll',
    '*/download/*.exe', '*/download/*.zip',
    '*/upload/*.exe', '*/upload/*.ps1',
    
    # Data URIs - removed angle brackets
    'data:text/html*script*', 'data:text/html*javascript*',
    'data:application/*base64*', 'data:text/*base64*',
    
    # Double extensions
    '*.pdf.exe', '*.doc.exe', '*.xls.exe', '*.xlsx.exe',
    '*.jpg.exe', '*.png.exe', '*.txt.exe', '*.gif.exe',
    '*.pdf.bat', '*.doc.cmd', '*.xls.ps1', '*.jpg.scr',
    '*.pdf.zip', '*.doc.zip', '*.xls.rar',
    
    # Shortened URLs
    '*bit.ly/*', '*tinyurl.*', '*goo.gl/*', '*t.co/*',
    '*rebrand.ly/*', '*ow.ly/*', '*is.gd/*',
    '*short.link/*', '*cutt.ly/*', '*tiny.cc/*',
    
    # Suspicious query strings
    '*?*cmd=*', '*?*exec=*', '*?*shell=*', '*?*payload=*',
    '*?*command=*', '*?*execute=*', '*?*run=*',
    '*&cmd=*', '*&exec=*', '*&shell=*',
    
    # Non-standard ports
    '*:8080*', '*:8443*', '*:4444*', '*:1337*', '*:31337*',
    '*:6666*', '*:7777*', '*:9999*', '*:5555*', '*:3389*',
    
    # Additional suspicious patterns
    '*.onion*',
    '*://pastebin.com/*', '*://paste.ee/*', '*://hastebin.com/*',
    '*webhook.site*', '*discord.com/api/webhooks/*',
    '*/admin.php*', '*/shell.php*', '*/cmd.php*',
    '*powershell*', '*encoded*', '*base64*',
    
    # Executable download patterns
    '*.exe?*', '*.bat?*', '*.ps1?*', '*.vbs?*',
    '*.exe#*', '*.bat#*',
    
    # Suspicious domains patterns
    '*-download.*', '*-update.*', '*-installer.*',
    '*admin-*', '*login-*', '*secure-*', '*verify-*'
)

$script:aggressiveBrowserStrings = @(
    'file', 'download', 'login', 'password', 'admin', 'exploit', 'payload', 'shell', 
    'reverse', 'bypass', 'hidden', 'encoded',
    '*.pdf.exe', '*.doc.exe', '*.xls.exe', '*.jpg.exe', '*.txt.exe',
    '*invoice*.exe', '*receipt*.exe', '*order*.exe', '*payment*.exe',
    '*document*.exe', '*file*.exe', '*update*.exe', '*install*.exe',
    '*crack*.exe', '*keygen*.exe', '*patch*.exe', '*activator*.exe',
    '*.ps1', '*.bat', '*.cmd', '*.vbs', '*.js', '*.wsf', '*.hta',
    '*.zip', '*.rar', '*.7z', '*.tar', '*.gz' 
)

$script:suspiciousTLDs = @(
    '.top', '.xyz', '.shop', '.dev', '.ru', '.cn', '.tk', '.ml', '.ga', '.cf',
    '.pw', '.cc', '.click', '.download', '.work', '.link', '.site', '.online',
    '.website', '.space', '.tech', '.store', '.bid', '.win', '.review', '.trade',
    '.date', '.racing', '.cricket', '.science', '.party', '.gq', '.zip',
    '.rest', '.bar', '.life', '.live', '.host', '.best', '.fun', '.skin',
    '.cyou', '.buzz', '.vip', '.icu', '.monster', '.club', '.casa', '.uno',
    '.lol', '.sbs', '.hair', '.beauty', '.mom', '.nexus', '.quest',
    '.su', '.kp', '.sy', '.ir', '.ye', '.ly', '.to', '.ws', '.nu'
)

$script:PossibleTLDs = @(
    '.com', '.org', '.net', '.edu', '.gov', '.mil', '.int', '.co', '.io', '.me',
    '.tv', '.cc', '.ws', '.biz', '.info', '.name', '.pro', '.museum', '.coop',
    '.aero', '.jobs', '.mobi', '.travel', '.tel', '.asia', '.xxx', '.post',
    '.uk', '.ca', '.au', '.de', '.jp', '.fr', '.br', '.it', '.nl', '.be',
    '.es', '.pl', '.no', '.se', '.dk', '.fi', '.ch', '.at', '.cz', '.hu',
    '.microsoft', '.google', '.amazon', '.apple', '.adobe', '.cisco'
)

# Hunt Logs
$script:GlobalLogIOCs = @(
    # Default computer names
    "WIN-*", "DESKTOP-*", "LAPTOP-*", 
    "WORKGROUP\\WIN-", "WORKGROUP\\DESKTOP-",
    
    # Credential access artifacts
    "lsass.dmp", "lsass_", 
    "ntds.dit", ".hiv",
    "reg save HKLM\\SA", "reg save HKLM\\SYSTEM", "reg save HKLM\\SECURITY",
    "vssadmin create shadow", "copy \\\\?\\GLOBALROOT",
    "comsvcs.dll,MiniDump", "comsvcs.dll,#24",
    
    # Kerberos patterns
    "RC4_HMAC_MD5", "DES_CBC_MD5", ".kirbi",
    "S4U2Self", "S4U2Proxy",
    
    # Network shares
    "ADMIN$", "C$", "IPC$",
    "\\\\127.0.0.1\\C$", "\\\\localhost\\ADMIN$",
    
    # PowerShell execution flags & download cradles
    "-EncodedCommand", "-enc ", "powershell.exe -e ", "powershell.exe -ec ",
    "-ExecutionPolicy Bypass", "-ep bypass", "-ex bypass",
    "-WindowStyle Hidden", "-w hidden", "-wi h",
    "-NoProfile", "-nop",
    "-NonInteractive", "-noni",
    "-NoLogo", "-NoExit",
    "FromBase64String", "ToBase64String",
    "DownloadString", "DownloadFile", "DownloadData",
    "WebClient",
    "Invoke-WebRequest", "Invoke-RestMethod",
    "Start-BitsTransfer",
    "Invoke-Expression", "IEX ",
    "ServerCertificateValidationCallback",
    
    # LOLBin command patterns
    "certutil -decode", "certutil -urlcache", "certutil.exe -f",
    "bitsadmin /transfer", "bitsadmin /create",
    "mshta.exe http", "mshta.exe javascript",
    "rundll32.exe javascript", "rundll32.exe http",
    "regsvr32 /s /u /i:http",
    "msiexec /quiet /i http", "msiexec.exe /q /i",
    "wmic process call create", "wmic shadowcopy",
    "installutil.exe /logfile=", "installutil.exe /U",
    "forfiles /p c:\\windows\\system32 /m cmd.exe /c",
    "pcalua.exe -a",
    
    # Defender tampering
    "Set-MpPreference -Disable",
    "Add-MpPreference -Exclusion",
    "stop windefend",
    "powershell.exe -version 2", "powershell -v 2",
    
    # Persistence mechanisms
    "schtasks /create",
    "reg add HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
    "reg add HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
    "ActiveScriptEventConsumer", "__EventFilter",
    "CommandLineEventConsumer",
    "sethc.exe", "utilman.exe",
    "AppInit_DLLs",
    "Image File Execution Options",
    "Winlogon\\Shell", "Winlogon\\Userinit",
    
    # Reconnaissance - Network enumeration
    "net user", "net user /domain",
    "net group", "net group /domain", 
    "domain admins", "enterprise admins",
    "net localgroup", 
    "net accounts", "net view", "net share", "net session",
    "net config", "net time /domain", "net use",
    
    # Reconnaissance - AD/Domain queries
    "nltest /dc", "nltest /domain_trusts", "nltest /dsgetdc",
    "dsquery", "gpresult",
    
    # Reconnaissance - System information
    "whoami /", "ipconfig /all", "ipconfig /displaydns",
    "netstat -an", "route print", "arp -a",
    "tasklist", "quser", "query user", "qwinsta",
    "wmic qfe", "wmic product", "wmic service", "wmic process",
    "wmic startup", "wmic useraccount", "wmic group",
    "wmic netuse", "wmic share",
    "Get-NetIP", "Get-NetAdapter", "Get-DnsClientCache",
    
    # Reconnaissance - PowerShell AD cmdlets
    "Get-ADUser", "Get-ADGroup", 
    "Get-ADComputer", "Get-ADDomain", 
    "Get-ADForest", "Get-ADObject", "Get-ADOrganizational",
    
    # Data staging
    "7z.exe a -p", "rar.exe a -hp", "Compress-Archive",
    
    # Remote access/tunneling
    "ssh -R", "ssh -L", "ssh -D",
    "ngrok", "cloudflared",
    "socks4", "socks5",
    
    # Exfiltration services
    "pastebin.com", "paste.ee",
    "discord.com/api/webhooks", "webhook.site",
    
    # Suspicious paths
    "C:\\Users\\Public\\", "C:\\ProgramData\\", "C:\\Windows\\Temp\\",
    "%TEMP%\\", "%TMP%\\",
    
    # Obfuscation & encoding
    "[Convert]::FromBase64", "[Convert]::ToBase64",
    "[Text.Encoding]::",
    # "-join", # Needs tuned
    "-replace", 
    # "-split", # Probably needs tuned
    "[char", "[int[]]",
    ".replace(", ".substring(", "[array]::Reverse",
    "IO.Compression", "IO.MemoryStream",
    "Reflection.Assembly", "Assembly.Load", "::Load("
)


# Script Helper Functions 
# --------------------------
function Get-FileFromCommandLine {
    param([String]$CommandLine)

    if ([string]::IsNullOrWhiteSpace($CommandLine)) {
        return $null
    }

    try {
        # Expand environment variables
        $expanded = [System.Environment]::ExpandEnvironmentVariables($CommandLine.Trim())
        
        # 1. COMPATTELRUNNER.EXE with -m: parameter - extract the executable, not the DLL
        if ($expanded -match '(.*compattelrunner\.exe)\s+-m:') {
            return $matches[1]
        }
        
        # 2. CMD.EXE executing files - extract the target file
        if ($expanded -match 'cmd\.exe.*?/[dc]\s+([A-Za-z]:\\[^"\s]+\.(?:cmd|bat|ps1|vbs|js)(?!on)\b)') {
            return $matches[1]
        }
        if ($expanded -match 'cmd\.exe.*?/[dc]\s+"([^"]+\.(?:cmd|bat|ps1|vbs|js)(?!on)\b)"') {
            return $matches[1]
        }
        if ($expanded -match 'cmd\.exe.*?/[dc]\s+([^"\s]+\.(?:cmd|bat|ps1|vbs|js)(?!on)\b)') {
            return $matches[1]
        }
        
        # 3. POWERSHELL.EXE executing files - extract script files or executables
        if ($expanded -match 'powershell\.exe.*?-[Ff]ile\s+"?([^"\s]+\.(?:ps1|bat|cmd|exe|vbs|js)(?!on)\b)"?') {
            return $matches[1]
        }
        if ($expanded -match 'powershell\.exe.*?"[^"]*([A-Za-z]:\\[^"]*\.(?:ps1|bat|cmd|exe|vbs|js|dll)(?!on)\b)[^"]*"') {
            return $matches[1]
        }
        if ($expanded -match 'powershell\.exe.*?&\s+([A-Za-z]:\\[^"\s]+\.(?:ps1|bat|cmd|exe|vbs|js)(?!on)\b)') {
            return $matches[1]
        }
        if ($expanded -match 'powershell\.exe.*?\.\s+([A-Za-z]:\\[^"\s]+\.(?:ps1|bat|cmd|exe|vbs|js)(?!on)\b)') {
            return $matches[1]
        }
        
        # 4. NODE.EXE executing JavaScript files
        if ($expanded -match 'node\.exe\s+"?([^"\s]+\.js)(?!on)\b"?') {
            return $matches[1]
        }
        
        # 5. PYTHON.EXE executing Python files
        if ($expanded -match 'python\.exe\s+"?([^"\s]+\.py)"?') {
            return $matches[1]
        }
        
        # 6. WSCRIPT.EXE / CSCRIPT.EXE executing scripts
        if ($expanded -match '(?:wscript|cscript)\.exe\s+"?([^"\s]+\.(?:vbs|js|wsf)(?!on)\b)"?') {
            return $matches[1]
        }
        
        # 7. MSHTA.EXE executing HTA files
        if ($expanded -match 'mshta\.exe\s+"?([^"\s]+\.hta)"?') {
            return $matches[1]
        }
        
        # 8. REGSVR32.EXE registering DLLs
        if ($expanded -match 'regsvr32\.exe.*?\s+"?([^"\s]+\.dll)"?') {
            return $matches[1]
        }
        
        # 9. RUNDLL32.EXE calling DLL functions - extract the DLL
        if ($expanded -match 'rundll32\.exe\s+([A-Za-z]:\\[^,\s]+\.dll|[^,\s]+\.dll)') {
            $dll = $matches[1]
            # If relative path, try to resolve it
            if ($dll -notmatch '^[A-Za-z]:') {
                return Find-ExecutableInSystemPaths $dll
            }
            return $dll
        }
        
        # 10. MSIEXEC.EXE installing MSI files
        if ($expanded -match 'msiexec\.exe.*?[/\-]i\s+"?([^"\s]+\.msi)"?') {
            return $matches[1]
        }
        
        # 11. SCHTASKS.EXE with /RU (run as) pointing to executables
        if ($expanded -match 'schtasks\.exe.*?/TR\s+"?([^"\s]+\.(exe|bat|cmd|ps1))"?') {
            return $matches[1]
        }
        
        # 12. NET.EXE or SC.EXE starting services - return the full path
        if ($expanded -match '^(net\.exe|sc\.exe)\s+(?:start|stop|config)') {
            $utilityName = $matches[1]
            return Find-ExecutableInSystemPaths $utilityName
        }
        
        # 13. Quoted paths - but exclude PowerShell script content
        if ($expanded -match '"([^"]+)"' -and $matches[1] -notlike "& *" -and $matches[1] -notlike ".*-.*") {
            $path = $matches[1].Trim()
            # Clean trailing punctuation
            $path = $path -replace '[,;]+$', ''
            # Only return if it's a file path - exclude .json files
            if ($path -match '\.(?:exe|dll|bat|cmd|ps1|vbs|js|msi|com|scr|lnk|cpl|hta|wsf)$' -and $path -notmatch '\.json$') {
                return $path
            }
        }
        
        # 14. Simple drive paths with any extension - improved path validation
        if ($expanded -match '^([A-Za-z]:[^"]*\.(exe|dll|bat|cmd|ps1|vbs|js|msi|com|scr|lnk|cpl|hta|wsf))(\s|$)') {
            $path = $matches[1].Trim()
            # Clean trailing punctuation and validate
            $path = $path -replace '[,;]+$', ''
            # Ensure path doesn't contain invalid characters
            if ($path -notmatch '[\<\>\|\*\?]') {
                return $path
            }
        }
        
        # 15. Drive paths with arguments - capture until first argument
        if ($expanded -match '([A-Za-z]:[^"]*\.(exe|dll|bat|cmd|ps1|vbs|js|msi|com|scr))\s+(-|/)') {
            return $matches[1].Trim()
        }
        
        # 16. Drive paths with space + word arguments (non-path arguments)
        if ($expanded -match '([A-Za-z]:[^"]*\.(exe|dll|bat|cmd|ps1|vbs|js|msi|com|scr))\s+([a-zA-Z]+)' -and $matches[3] -notmatch '^[A-Za-z]:') {
            return $matches[1].Trim()
        }
        
        # 17. UNC paths
        if ($expanded -match '(\\\\[^\\]+\\[^\s"]+\.(exe|dll|bat|cmd|ps1|vbs|js|msi|com|scr))') {
            return $matches[1].Trim()
        }
        
        # 18. Simple executable names with arguments - handle cases like "BthUdTask.exe $(Arg0)"
        if ($expanded -match '^([a-zA-Z][a-zA-Z0-9]*\.(exe|com|scr|dll))(\s|$)') {
            $file = $matches[1]
            return Find-ExecutableInSystemPaths $file
        }
        
        # 19. Look for any executable file in command line arguments - improved validation
        if ($expanded -match '([A-Za-z]:[^"]*\.(exe|dll|bat|cmd|ps1|vbs|js|msi|com|scr|lnk|cpl|hta|wsf))') {
            $path = $matches[1] -replace '[,;]+$', ''
            # Validate path doesn't contain invalid characters
            if ($path -notmatch '[\<\>\|\*\?]') {
                return $path
            }
        }
        
        # 20. FINAL FALLBACK - if nothing else worked and we have a non-empty string, return it
        if (![string]::IsNullOrWhiteSpace($expanded)) {
            return $expanded.Trim()
        }
        
        return $null
        
    }
    catch {
        Write-Verbose "Error parsing command line '$CommandLine': $($_.Exception.Message)"
        # Even on error, try the fallback
        if (![string]::IsNullOrWhiteSpace($CommandLine)) {
            return $CommandLine.Trim()
        }
        return $null
    }
}


function Find-ExecutableInSystemPaths {
    param([string]$FileName)
        
    if ([string]::IsNullOrWhiteSpace($FileName)) { 
        return $FileName 
    }
        
    # Define search paths in order of priority
    $searchPaths = @(
        "C:\Windows\System32",
        "C:\Windows\SysWOW64", 
        "C:\Windows",
        "C:\Program Files\Windows NT\Accessories",
        "C:\Program Files\Common Files\Microsoft Shared",
        "C:\Windows\System32\WindowsPowerShell\v1.0\",
        "C:\Windows\SysWOW64\WindowsPowerShell\v1.0\",
        "C:\Users\<YourUsername>\AppData\Local\Microsoft\PowerShell\7\",
        "C:\Program Files\PowerShell\7\"
    )
        
    foreach ($searchPath in $searchPaths) {
        $fullPath = Join-Path $searchPath $FileName
        if (Test-Path $fullPath -ErrorAction SilentlyContinue) {
            return $fullPath
        }
    }
        
    # If not found, return the original filename
    return $FileName
}


# Script-level variable to track mounted hives across all functions
if ($null -eq $script:GlobalMountedHives) {
    $script:GlobalMountedHives = @()
}

function Close-RegistryHandles {
    <#
    .SYNOPSIS
    Forces garbage collection to release registry handles held by PowerShell.
    
    .DESCRIPTION
    Performs multiple garbage collection passes to ensure all registry handles 
    are released before attempting to dismount hives. This is critical for
    allowing registry hives to be dismounted cleanly.
    #>
    [CmdletBinding()]
    param()
    
    Write-Verbose "Forcing garbage collection to release registry handles..."
    
    # Close all PowerShell drives pointing to registry
    try {
        Get-PSDrive -PSProvider Registry -ErrorAction SilentlyContinue | 
        Where-Object { $_.Root -like "*TEMP_DFIR*" } | 
        ForEach-Object {
            try {
                Remove-PSDrive -Name $_.Name -Force -ErrorAction SilentlyContinue
                Write-Verbose "Removed PSDrive: $($_.Name)"
            }
            catch {
                Write-Verbose "Could not remove PSDrive $($_.Name): $($_.Exception.Message)"
            }
        }
    }
    catch {
        Write-Verbose "Error enumerating PSDrives: $($_.Exception.Message)"
    }
    
    # Multiple aggressive GC passes
    for ($i = 1; $i -le 3; $i++) {
        [System.GC]::Collect([System.GC]::MaxGeneration, [System.GCCollectionMode]::Forced)
        [System.GC]::WaitForPendingFinalizers()
        [System.GC]::Collect([System.GC]::MaxGeneration, [System.GCCollectionMode]::Forced)
        Start-Sleep -Milliseconds 200
    }
    
    # Additional pause to allow OS to fully release handles
    Start-Sleep -Milliseconds 1000
    
    Write-Verbose "Registry handle cleanup complete"
}

function Mount-RegistryHive {
    <#
    .SYNOPSIS
    Mounts an unloaded user registry hive.
    
    .DESCRIPTION
    Loads an NTUSER.DAT file into the registry under HKU (HKEY_USERS) for analysis.
    Tracks mounted hives in script-level variable for later cleanup.
    
    .PARAMETER NtUserPath
    Path to the NTUSER.DAT file to mount.
    
    .PARAMETER SID
    Security identifier (SID) of the user profile.
    
    .PARAMETER Quiet
    Suppress informational output.
    
    .OUTPUTS
    String. Returns the registry path if successful, null if failed.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$NtUserPath,
        
        [Parameter(Mandatory = $true)]
        [string]$SID,
        
        [switch]$Quiet
    )
    
    if (-not (Test-Path $NtUserPath -ErrorAction SilentlyContinue)) {
        Write-Verbose "NTUSER.DAT not found: $NtUserPath"
        return $null
    }
    
    $mountPoint = "TEMP_DFIR_$($SID.Replace('-','_'))"
    $testPath = "Registry::HKEY_USERS\$mountPoint"
    
    try {
        # Check if already mounted
        if (Test-Path $testPath -ErrorAction SilentlyContinue) {
            Write-Verbose "Hive already mounted: $mountPoint"
            $mountedHivePath = "Microsoft.PowerShell.Core\Registry::HKEY_USERS\$mountPoint"
            
            # Ensure it's tracked
            if ($script:GlobalMountedHives -notcontains $mountPoint) {
                $script:GlobalMountedHives += $mountPoint
            }
            
            # (Username display removed - shown in profile discovery phase)
            
            return $mountedHivePath
        }
        
        # Attempt to mount
        $result = & reg.exe load "HKU\$mountPoint" $NtUserPath 2>&1
        
        if ($LASTEXITCODE -eq 0) {
            # Verify the mount succeeded
            Start-Sleep -Milliseconds 200
            
            if (Test-Path $testPath -ErrorAction SilentlyContinue) {
                $mountedHivePath = "Microsoft.PowerShell.Core\Registry::HKEY_USERS\$mountPoint"
                $script:GlobalMountedHives += $mountPoint
                
                Write-Verbose "Successfully mounted: $SID at $mountPoint"
                # (Username display removed - shown in profile discovery phase)
                
                return $mountedHivePath
            }
            else {
                Write-Verbose "Mount reported success but path not accessible: $mountPoint"
                return $null
            }
        }
        else {
            Write-Verbose "Failed to mount $SID (exit code: $LASTEXITCODE)"
            return $null
        }
    }
    catch {
        Write-Verbose "Error mounting $SID : $($_.Exception.Message)"
        return $null
    }
}

function Dismount-AllRegistryHives {
    <#
    .SYNOPSIS
    Dismounts all temporarily loaded registry hives.
    
    .DESCRIPTION
    Dismounts all hives tracked in the global mounted hives array, plus discovers
    any orphaned TEMP_DFIR_ hives. Uses proper handle cleanup and reports results.
    
    .PARAMETER Quiet
    Suppress informational output.
    #>
    [CmdletBinding()]
    param([switch]$Quiet)
    
    # Discover any orphaned TEMP_DFIR_ hives
    $discoveredHives = @()
    try {
        $hkuSubkeys = Get-ChildItem "Registry::HKEY_USERS" -ErrorAction SilentlyContinue
        $discoveredHives = $hkuSubkeys | 
        Where-Object { $_.Name -like "*TEMP_DFIR*" } | 
        ForEach-Object { Split-Path $_.Name -Leaf }
    }
    catch {
        Write-Verbose "Error discovering orphaned hives: $($_.Exception.Message)"
    }
    
    # Combine tracked and discovered hives
    $allHivesToDismount = @()
    if ($script:GlobalMountedHives) { 
        $allHivesToDismount += $script:GlobalMountedHives 
    }
    if ($discoveredHives) { 
        $allHivesToDismount += $discoveredHives 
    }
    $allHivesToDismount = $allHivesToDismount | Select-Object -Unique
    
    if ($allHivesToDismount.Count -eq 0) {
        Write-Verbose "No temporary hives to dismount"
        return
    }
    
    # Aggressive cleanup
    Close-RegistryHandles
    
    $successCount = 0
    $failedHives = @()
    
    foreach ($mountPoint in $allHivesToDismount) {
        Write-Verbose "Attempting to dismount: $mountPoint"
        
        # Single attempt with proper cleanup
        Close-RegistryHandles
        
        $hivePath = "Registry::HKEY_USERS\$mountPoint"
        if (-not (Test-Path $hivePath -ErrorAction SilentlyContinue)) {
            Write-Verbose "$mountPoint already dismounted"
            $successCount++
            continue
        }
        
        try {
            $pinfo = New-Object System.Diagnostics.ProcessStartInfo
            $pinfo.FileName = "reg.exe"
            $pinfo.Arguments = "unload `"HKU\$mountPoint`""
            $pinfo.UseShellExecute = $false
            $pinfo.RedirectStandardOutput = $true
            $pinfo.RedirectStandardError = $true
            $pinfo.CreateNoWindow = $true
            
            $process = New-Object System.Diagnostics.Process
            $process.StartInfo = $pinfo
            [void]$process.Start()
            $completed = $process.WaitForExit(5000)
            
            if ($completed -and $process.ExitCode -eq 0) {
                Start-Sleep -Milliseconds 200
                if (-not (Test-Path $hivePath -ErrorAction SilentlyContinue)) {
                    Write-Verbose "Successfully dismounted: $mountPoint"
                    $successCount++
                }
                else {
                    $failedHives += $mountPoint
                }
            }
            else {
                $failedHives += $mountPoint
            }
        }
        catch {
            $failedHives += $mountPoint
        }
    }
    
    # Clear tracking
    $script:GlobalMountedHives = @()
    
    # Report results
    if (-not $Quiet) {
        if ($successCount -gt 0) {
            Write-Host "[OK] Dismounted $successCount hive(s)" -ForegroundColor Green
        }
        if ($failedHives.Count -gt 0) {
            Write-Host "[INFO] $($failedHives.Count) hive(s) remain mounted (will clear on reboot)" -ForegroundColor Yellow
        }
    }
    
    Write-Verbose "Dismount complete: $successCount successful, $($failedHives.Count) failed"
}

function Get-RegistryHivesForAnalysis {
    <#
    .SYNOPSIS
    Gets registry hives for analysis with optional unloaded hive mounting.
    
    .DESCRIPTION
    Returns a list of registry hive paths for analysis. Can optionally load
    unloaded user profile hives for comprehensive analysis.
    
    .PARAMETER LoadUnloadedHives
    If specified, attempts to mount unloaded user registry hives.
    
    .PARAMETER HiveFilter
    Filter which hives to return: HKLM, HKCU, HKCR, HKU, HKCC, or All.
    
    .PARAMETER Quiet
    Suppress informational output.
    
    .OUTPUTS
    ArrayList of registry hive paths.
    #>
    [CmdletBinding()]
    param(
        [switch]$LoadUnloadedHives,
        
        [ValidateSet('HKLM', 'HKCU', 'HKCR', 'HKU', 'HKCC', 'All')]
        [string]$HiveFilter = 'All',
        
        [switch]$Quiet
    )
    
    $hiveList = [Collections.ArrayList]::new()
    
    # Check admin privileges if loading unloaded hives
    if ($LoadUnloadedHives) {
        $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
        
        if (-not $isAdmin) {
            Write-Warning "Administrator privileges required for loading unloaded hives. Continuing with loaded hives only."
            $LoadUnloadedHives = $false
        }
    }
    
    # Add main hives based on filter
    if ($HiveFilter -eq 'All' -or $HiveFilter -eq 'HKLM') {
        $hklm = Get-Item Registry::HKEY_LOCAL_MACHINE -ErrorAction SilentlyContinue
        if ($hklm) { $null = $hiveList.Add($hklm.PSPath) }
    }
    
    if ($HiveFilter -eq 'All' -or $HiveFilter -eq 'HKCU') {
        $hkcu = Get-Item Registry::HKEY_CURRENT_USER -ErrorAction SilentlyContinue
        if ($hkcu) { $null = $hiveList.Add($hkcu.PSPath) }
    }
    
    if ($HiveFilter -eq 'All' -or $HiveFilter -eq 'HKCR') {
        $hkcr = Get-Item Registry::HKEY_CLASSES_ROOT -ErrorAction SilentlyContinue
        if ($hkcr) { $null = $hiveList.Add($hkcr.PSPath) }
    }
    
    $loadedUserHives = $null
    if ($HiveFilter -eq 'All' -or $HiveFilter -eq 'HKU') {
        $loadedUserHives = Get-ChildItem Registry::HKEY_USERS -ErrorAction SilentlyContinue
        foreach ($hive in $loadedUserHives) {
            $null = $hiveList.Add($hive.PSPath)
        }
    }
    
    if ($HiveFilter -eq 'All' -or $HiveFilter -eq 'HKCC') {
        $hkcc = Get-Item Registry::HKEY_CURRENT_CONFIG -ErrorAction SilentlyContinue
        if ($hkcc) { $null = $hiveList.Add($hkcc.PSPath) }
    }
    
    # Load unloaded user profiles if requested
    if ($LoadUnloadedHives -and ($HiveFilter -eq 'All' -or $HiveFilter -eq 'HKU')) {
        if (-not $Quiet) {
            Write-Host "[INFO] Loading unloaded user registry hives..." -ForegroundColor Yellow
        }
        
        try {
            $profileListPath = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList"
            $profiles = Get-ChildItem $profileListPath -ErrorAction Stop
            
            # Display all profiles that will be processed
            if (-not $Quiet) {
                Write-Host "`n[PROFILES]" -ForegroundColor Cyan
                foreach ($profile in $profiles) {
                    $sid = Split-Path $profile.Name -Leaf
                    $profileData = Get-ItemProperty $profile.PSPath -ErrorAction SilentlyContinue
                    
                    if ($profileData.ProfileImagePath) {
                        $username = Split-Path $profileData.ProfileImagePath -Leaf
                        
                        # Check if already loaded (including TEMP_DFIR_ mounts)
                        $sidUnderscore = $sid.Replace('-', '_')
                        $alreadyLoaded = $loadedUserHives | Where-Object { 
                            $_.Name -like "*$sid*" -or $_.PSChildName -like "*TEMP_DFIR*$sidUnderscore*"
                        }
                        
                        # Double-check with Test-Path for TEMP_DFIR mounts
                        $mountPoint = "TEMP_DFIR_$sidUnderscore"
                        $tempMountExists = Test-Path "Registry::HKEY_USERS\$mountPoint" -ErrorAction SilentlyContinue
                        
                        if ($alreadyLoaded -or $tempMountExists) {
                            Write-Host "  [LOADED] " -NoNewline -ForegroundColor Green
                        }
                        else {
                            Write-Host "  [MOUNTING] " -NoNewline -ForegroundColor Yellow
                        }
                        Write-Host "$username " -NoNewline -ForegroundColor Cyan
                        Write-Host "($sid)" -ForegroundColor DarkGray
                    }
                }
                Write-Host ""
            }
            
            $mountedCount = 0
            
            foreach ($profile in $profiles) {
                $sid = Split-Path $profile.Name -Leaf
                
                # Skip if SID is already loaded (including TEMP_DFIR_ mounts)
                $sidUnderscore = $sid.Replace('-', '_')
                $alreadyLoaded = $loadedUserHives | Where-Object { 
                    $_.Name -like "*$sid*" -or $_.PSChildName -like "*TEMP_DFIR*$sidUnderscore*"
                }
                
                # Also check if TEMP_DFIR mount exists
                $mountPoint = "TEMP_DFIR_$sidUnderscore"
                $tempMountExists = Test-Path "Registry::HKEY_USERS\$mountPoint" -ErrorAction SilentlyContinue
                
                if ($alreadyLoaded -or $tempMountExists) { 
                    Write-Verbose "Profile already loaded or mounted: $sid"
                    
                    # If it's a TEMP_DFIR mount, add it to hiveList and tracking
                    if ($tempMountExists) {
                        $mountedHivePath = "Microsoft.PowerShell.Core\Registry::HKEY_USERS\$mountPoint"
                        if ($hiveList -notcontains $mountedHivePath) {
                            $null = $hiveList.Add($mountedHivePath)
                        }
                        if ($script:GlobalMountedHives -notcontains $mountPoint) {
                            $script:GlobalMountedHives += $mountPoint
                        }
                    }
                    continue 
                }
                
                # Get profile path
                $profileData = Get-ItemProperty $profile.PSPath -ErrorAction SilentlyContinue
                if (-not $profileData.ProfileImagePath) { 
                    Write-Verbose "No ProfileImagePath for: $sid"
                    continue 
                }
                
                $ntUserPath = Join-Path $profileData.ProfileImagePath "NTUSER.DAT"
                
                # Attempt to mount
                $mountedPath = Mount-RegistryHive -NtUserPath $ntUserPath -SID $sid -Quiet:$Quiet
                
                if ($mountedPath) {
                    $null = $hiveList.Add($mountedPath)
                    $mountedCount++
                }
            }
            
            if (-not $Quiet) {
                if ($mountedCount -gt 0) {
                    Write-Host "[+] Successfully mounted $mountedCount unloaded user hive(s)" -ForegroundColor Green
                }
                else {
                    Write-Host "[-] No unloaded hives to mount" -ForegroundColor Yellow
                }
            }
        }
        catch {
            Write-Warning "Failed to enumerate user profiles: $($_.Exception.Message)"
        }
    }
    
    Write-Verbose "Returning $($hiveList.Count) registry hives (Mounted: $($script:GlobalMountedHives.Count))"
    return $hiveList
}

# -------------------



# Function Exports
# -------------------
function Hunt-ForensicDump {
    <#
    .SYNOPSIS
    Hunt-ForensicDump performs comprehensive DFIR data collection and generates forensic reports.
    
    .DESCRIPTION
    Hunt-ForensicDump is a master function that coordinates all Hunt-* modules for comprehensive
    forensic data collection and HTML report generation. It creates a complete forensic snapshot
    with an interactive HTML report containing system info, persistence, filesystem, registry,
    browser history, event logs, services, and scheduled tasks.

    MODES:
    - Auto Mode (default): Balanced detection with 7-day default range
    * Focuses on core Windows logs (PowerShell, Security, System, Application, and custom logs)
    * Standard file extensions and persistence locations
    * Excludes system folders to reduce noise
    * NOTE: Hunt-Persistence always runs in Aggressive mode regardless of ForensicDump mode
    
    - Aggressive Mode: Comprehensive detection with broader scope
    * All available Windows event logs
    * Expanded file extension coverage (more suspicious file types)
    * Includes system folders (Windows, Program Files)
    * More permissive detection rules (higher false positive rate)
    * Hunt-Persistence runs in Aggressive mode (same as Auto mode)

    DATE RANGES:
    - Specify exact dates: -StartDate "2024-01-01" -EndDate "2024-12-31"
    - Relative formats: -StartDate "7D" (7 days), "24H" (24 hours), "30M" (30 minutes)
    - All time: -StartDate "AllTime" or omit -StartDate
    
    LOADFROMJSON MODE:
    - Load previously collected forensic data from JSON files
    - Useful for regenerating HTML reports with different settings
    - Specify path to output directory or JSON_Files subfolder
    
    .PARAMETER StartDate
    Start date for searches. Accepts datetime, relative formats (3D, 24H), or 'AllTime'.
    
    .PARAMETER EndDate
    End date for searches. Defaults to 'Now'.
    
    .PARAMETER Auto
    Run in automatic mode with balanced detection settings. This is the default.
    
    .PARAMETER Aggressive
    Run in aggressive mode with comprehensive detection settings.
    
    .PARAMETER ExportLogs
    Export all EVTX files to archive.
    
    .PARAMETER OutputDir
    Directory for forensic dump output. Default: C:\ForensicDump_[timestamp]
    
    .PARAMETER Config
    Array of modules to include in forensic dump. Options: 'All', 'Persistence', 'Files', 'Registry', 'Browser', 'Logs', 'Services', 'Tasks'. Default: @('All')
    
    .PARAMETER MaxChars
    Maximum characters per cell before truncation in HTML report. Default: 500
    
    .PARAMETER MaxRows
    Maximum rows to display per table in HTML report. 0 = unlimited. Default: 10000
    
    .PARAMETER AllFields
    Show all fields in HTML report (disable field omission for cleaner display).
    
    .PARAMETER Timezone
    Timezone identifier for timestamp conversion. Default: system timezone.
    
    .PARAMETER LoadBrowserTool
    Switch to enable LoadTool mode for browser history extraction using NirSoft's BrowsingHistoryView.
    
    .PARAMETER LoadToolPath
    Optional path to local BrowsingHistoryView.exe. If not provided, downloads from NirSoft.
    
    .EXAMPLE
    Hunt-ForensicDump -StartDate "7D" -Auto
    
    .EXAMPLE
    Hunt-ForensicDump -LoadTool "C:\Tools\BrowsingHistoryView.exe" -StartDate "30D"
    
    .EXAMPLE
    Hunt-ForensicDump -Config @('Persistence', 'Files', 'Logs') -StartDate "30D"
    
    .EXAMPLE
    Hunt-ForensicDump -Aggressive -StartDate "AllTime"
    
    .EXAMPLE
    Hunt-ForensicDump -StartDate "AllTime" -MaxRows 10000 -MaxChars 300
    
    .EXAMPLE
    Hunt-ForensicDump -ExportLogs -OutputDir "C:\Evidence\Case001"

    .EXAMPLE
    Hunt-ForensicDump -LoadBrowserTool -StartDate "30D"
    Uses LoadTool mode, downloads BrowsingHistoryView, and performs forensic dump for last 30 days.
    
    .EXAMPLE
    Hunt-ForensicDump -LoadBrowserTool -LoadToolPath "C:\Tools\BrowsingHistoryView.exe" -StartDate "7D"
    Uses local BrowsingHistoryView executable for browser history extraction.
    
    .EXAMPLE
    Hunt-ForensicDump -LoadFromJson "C:\ForensicDump_PC01_20250115\JSON_Files"
    Loads previously collected JSON data and regenerates HTML report.
    
    .EXAMPLE
    Hunt-ForensicDump -LoadFromJson ".\ForensicDump_PC01_20250115" -MaxRows 5000
    Loads JSON data from relative path and limits HTML display to 5000 rows per table.
    
    .NOTES
    - Hunt-Persistence runs without -Aggressive flag (preserves original flags from function)
    - LoadFromJson mode bypasses data collection and regenerates HTML reports from existing JSON
    - Use -LoadBrowserTool for most accurate browser history extraction (downloads NirSoft tool)
    - LoadToolPath parameter requires -LoadBrowserTool switch to be effective
    - MaxRows=0 displays all embedded data (may impact browser performance with large datasets)
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        $StartDate,
        
        [Parameter(Mandatory = $false)]
        $EndDate = "Now",
        
        [Parameter(Mandatory = $false)]
        [switch]$Auto,
        
        [Parameter(Mandatory = $false)]
        [switch]$Aggressive,
        
        [Parameter(Mandatory = $false)]
        [switch]$ExportLogs,
        
        [Parameter(Mandatory = $false)]
        [string]$OutputDir = "",

        [Parameter(Mandatory = $false)]
        [ValidateSet('All', 'Persistence', 'Files', 'Registry', 'Browser', 'Logs', 'Services', 'Tasks')]
        [string[]]$Config = @('All'),

        [Parameter(Mandatory = $false)]
        [int]$MaxChars = 500,

        [Parameter(Mandatory = $false)]
        [int]$MaxRows = 10000, 

        [Parameter(Mandatory = $false)]
        [switch]$AllFields,
        
        [Parameter(Mandatory = $false)]
        [switch]$LoadBrowserTool,
        
        [Parameter(Mandatory = $false)]
        [string]$LoadToolPath = "",
    
        [Parameter(Mandatory = $false)]
        [string]$LoadFromJson = ""
    )

    # PowerShell version check
    if ($PSVersionTable.PSVersion.Major -lt 5) {
        Write-Error "This function requires PowerShell 5.0 or higher. Current version: $($PSVersionTable.PSVersion)"
        return
    }

    # Helper function: Get AMSI Providers
    function Get-AMSIProviders {
        try {
            $amsiProviders = @()
            $amsiKey = "HKLM:\SOFTWARE\Microsoft\AMSI\Providers"
            
            # Phase 1: Registry-based AMSI provider detection
            if (Test-Path $amsiKey) {
                $providers = Get-ChildItem -Path $amsiKey -ErrorAction SilentlyContinue
                foreach ($provider in $providers) {
                    try {
                        $providerGuid = $provider.PSChildName
                        $clsidPath = "HKLM:\SOFTWARE\Classes\CLSID\$providerGuid"
                        $providerName = "Unknown"
                        $dllPath = "N/A"
                        $threadingModel = "N/A"
                        
                        if (Test-Path $clsidPath) {
                            # Get the provider name from the default value
                            $clsidKey = Get-ItemProperty -Path $clsidPath -ErrorAction SilentlyContinue
                            if ($clsidKey -and $clsidKey.PSObject.Properties['(default)']) {
                                $providerName = $clsidKey.'(default)'
                            }
                            
                            # Get the DLL path from InprocServer32
                            $inprocPath = "$clsidPath\InprocServer32"
                            if (Test-Path $inprocPath) {
                                $inprocKey = Get-ItemProperty -Path $inprocPath -ErrorAction SilentlyContinue
                                if ($inprocKey) {
                                    if ($inprocKey.PSObject.Properties['(default)']) {
                                        $dllPath = $inprocKey.'(default)'
                                    }
                                    if ($inprocKey.PSObject.Properties['ThreadingModel']) {
                                        $threadingModel = $inprocKey.ThreadingModel
                                    }
                                }
                            }
                        }
                        
                        # Check if DLL exists on disk and calculate MD5
                        $dllExists = $false
                        $dllSize = 0
                        $dllMD5 = "N/A"
                        if ($dllPath -ne "N/A" -and (Test-Path $dllPath -ErrorAction SilentlyContinue)) {
                            $dllExists = $true
                            $dllFile = Get-Item $dllPath -ErrorAction SilentlyContinue
                            if ($dllFile) {
                                $dllSize = [math]::Round($dllFile.Length / 1KB, 2)
                                
                                # Calculate MD5 hash
                                try {
                                    $md5 = [System.Security.Cryptography.MD5]::Create()
                                    $fileStream = [System.IO.File]::OpenRead($dllPath)
                                    try {
                                        $hashBytes = $md5.ComputeHash($fileStream)
                                        $dllMD5 = [System.BitConverter]::ToString($hashBytes) -replace '-', ''
                                    }
                                    finally {
                                        $fileStream.Close()
                                        $fileStream.Dispose()
                                    }
                                }
                                catch {
                                    $dllMD5 = "Error"
                                    Write-Verbose "Failed to calculate MD5 for $dllPath : $($_.Exception.Message)"
                                }
                            }
                        }
                        
                        $amsiProviders += [PSCustomObject]@{
                            GUID            = $providerGuid
                            Name            = $providerName
                            DLLPath         = $dllPath
                            DLLExists       = $dllExists
                            DLLSizeKB       = $dllSize
                            DLLMd5          = $dllMD5
                            ThreadingModel  = $threadingModel
                            DetectionMethod = "Registry"
                        }
                    }
                    catch {
                        Write-Verbose "Error processing AMSI provider $providerGuid : $($_.Exception.Message)"
                        continue
                    }
                }
            }
            
            # Phase 2: Process-based AMSI provider detection (loaded modules)
            try {
                $loadedAMSI = @{}
                $processes = Get-Process -ErrorAction SilentlyContinue
                
                foreach ($proc in $processes) {
                    try {
                        # Look for AMSI-related modules (including vendor-specific like TmAMSI, MsMpEng, etc.)
                        $modules = $proc.Modules | Where-Object { 
                            $_.ModuleName -like "*amsi*" -or 
                            $_.ModuleName -like "Tm*AMSI*" -or
                            $_.ModuleName -like "*AMSIProvider*"
                        }
                        
                        foreach ($mod in $modules) {
                            $modKey = $mod.FileName
                            
                            # Track unique modules and which processes they're loaded in
                            if (-not $loadedAMSI.ContainsKey($modKey)) {
                                $loadedAMSI[$modKey] = @{
                                    ModuleName = $mod.ModuleName
                                    ModulePath = $mod.FileName
                                    Processes  = @()
                                }
                            }
                            
                            $loadedAMSI[$modKey].Processes += "$($proc.Name) (PID: $($proc.Id))"
                        }
                    }
                    catch {
                        # Access denied for some processes - continue
                        continue
                    }
                }
                
                # Add loaded modules to provider list
                foreach ($modKey in $loadedAMSI.Keys) {
                    $modInfo = $loadedAMSI[$modKey]
                    
                    # Check if already in registry-based list
                    $existingProvider = $amsiProviders | Where-Object { 
                        $_.DLLPath -eq $modInfo.ModulePath 
                    } | Select-Object -First 1
                    
                    if ($existingProvider) {
                        # Update existing provider with process info
                        $existingProvider | Add-Member -NotePropertyName 'LoadedInProcesses' -NotePropertyValue ($modInfo.Processes -join '; ') -Force
                        $existingProvider.DetectionMethod = "Registry+Process"
                    }
                    else {
                        # Add as new provider (not in registry but loaded)
                        $dllExists = Test-Path $modInfo.ModulePath -ErrorAction SilentlyContinue
                        $dllSize = 0
                        $dllMD5 = "N/A"
                        if ($dllExists) {
                            $dllFile = Get-Item $modInfo.ModulePath -ErrorAction SilentlyContinue
                            if ($dllFile) {
                                $dllSize = [math]::Round($dllFile.Length / 1KB, 2)
                                
                                # Calculate MD5 hash
                                try {
                                    $md5 = [System.Security.Cryptography.MD5]::Create()
                                    $fileStream = [System.IO.File]::OpenRead($modInfo.ModulePath)
                                    $hashBytes = $md5.ComputeHash($fileStream)
                                    $fileStream.Close()
                                    $dllMD5 = [System.BitConverter]::ToString($hashBytes) -replace '-', ''
                                }
                                catch {
                                    $dllMD5 = "Error"
                                    Write-Verbose "Failed to calculate MD5 for $($modInfo.ModulePath) : $($_.Exception.Message)"
                                }
                            }
                        }
                        
                        $amsiProviders += [PSCustomObject]@{
                            GUID              = "N/A"
                            Name              = "Loaded Module: $($modInfo.ModuleName)"
                            DLLPath           = $modInfo.ModulePath
                            DLLExists         = $dllExists
                            DLLSizeKB         = $dllSize
                            DLLMd5            = $dllMD5
                            ThreadingModel    = "N/A"
                            DetectionMethod   = "Process"
                            LoadedInProcesses = ($modInfo.Processes -join '; ')
                        }
                    }
                }
                
                Write-Verbose "Found $($loadedAMSI.Count) unique AMSI modules loaded in processes"
            }
            catch {
                Write-Verbose "Could not enumerate loaded AMSI modules: $($_.Exception.Message)"
            }
            
            # Phase 3: Check Windows Defender AMSI integration
            try {
                $defenderAmsi = Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows Defender\Features" -Name "MpEngine" -ErrorAction SilentlyContinue
                if ($defenderAmsi) {
                    # Check if amsi.dll is in Windows Defender directory
                    $defenderPath = "$env:ProgramFiles\Windows Defender"
                    $defenderAmsiPath = Join-Path $defenderPath "MpOav.dll"
                    
                    if (Test-Path $defenderAmsiPath) {
                        $existing = $amsiProviders | Where-Object { $_.DLLPath -eq $defenderAmsiPath }
                        if (-not $existing) {
                            $dllFile = Get-Item $defenderAmsiPath -ErrorAction SilentlyContinue
                            $dllSize = if ($dllFile) { [math]::Round($dllFile.Length / 1KB, 2) } else { 0 }
                            
                            # Calculate MD5 hash
                            $dllMD5 = "N/A"
                            if ($dllFile) {
                                try {
                                    $md5 = [System.Security.Cryptography.MD5]::Create()
                                    $fileStream = [System.IO.File]::OpenRead($defenderAmsiPath)
                                    $hashBytes = $md5.ComputeHash($fileStream)
                                    $fileStream.Close()
                                    $dllMD5 = [System.BitConverter]::ToString($hashBytes) -replace '-', ''
                                }
                                catch {
                                    $dllMD5 = "Error"
                                    Write-Verbose "Failed to calculate MD5 for Defender AMSI: $($_.Exception.Message)"
                                }
                            }
                            
                            $amsiProviders += [PSCustomObject]@{
                                GUID            = "N/A"
                                Name            = "Windows Defender AMSI"
                                DLLPath         = $defenderAmsiPath
                                DLLExists       = $true
                                DLLSizeKB       = $dllSize
                                DLLMd5          = $dllMD5
                                ThreadingModel  = "N/A"
                                DetectionMethod = "Defender Integration"
                            }
                        }
                    }
                }
            }
            catch {
                Write-Verbose "Could not check Windows Defender AMSI integration: $($_.Exception.Message)"
            }
            
            return $amsiProviders
        }
        catch {
            Write-Verbose "AMSI provider enumeration failed: $($_.Exception.Message)"
            return @()
        }
    }


    # Helper function: Get Comprehensive AntiVirus Information
    function Get-AntiVirusInfo {
        try {
            $avInfo = @{
                SecurityCenter = @()
                DefenderStatus = $null
                InstalledAV    = @()
                AVServices     = @()
                AVDrivers      = @()
            }
            
            # Phase 1: SecurityCenter2 AntiVirus Products
            Write-Verbose "Querying SecurityCenter2 for AV products..."
            try {
                $avProducts = Get-CimInstance -Namespace 'root/SecurityCenter2' -ClassName 'AntivirusProduct' -ErrorAction SilentlyContinue
                if ($avProducts) {
                    foreach ($av in $avProducts) {
                        # Decode productState to determine status
                        $productState = $av.productState
                        $hex = [Convert]::ToString($productState, 16).PadLeft(6, '0')
                        $enabled = $hex.Substring(2, 2) -eq '10'
                        $upToDate = $hex.Substring(4, 2) -eq '00'
                        
                        $avInfo.SecurityCenter += [PSCustomObject]@{
                            DisplayName              = $av.displayName
                            InstanceGuid             = $av.instanceGuid
                            PathToSignedProductExe   = $av.pathToSignedProductExe
                            PathToSignedReportingExe = $av.pathToSignedReportingExe
                            ProductState             = $productState
                            Enabled                  = $enabled
                            UpToDate                 = $upToDate
                            Timestamp                = $av.timestamp
                        }
                    }
                }
            }
            catch {
                Write-Verbose "SecurityCenter2 query failed: $($_.Exception.Message)"
            }
            
            # Phase 2: Windows Defender Detailed Status
            Write-Verbose "Querying Windows Defender status..."
            try {
                $defenderStatus = Get-MpComputerStatus -ErrorAction SilentlyContinue
                if ($defenderStatus) {
                    $avInfo.DefenderStatus = [PSCustomObject]@{
                        AMRunning                     = $defenderStatus.AMRunningMode
                        AMServiceEnabled              = $defenderStatus.AMServiceEnabled
                        AMProductVersion              = $defenderStatus.AMProductVersion
                        AntivirusEnabled              = $defenderStatus.AntivirusEnabled
                        RealTimeProtectionEnabled     = $defenderStatus.RealTimeProtectionEnabled
                        BehaviorMonitorEnabled        = $defenderStatus.BehaviorMonitorEnabled
                        IoavProtectionEnabled         = $defenderStatus.IoavProtectionEnabled
                        OnAccessProtectionEnabled     = $defenderStatus.OnAccessProtectionEnabled
                        AntivirusSignatureLastUpdated = $defenderStatus.AntivirusSignatureLastUpdated
                        QuickScanAge                  = $defenderStatus.QuickScanAge
                        FullScanAge                   = $defenderStatus.FullScanAge
                    }
                }
            }
            catch {
                Write-Verbose "Windows Defender query failed: $($_.Exception.Message)"
            }
            
            # Phase 3: Registry-based AV Software Detection
            Write-Verbose "Scanning registry for installed AV software..."
            try {
                $regPaths = @(
                    'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*',
                    'HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*'
                )
                
                $avKeywords = @('AV', 'Antivirus', 'Anti-virus', 'ESET', 'McAfee', 'Symantec', 'Norton', 
                    'Trend', 'Sophos', 'Kaspersky', 'Bitdefender', 'Avast', 'AVG', 'Malwarebytes',
                    'Defender', 'CrowdStrike', 'SentinelOne', 'Carbon Black', 'Cylance')
                
                foreach ($path in $regPaths) {
                    $items = Get-ItemProperty -Path $path -ErrorAction SilentlyContinue
                    foreach ($item in $items) {
                        if ($item.DisplayName) {
                            foreach ($keyword in $avKeywords) {
                                if ($item.DisplayName -match $keyword) {
                                    # Check if already added (avoid duplicates)
                                    $exists = $avInfo.InstalledAV | Where-Object { 
                                        $_.DisplayName -eq $item.DisplayName -and 
                                        $_.DisplayVersion -eq $item.DisplayVersion 
                                    }
                                    
                                    if (-not $exists) {
                                        $avInfo.InstalledAV += [PSCustomObject]@{
                                            DisplayName     = $item.DisplayName
                                            DisplayVersion  = $item.DisplayVersion
                                            Publisher       = $item.Publisher
                                            InstallDate     = $item.InstallDate
                                            InstallLocation = $item.InstallLocation
                                        }
                                    }
                                    break
                                }
                            }
                        }
                    }
                }
            }
            catch {
                Write-Verbose "Registry AV scan failed: $($_.Exception.Message)"
            }
            
            # Phase 4: AV-Related Services
            Write-Verbose "Scanning for AV-related services..."
            try {
                $avServiceKeywords = @('Defend', 'McAfee', 'Symantec', 'Sophos', 'ESET', 'Trend', 'Kaspersky', 
                    'Bitdefender', 'Avast', 'AVG', 'Malwarebytes', 'CrowdStrike', 'Sentinel',
                    'Carbon', 'Cylance', 'AV', 'Virus', 'Malware')
                
                $services = Get-Service -ErrorAction SilentlyContinue | Where-Object {
                    $serviceName = $_.DisplayName + $_.Name
                    $match = $false
                    foreach ($keyword in $avServiceKeywords) {
                        if ($serviceName -match $keyword) {
                            $match = $true
                            break
                        }
                    }
                    $match
                }
                
                foreach ($svc in $services) {
                    $avInfo.AVServices += [PSCustomObject]@{
                        Name        = $svc.Name
                        DisplayName = $svc.DisplayName
                        Status      = $svc.Status
                        StartType   = $svc.StartType
                    }
                }
            }
            catch {
                Write-Verbose "Service scan failed: $($_.Exception.Message)"
            }
            
            # Phase 5: AV-Related Drivers
            Write-Verbose "Scanning for AV-related drivers..."
            try {
                $avDriverKeywords = @('av', 'virus', 'malware', 'defender', 'mfet', 'symm', 'kav', 
                    'sophos', 'eset', 'trend', 'bit', 'crowd', 'sentinel', 'carbon', 'cylance')
                
                $drivers = Get-CimInstance -ClassName Win32_SystemDriver -ErrorAction SilentlyContinue | Where-Object {
                    $driverName = $_.Name + $_.DisplayName
                    $match = $false
                    foreach ($keyword in $avDriverKeywords) {
                        if ($driverName -match $keyword) {
                            $match = $true
                            break
                        }
                    }
                    $match -and $_.State -eq 'Running'
                }
                
                foreach ($drv in $drivers) {
                    $avInfo.AVDrivers += [PSCustomObject]@{
                        Name        = $drv.Name
                        DisplayName = $drv.DisplayName
                        State       = $drv.State
                        StartMode   = $drv.StartMode
                        PathName    = $drv.PathName
                    }
                }
            }
            catch {
                Write-Verbose "Driver scan failed: $($_.Exception.Message)"
            }
            
            return $avInfo
        }
        catch {
            Write-Verbose "AntiVirus info collection failed: $($_.Exception.Message)"
            return @{
                SecurityCenter = @()
                DefenderStatus = $null
                InstalledAV    = @()
                AVServices     = @()
                AVDrivers      = @()
            }
        }
    }

    # Helper function: Get Minifilter Drivers
    function Get-MinifilterDrivers {
        try {
            $drivers = @()
            $fltmc = fltmc filters 2>$null
            
            if ($fltmc) {
                $fltmc | Select-Object -Skip 3 | ForEach-Object {
                    if ($_ -match '^(\S+)\s+(\d+)\s+(\d+)') {
                        $drivers += [PSCustomObject]@{
                            FilterName = $matches[1].Trim()
                            Instances  = $matches[2].Trim()
                            Altitude   = $matches[3].Trim()
                        }
                    }
                }
            }
            return $drivers
        }
        catch {
            return @()
        }
    }

    # Helper function: Get WDAC Policy Status
    function Get-WDACStatus {
        try {
            $wdacStatus = [PSCustomObject]@{
                Enabled  = $false
                Policies = @()
            }
            
            # Check for Code Integrity policies
            $ciPolicies = Get-CimInstance -Namespace root\Microsoft\Windows\CI -ClassName PS_CIPolicyInfo -ErrorAction SilentlyContinue
            
            if ($ciPolicies) {
                $wdacStatus.Enabled = $true
                $wdacStatus.Policies = $ciPolicies | Select-Object PolicyID, FriendlyName, IsActive
            }
            
            return $wdacStatus
        }
        catch {
            return [PSCustomObject]@{ Enabled = $false; Policies = @() }
        }
    }

    # Helper function: Get VBS Status
    function Get-VBSStatus {
        try {
            $vbsStatus = [PSCustomObject]@{
                VBSEnabled = $false
                VBSRunning = $false
                Details    = "Unknown"
            }
            
            $devGuard = Get-CimInstance -ClassName Win32_DeviceGuard -Namespace root\Microsoft\Windows\DeviceGuard -ErrorAction SilentlyContinue
            
            if ($devGuard) {
                $vbsStatus.VBSEnabled = $devGuard.VirtualizationBasedSecurityStatus -eq 2
                $vbsStatus.VBSRunning = $devGuard.VirtualizationBasedSecurityStatus -eq 2
                $vbsStatus.Details = "Status: $($devGuard.VirtualizationBasedSecurityStatus)"
            }
            
            return $vbsStatus
        }
        catch {
            return [PSCustomObject]@{ VBSEnabled = $false; VBSRunning = $false; Details = "Error" }
        }
    }

    # Helper function: Get Bitlocker Status
    function Get-BitlockerStatus {
        try {
            $volumes = Get-BitLockerVolume -ErrorAction SilentlyContinue
            if ($volumes) {
                return $volumes | Select-Object MountPoint, ProtectionStatus, EncryptionPercentage, VolumeStatus
            }
            return @()
        }
        catch {
            return @()
        }
    }

    # Helper function: Get Secure Boot Status
    function Get-SecureBootStatus {
        try {
            $secureBootEnabled = Confirm-SecureBootUEFI -ErrorAction SilentlyContinue
            return [PSCustomObject]@{
                Enabled = $secureBootEnabled
                Status  = if ($secureBootEnabled) { "Enabled" } else { "Disabled" }
            }
        }
        catch {
            return [PSCustomObject]@{ Enabled = $false; Status = "Unknown or Not Supported" }
        }
    }

    # Helper function: Detect VM
    function Test-IsVirtualMachine {
        try {
            $isVM = $false
            $vmType = "Physical"
            
            $computerSystem = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction SilentlyContinue
            if ($computerSystem) {
                $manufacturer = $computerSystem.Manufacturer.ToLower()
                $model = $computerSystem.Model.ToLower()
                
                if ($manufacturer -match 'vmware' -or $model -match 'vmware') {
                    $isVM = $true; $vmType = "VMware"
                }
                elseif ($manufacturer -match 'microsoft' -and $model -match 'virtual') {
                    $isVM = $true; $vmType = "Hyper-V"
                }
                elseif ($manufacturer -match 'xen' -or $model -match 'xen') {
                    $isVM = $true; $vmType = "Xen"
                }
                elseif ($manufacturer -match 'innotek' -or $manufacturer -match 'virtualbox') {
                    $isVM = $true; $vmType = "VirtualBox"
                }
                elseif ($manufacturer -match 'qemu' -or $model -match 'qemu') {
                    $isVM = $true; $vmType = "QEMU"
                }
                elseif ($manufacturer -match 'parallels') {
                    $isVM = $true; $vmType = "Parallels"
                }
            }
            
            return [PSCustomObject]@{
                IsVirtualMachine = $isVM
                Type             = $vmType
            }
        }
        catch {
            return [PSCustomObject]@{ IsVirtualMachine = $false; Type = "Unknown" }
        }
    }

    # Helper function: Parse systeminfo command output
    function Get-SystemInfoCommand {
        try {
            $systemInfoData = @{}
            
            Write-Verbose "Running systeminfo command..."
            $systemInfoOutput = systeminfo.exe 2>$null
            
            if ($LASTEXITCODE -ne 0) {
                Write-Verbose "systeminfo command failed with exit code: $LASTEXITCODE"
                return $systemInfoData
            }
            
            if (-not $systemInfoOutput -or $systemInfoOutput.Count -eq 0) {
                Write-Verbose "systeminfo command returned no data"
                return $systemInfoData
            }
            
            Write-Verbose "systeminfo returned $($systemInfoOutput.Count) lines of output"
            
            foreach ($line in $systemInfoOutput) {
                # Special handling for Virtual Memory lines (format: "Virtual Memory: Max Size:  value")
                if ($line -match '^Virtual Memory:\s*Max Size:\s*(.+)$') {
                    $systemInfoData.VirtualMemoryMax = $matches[1].Trim()
                    continue
                }
                if ($line -match '^Virtual Memory:\s*Available:\s*(.+)$') {
                    $systemInfoData.VirtualMemoryAvailable = $matches[1].Trim()
                    continue
                }
                if ($line -match '^Virtual Memory:\s*In Use:\s*(.+)$') {
                    $systemInfoData.VirtualMemoryInUse = $matches[1].Trim()
                    continue
                }
                
                # Parse key-value pairs (format: "Key: Value")
                if ($line -match '^([^:]+):\s+(.+)$') {
                    $key = $matches[1].Trim()
                    $value = $matches[2].Trim()
                    
                    # Don't skip empty values - we'll handle them in display
                    # Only skip completely blank lines
                    if ([string]::IsNullOrWhiteSpace($key)) {
                        continue
                    }
                    
                    # Map important fields
                    switch ($key) {
                        'Host Name' { 
                            $systemInfoData.Hostname = $value 
                        }
                        'OS Name' { 
                            $systemInfoData.OSName = $value 
                        }
                        'OS Version' { 
                            $systemInfoData.OSVersion = $value 
                        }
                        'OS Manufacturer' { 
                            $systemInfoData.OSManufacturer = $value 
                        }
                        'OS Configuration' { 
                            $systemInfoData.OSConfiguration = $value 
                        }
                        'OS Build Type' { 
                            $systemInfoData.OSBuildType = $value 
                        }
                        'Registered Owner' { 
                            $systemInfoData.RegisteredOwner = $value 
                        }
                        'Registered Organization' { 
                            $systemInfoData.RegisteredOrganization = $value 
                        }
                        'Product ID' { 
                            $systemInfoData.ProductID = $value 
                        }
                        'Original Install Date' { 
                            $systemInfoData.InstallDate = $value 
                        }
                        'System Boot Time' { 
                            $systemInfoData.BootTime = $value 
                        }
                        'System Manufacturer' { 
                            $systemInfoData.SystemManufacturer = $value 
                        }
                        'System Model' { 
                            $systemInfoData.SystemModel = $value 
                        }
                        'System Type' { 
                            $systemInfoData.SystemType = $value 
                        }
                        'Processor(s)' { 
                            $systemInfoData.ProcessorCount = $value 
                        }
                        'BIOS Version' { 
                            $systemInfoData.BIOSVersion = $value 
                        }
                        'Windows Directory' { 
                            $systemInfoData.WindowsDirectory = $value 
                        }
                        'System Directory' { 
                            $systemInfoData.SystemDirectory = $value 
                        }
                        'Boot Device' { 
                            $systemInfoData.BootDevice = $value 
                        }
                        'System Locale' { 
                            $systemInfoData.SystemLocale = $value 
                        }
                        'Input Locale' { 
                            $systemInfoData.InputLocale = $value 
                        }
                        'Time Zone' { 
                            $systemInfoData.TimeZone = $value 
                        }
                        'Total Physical Memory' { 
                            $systemInfoData.TotalPhysicalMemory = $value 
                        }
                        'Available Physical Memory' { 
                            $systemInfoData.AvailablePhysicalMemory = $value 
                        }
                        'Page File Location(s)' { 
                            $systemInfoData.PageFileLocation = $value 
                        }
                        'Domain' { 
                            $systemInfoData.Domain = $value 
                        }
                        'Logon Server' { 
                            $systemInfoData.LogonServer = $value 
                        }
                        'Hyper-V Requirements' { 
                            $systemInfoData.HyperVRequirements = $value 
                        }
                    }
                }
                # Collect processor details (they appear after "Processor(s):" line)
                elseif ($line -match '^\s+\[(\d+)\]:\s+(.+)$') {
                    $procIndex = $matches[1]
                    $procDetails = $matches[2].Trim()
                    
                    if (-not $systemInfoData.ContainsKey('ProcessorDetails')) {
                        $systemInfoData.ProcessorDetails = @()
                    }
                    
                    # Only add if not already present (avoid duplicates)
                    if ($systemInfoData.ProcessorDetails -notcontains $procDetails) {
                        $systemInfoData.ProcessorDetails += $procDetails
                    }
                }
            }
            
            # Post-processing: If we don't have processor details but have processor count, try WMI
            if (-not $systemInfoData.ContainsKey('ProcessorDetails') -or $systemInfoData.ProcessorDetails.Count -eq 0) {
                try {
                    $wmiProc = Get-CimInstance -ClassName Win32_Processor -ErrorAction SilentlyContinue | Select-Object -First 1
                    if ($wmiProc -and $wmiProc.Name) {
                        $systemInfoData.ProcessorDetails = @($wmiProc.Name)
                    }
                }
                catch {
                    Write-Verbose "WMI processor fallback failed: $($_.Exception.Message)"
                }
            }
            
            # Parse hotfixes separately
            $hotfixSection = $false
            $hotfixes = @()
            foreach ($line in $systemInfoOutput) {
                if ($line -match 'Hotfix\(s\):') {
                    $hotfixSection = $true
                    if ($line -match 'Hotfix\(s\):\s+(\d+)\s+Hotfix\(s\)\s+Installed') {
                        $systemInfoData.HotfixCount = $matches[1]
                    }
                    continue
                }
                
                if ($hotfixSection) {
                    if ($line -match '^\s+\[\d+\]:\s+(KB\d+)') {
                        $hotfixes += $matches[1]
                    }
                    elseif ($line -match '^[A-Za-z]') {
                        $hotfixSection = $false
                    }
                }
            }
            
            if ($hotfixes.Count -gt 0) {
                $systemInfoData.Hotfixes = $hotfixes
                $systemInfoData.HotfixCount = $hotfixes.Count
            }
            
            Write-Verbose "systeminfo parsing complete. Captured $($systemInfoData.Count) data points"
            
            return $systemInfoData
        }
        catch {
            Write-Warning "systeminfo parsing error: $($_.Exception.Message)"
            return @{}
        }
    }

    
    # Helper function: Test Internet Connectivity
    function Test-InternetConnectivity {
        try {
            $connectivity = [PSCustomObject]@{
                CanReachInternet = $false
                DNSWorking       = $false
                HTTPWorking      = $false
                Status           = "Offline"
                Details          = ""
            }
            
            $testResults = @()
            
            # Test 1: DNS Resolution (most reliable indicator)
            try {
                $dnsTest = Resolve-DnsName -Name "www.google.com" -Type A -ErrorAction Stop
                if ($dnsTest) {
                    $connectivity.DNSWorking = $true
                    $testResults += "DNS resolution working"
                }
            }
            catch {
                $testResults += "DNS resolution failed"
            }
            
            # Test 2: HTTP connectivity (if DNS works)
            if ($connectivity.DNSWorking) {
                try {
                    $httpTest = Invoke-WebRequest -Uri "http://www.msftconnecttest.com/connecttest.txt" -UseBasicParsing -TimeoutSec 5 -ErrorAction Stop
                    if ($httpTest.StatusCode -eq 200) {
                        $connectivity.HTTPWorking = $true
                        $testResults += "HTTP connectivity confirmed"
                    }
                }
                catch {
                    $testResults += "HTTP test failed: $($_.Exception.Message)"
                }
            }
            
            # Test 3: Fallback ICMP test (less reliable due to firewall blocks)
            if (-not $connectivity.DNSWorking) {
                try {
                    $pingTest = Test-Connection -ComputerName "8.8.8.8" -Count 1 -Quiet -ErrorAction SilentlyContinue
                    if ($pingTest) {
                        $testResults += "ICMP ping successful (but DNS may be blocked)"
                        $connectivity.CanReachInternet = $true
                    }
                }
                catch {
                    $testResults += "ICMP ping blocked or failed"
                }
            }
            
            # Determine overall status
            if ($connectivity.DNSWorking -and $connectivity.HTTPWorking) {
                $connectivity.Status = "Online"
                $connectivity.CanReachInternet = $true
            }
            elseif ($connectivity.DNSWorking) {
                $connectivity.Status = "Limited"
                $connectivity.CanReachInternet = $true
                $testResults += "(DNS works but HTTP may be restricted)"
            }
            elseif ($connectivity.CanReachInternet) {
                $connectivity.Status = "Limited"
                $testResults += "(Network access but DNS issues)"
            }
            else {
                $connectivity.Status = "Offline"
            }
            
            $connectivity.Details = $testResults -join "; "
            
            return $connectivity
        }
        catch {
            return [PSCustomObject]@{
                CanReachInternet = $false
                DNSWorking       = $false
                HTTPWorking      = $false
                Status           = "Error"
                Details          = "Connectivity test failed: $($_.Exception.Message)"
            }
        }
    }

    # Helper function: Get Installed Software
    function Get-InstalledSoftware {
        try {
            $software = @()
            
            $regPaths = @(
                "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*",
                "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*"
            )
            
            foreach ($path in $regPaths) {
                Get-ItemProperty -Path $path -ErrorAction SilentlyContinue | 
                Where-Object { $_.DisplayName } | 
                Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | 
                ForEach-Object { $software += $_ }
            }
            
            return $software | Sort-Object DisplayName -Unique
        }
        catch {
            return @()
        }
    }

    # Helper function: Get Default Browser
    function Get-DefaultBrowser {
        try {
            $defaultBrowser = "Unknown"
            
            $userChoice = Get-ItemProperty -Path "HKCU:\SOFTWARE\Microsoft\Windows\Shell\Associations\UrlAssociations\http\UserChoice" -ErrorAction SilentlyContinue
            
            if ($userChoice -and $userChoice.ProgId) {
                $progId = $userChoice.ProgId
                
                if ($progId -match 'Chrome') { $defaultBrowser = "Google Chrome" }
                elseif ($progId -match 'Firefox') { $defaultBrowser = "Mozilla Firefox" }
                elseif ($progId -match 'Edge') { $defaultBrowser = "Microsoft Edge" }
                elseif ($progId -match 'IE') { $defaultBrowser = "Internet Explorer" }
                elseif ($progId -match 'Opera') { $defaultBrowser = "Opera" }
                elseif ($progId -match 'Brave') { $defaultBrowser = "Brave" }
                else { $defaultBrowser = $progId }
            }
            
            return $defaultBrowser
        }
        catch {
            return "Unknown"
        }
    }


    # Helper function: Get Filesystem and Drive Information
    function Get-FilesystemInfo {
        try {
            $fsInfo = @{
                LogicalDrives = @()
                NetworkDrives = @()
                USBDrives     = @()
                OpticalDrives = @()
                NetworkShares = @()
            }
            
            # Get all logical drives
            try {
                $drives = Get-PSDrive -PSProvider FileSystem -ErrorAction SilentlyContinue
                foreach ($drive in $drives) {
                    try {
                        # Get detailed info using WMI
                        $wmiDrive = Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DeviceID='$($drive.Name):'" -ErrorAction SilentlyContinue
                        
                        if ($wmiDrive) {
                            # Enhanced drive type detection
                            $driveTypeStr = "Unknown"
                            $driveCategory = "LogicalDrives"
                        
                            # Primary classification from WMI
                            switch ($wmiDrive.DriveType) {
                                2 { 
                                    $driveTypeStr = "Removable"
                                    $driveCategory = "USBDrives"
                                }
                                3 { 
                                    $driveTypeStr = "Local Fixed"
                                    $driveCategory = "LogicalDrives"
                                }
                                4 { 
                                    $driveTypeStr = "Network"
                                    $driveCategory = "NetworkDrives"
                                }
                                5 { 
                                    $driveTypeStr = "Optical"
                                    $driveCategory = "OpticalDrives"
                                }
                                default { 
                                    $driveTypeStr = "Unknown Type $($wmiDrive.DriveType)"
                                    $driveCategory = "LogicalDrives"
                                }
                            }
                        
                            # Secondary validation using device information for removable drives
                            if ($wmiDrive.DriveType -eq 2) {
                                try {
                                    # Check if it's actually a USB drive via disk information
                                    $diskDrive = Get-CimInstance -ClassName Win32_DiskDrive -ErrorAction SilentlyContinue | Where-Object {
                                        $partition = Get-CimInstance -Query "ASSOCIATORS OF {Win32_DiskDrive.DeviceID='$($_.DeviceID)'} WHERE AssocClass=Win32_DiskDriveToDiskPartition" -ErrorAction SilentlyContinue
                                        if ($partition) {
                                            $logicalDisk = Get-CimInstance -Query "ASSOCIATORS OF {Win32_DiskPartition.DeviceID='$($partition.DeviceID)'} WHERE AssocClass=Win32_LogicalDiskToPartition" -ErrorAction SilentlyContinue
                                            return $logicalDisk -and $logicalDisk.DeviceID -eq "$($drive.Name):"
                                        }
                                        return $false
                                    }
                                
                                    if ($diskDrive) {
                                        # Check interface type
                                        if ($diskDrive.InterfaceType -match 'USB') {
                                            $driveTypeStr = "USB Removable"
                                        }
                                        elseif ($diskDrive.Caption -match 'SD|MMC|Flash') {
                                            $driveTypeStr = "Flash Card"
                                        }
                                        elseif ($diskDrive.MediaType -match 'Removable') {
                                            $driveTypeStr = "Removable Media"
                                        }
                                    }
                                }
                                catch {
                                    Write-Verbose "Could not validate removable drive type for $($drive.Name): $($_.Exception.Message)"
                                }
                            }
                        
                            # Optical drive validation
                            if ($wmiDrive.DriveType -eq 5) {
                                try {
                                    $cdrom = Get-CimInstance -ClassName Win32_CDROMDrive -ErrorAction SilentlyContinue | Where-Object {
                                        $_.Drive -eq "$($drive.Name):"
                                    }
                                
                                    if ($cdrom) {
                                        if ($cdrom.MediaType -match 'DVD') {
                                            $driveTypeStr = "DVD Drive"
                                        }
                                        elseif ($cdrom.MediaType -match 'CD') {
                                            $driveTypeStr = "CD Drive"
                                        }
                                        elseif ($cdrom.MediaType -match 'Blu-ray|BD') {
                                            $driveTypeStr = "Blu-ray Drive"
                                        }
                                    }
                                }
                                catch {
                                    Write-Verbose "Could not validate optical drive type for $($drive.Name): $($_.Exception.Message)"
                                }
                            }
                        
                            $driveObj = [PSCustomObject]@{
                                DriveLetter  = $drive.Name
                                Label        = if ($wmiDrive.VolumeName) { $wmiDrive.VolumeName } else { "(No label)" }
                                DriveType    = $driveTypeStr
                                FileSystem   = $wmiDrive.FileSystem
                                TotalSizeGB  = if ($wmiDrive.Size) { [math]::Round($wmiDrive.Size / 1GB, 2) } else { 0 }
                                FreeSpaceGB  = if ($wmiDrive.FreeSpace) { [math]::Round($wmiDrive.FreeSpace / 1GB, 2) } else { 0 }
                                UsedSpaceGB  = if ($wmiDrive.Size -and $wmiDrive.FreeSpace) { [math]::Round(($wmiDrive.Size - $wmiDrive.FreeSpace) / 1GB, 2) } else { 0 }
                                PercentFree  = if ($wmiDrive.Size -and $wmiDrive.Size -gt 0) { [math]::Round(($wmiDrive.FreeSpace / $wmiDrive.Size) * 100, 1) } else { 0 }
                                ProviderName = $wmiDrive.ProviderName
                            }
                        
                            # Categorize by detected type
                            switch ($driveCategory) {
                                "USBDrives" { $fsInfo.USBDrives += $driveObj }
                                "LogicalDrives" { $fsInfo.LogicalDrives += $driveObj }
                                "NetworkDrives" { $fsInfo.NetworkDrives += $driveObj }
                                "OpticalDrives" { $fsInfo.OpticalDrives += $driveObj }
                                default { $fsInfo.LogicalDrives += $driveObj }
                            }
                        }
                    }
                    catch {
                        Write-Verbose "Error processing drive $($drive.Name): $($_.Exception.Message)"
                        continue
                    }
                }
            }
            catch {
                Write-Verbose "Error enumerating drives: $($_.Exception.Message)"
            }
            
            # Get network shares
            try {
                $shares = Get-SmbShare -ErrorAction SilentlyContinue
                if ($shares) {
                    foreach ($share in $shares) {
                        $fsInfo.NetworkShares += [PSCustomObject]@{
                            ShareName   = $share.Name
                            Path        = $share.Path
                            Description = $share.Description
                            ShareType   = switch ($share.ShareType) {
                                0 { "Disk Drive" }
                                1 { "Print Queue" }
                                2 { "Device" }
                                3 { "IPC" }
                                default { "Unknown" }
                            }
                        }
                    }
                }
            }
            catch {
                Write-Verbose "Error enumerating SMB shares: $($_.Exception.Message)"
            }
            
            return $fsInfo
        }
        catch {
            Write-Verbose "Filesystem enumeration failed: $($_.Exception.Message)"
            return @{
                LogicalDrives = @()
                NetworkDrives = @()
                USBDrives     = @()
                OpticalDrives = @()
                NetworkShares = @()
            }
        }
    }

    # Helper function: Get Browser Extensions with Details
    function Get-DetailedBrowserExtensions {
        try {
            $extensions = @()
            $hostname = $env:COMPUTERNAME
                
            function Resolve-Message {
                param([string]$BasePath, [string]$msgKey)
                
                # Try multiple locale paths
                $localePaths = @(
                    (Join-Path $BasePath "_locales\en\messages.json"),
                    (Join-Path $BasePath "_locales\en_US\messages.json"),
                    (Join-Path $BasePath "_locales\en_GB\messages.json")
                )
                
                foreach ($localePath in $localePaths) {
                    if (Test-Path $localePath) {
                        try {
                            $rawMessages = Get-Content $localePath -Raw -ErrorAction Stop | ConvertFrom-Json
                            
                            # Try direct property access
                            if ($rawMessages.$msgKey -and $rawMessages.$msgKey.message) {
                                $resolvedMessage = $rawMessages.$msgKey.message
                                if (![string]::IsNullOrWhiteSpace($resolvedMessage)) {
                                    return $resolvedMessage
                                }
                            }
                            
                            # Try case-insensitive search
                            foreach ($prop in $rawMessages.PSObject.Properties) {
                                if ($prop.Name -ieq $msgKey -and $prop.Value.message) {
                                    $resolvedMessage = $prop.Value.message
                                    if (![string]::IsNullOrWhiteSpace($resolvedMessage)) {
                                        return $resolvedMessage
                                    }
                                }
                            }
                        }
                        catch { 
                            Write-Verbose "Failed to read locale file: $localePath - $($_.Exception.Message)"
                        }
                    }
                }
                
                # Fallback: return empty string instead of __MSG_ format
                # This will allow the extension ID to be the identifier
                return ""
            }
                
            if (-not (Test-Path 'C:\Users')) {
                return @()
            }
                
            $UserProfiles = Get-ChildItem 'C:\Users' -Directory -ErrorAction SilentlyContinue | Where-Object {
                $_.Name -notin @('All Users', 'Default', 'Default User', 'Public') -and -not $_.Name.StartsWith('$')
            }
                
            foreach ($userProfile in $UserProfiles) {
                $Username = $userProfile.Name
                $UserLocalAppData = Join-Path $userProfile.FullName "AppData\Local"
                $UserRoamingAppData = Join-Path $userProfile.FullName "AppData\Roaming"
                    
                if (-not (Test-Path $UserLocalAppData) -and -not (Test-Path $UserRoamingAppData)) {
                    continue
                }
                    
                $BrowserProfiles = @(
                    @{ Name = "Chrome"; Path = "$UserLocalAppData\Google\Chrome\User Data" },
                    @{ Name = "Edge"; Path = "$UserLocalAppData\Microsoft\Edge\User Data" },
                    @{ Name = "Brave"; Path = "$UserLocalAppData\BraveSoftware\Brave-Browser\User Data" },
                    @{ Name = "Vivaldi"; Path = "$UserLocalAppData\Vivaldi\User Data" },
                    @{ Name = "Opera"; Path = "$UserRoamingAppData\Opera Software\Opera Stable" },
                    @{ Name = "Firefox"; Path = "$UserRoamingAppData\Mozilla\Firefox\Profiles" }
                )
                    
                foreach ($browser in $BrowserProfiles) {
                    $browserName = $browser.Name
                    $basePath = $browser.Path
                        
                    if (-Not (Test-Path $basePath)) {
                        continue
                    }
                        
                    $profiles = if ($browserName -eq "Firefox") {
                        Get-ChildItem -Path $basePath -Directory -ErrorAction SilentlyContinue | Where-Object { 
                            $_.Name -like "*.default*" -or $_.Name -like "*-default" 
                        }
                    }
                    else {
                        Get-ChildItem -Path $basePath -Directory -ErrorAction SilentlyContinue | Where-Object {
                            $_.Name -eq 'Default' -or $_.Name -like 'Profile *'
                        }
                    }
                        
                    foreach ($profile in $profiles) {
                        if ($browserName -eq "Firefox") {
                            $extensionsPath = Join-Path $profile.FullName "extensions"
                            if (-Not (Test-Path $extensionsPath)) { continue }
                                
                            $xpiFiles = Get-ChildItem $extensionsPath -Filter *.xpi -File -ErrorAction SilentlyContinue
                            foreach ($xpi in $xpiFiles) {
                                $tempDir = Join-Path $env:TEMP ([System.IO.Path]::GetRandomFileName())
                                    
                                try {
                                    # Use .NET ZipFile directly - no copy needed
                                    Add-Type -AssemblyName System.IO.Compression.FileSystem
                                    [System.IO.Compression.ZipFile]::ExtractToDirectory($xpi.FullName, $tempDir)
                                        
                                    $manifestPath = Join-Path $tempDir "manifest.json"
                                    if (Test-Path $manifestPath) {
                                        $manifest = Get-Content $manifestPath -Raw -ErrorAction Stop | ConvertFrom-Json
                                            
                                        $name = if ($manifest.name -like "__MSG_*__") {
                                            $msgKey = $manifest.name -replace "^__MSG_(.+?)__$", '$1'
                                            Resolve-Message -BasePath $tempDir -msgKey $msgKey
                                        }
                                        else { $manifest.name }
                                            
                                        $desc = if ($manifest.description -like "__MSG_*__") {
                                            $msgKey = $manifest.description -replace "^__MSG_(.+?)__$", '$1'
                                            Resolve-Message -BasePath $tempDir -msgKey $msgKey
                                        }
                                        else { $manifest.description }
                                            
                                        $extensionId = if ($manifest.applications -and $manifest.applications.gecko -and $manifest.applications.gecko.id) {
                                            $manifest.applications.gecko.id
                                        }
                                        elseif ($manifest.browser_specific_settings -and $manifest.browser_specific_settings.gecko -and $manifest.browser_specific_settings.gecko.id) {
                                            $manifest.browser_specific_settings.gecko.id
                                        }
                                        else {
                                            [System.IO.Path]::GetFileNameWithoutExtension($xpi.Name)
                                        }
                                            
                                        $extensions += [PSCustomObject]@{
                                            Hostname    = $hostname
                                            User        = $Username
                                            Browser     = $browserName
                                            Profile     = $profile.Name
                                            ID          = $extensionId
                                            Name        = $name
                                            Version     = $manifest.version
                                            Description = $desc
                                        }
                                    }
                                }
                                catch { } finally {
                                    if (Test-Path $tempDir) { Remove-Item -Path $tempDir -Recurse -Force -ErrorAction SilentlyContinue }
                                }
                            }
                        }
                        else {
                            $extensionsPath = Join-Path $profile.FullName "Extensions"
                            if (-Not (Test-Path $extensionsPath)) { continue }
                                
                            $extensionDirs = Get-ChildItem -Path $extensionsPath -Directory -ErrorAction SilentlyContinue
                            foreach ($ext in $extensionDirs) {
                                $extId = $ext.Name
                                $versions = Get-ChildItem -Path $ext.FullName -Directory -ErrorAction SilentlyContinue | 
                                Sort-Object { 
                                    try {
                                        # Try to parse as version (e.g., "1.0.0_0" or "34.0.1847.116")
                                        $versionPart = $_.Name -replace '_.*$', ''
                                        # Ensure at least two parts for version parsing (add .0 if needed)
                                        if ($versionPart -notmatch '\.') {
                                            $versionPart = "$versionPart.0"
                                        }
                                        [version]$versionPart
                                    }
                                    catch {
                                        # If version parsing fails, sort alphabetically as fallback
                                        $_.Name
                                    }
                                } -Descending
                                    
                                if ($versions.Count -eq 0) { continue }
                                    
                                $latest = $versions[0]
                                $manifestPath = Join-Path $latest.FullName "manifest.json"
                                    
                                if (Test-Path $manifestPath) {
                                    try {
                                        $manifest = Get-Content $manifestPath -Raw -ErrorAction Stop | ConvertFrom-Json
                                            
                                        $name = if ($manifest.name -like "__MSG_*__") {
                                            $msgKey = $manifest.name -replace "^__MSG_(.+?)__$", '$1'
                                            $resolved = Resolve-Message -BasePath $latest.FullName -msgKey $msgKey
                                            if ([string]::IsNullOrWhiteSpace($resolved)) {
                                                # Use extension ID as fallback name
                                                $extId
                                            }
                                            else {
                                                $resolved
                                            }
                                        }
                                        else { 
                                            if ([string]::IsNullOrWhiteSpace($manifest.name)) { $extId } else { $manifest.name }
                                        }
                                            
                                        $desc = if ($manifest.description -like "__MSG_*__") {
                                            $msgKey = $manifest.description -replace "^__MSG_(.+?)__$", '$1'
                                            $resolved = Resolve-Message -BasePath $latest.FullName -msgKey $msgKey
                                            if ([string]::IsNullOrWhiteSpace($resolved)) { "" } else { $resolved }
                                        }
                                        else { 
                                            if ($manifest.description) { $manifest.description } else { "" }
                                        }
                                            
                                        $extensions += [PSCustomObject]@{
                                            Hostname    = $hostname
                                            User        = $Username
                                            Browser     = $browserName
                                            Profile     = $profile.Name
                                            ID          = $extId
                                            Name        = $name
                                            Version     = $manifest.version
                                            Description = $desc
                                        }
                                    }
                                    catch { }
                                }
                            }
                        }
                    }
                }
            }
                
            return $extensions
        }
        catch {
            return @()
        }
    }


    # Helper function: Get Logged In Users
    function Get-LoggedInUsers {
        try {
            $users = @()
            $processedUsers = @{}
            
            # Method 1: Try quser command (most reliable for active sessions)
            try {
                $quserOutput = quser 2>&1
                if ($LASTEXITCODE -eq 0 -and $quserOutput) {
                    # Skip header line
                    $lines = $quserOutput | Select-Object -Skip 1
                    
                    foreach ($line in $lines) {
                        if ([string]::IsNullOrWhiteSpace($line)) { continue }
                        
                        # Remove the > character that indicates current session
                        $line = $line.TrimStart('>')
                        
                        # quser output format (columns can vary):
                        # USERNAME              SESSIONNAME        ID  STATE   IDLE TIME  LOGON TIME
                        # Sometimes SESSIONNAME is blank (Disc state), making parsing tricky
                        
                        # Use regex to parse more reliably
                        # Pattern: USERNAME (spaces) SESSIONNAME or blank (spaces) ID (spaces) STATE (spaces) rest
                        if ($line -match '^\s*(\S+)\s+(\S*)\s+(\d+)\s+(\S+)\s+(.*)$') {
                            $username = $matches[1]
                            $sessionName = if ([string]::IsNullOrWhiteSpace($matches[2]) -or $matches[2] -eq 'Disc') { 
                                "Disconnected" 
                            }
                            else { 
                                $matches[2] 
                            }
                            $sessionId = $matches[3]
                            $state = $matches[4]
                            $restOfLine = $matches[5].Trim()
                            
                            # Parse idle time and logon time from rest of line
                            # Format is usually: IDLE_TIME LOGON_TIME
                            # Idle time can be: ".", "none", "1", "2:30", "3+01:45"
                            # Logon time is typically: "1/15/2025 3:45 PM"
                            
                            $idleTime = "."
                            $logonTime = "Unknown"
                            
                            # Split on multiple spaces to separate idle from logon time
                            $timeParts = $restOfLine -split '\s{2,}'
                            if ($timeParts.Count -ge 2) {
                                $idleTime = $timeParts[0]
                                $logonTime = ($timeParts[1..($timeParts.Count - 1)] -join ' ').Trim()
                            }
                            elseif ($timeParts.Count -eq 1) {
                                # Could be just idle time or just logon time
                                if ($timeParts[0] -match '^\d|^none|^\.|^\+') {
                                    $idleTime = $timeParts[0]
                                }
                                else {
                                    $logonTime = $timeParts[0]
                                }
                            }
                            
                            $userKey = "$username-$sessionId"
                            if (-not $processedUsers.ContainsKey($userKey)) {
                                $users += [PSCustomObject]@{
                                    Username    = $username
                                    SessionName = $sessionName
                                    ID          = $sessionId
                                    State       = $state
                                    IdleTime    = $idleTime
                                    LogonTime   = $logonTime
                                    Source      = "quser"
                                }
                                $processedUsers[$userKey] = $true
                            }
                        }
                    }
                }
            }
            catch {
                Write-Verbose "quser command failed: $($_.Exception.Message)"
            }
            
            # Method 2: Win32_LogonSession for additional sessions (network, service, etc.)
            try {
                # LogonType: 2=Interactive, 3=Network, 4=Batch, 5=Service, 7=Unlock, 8=NetworkCleartext, 9=NewCredentials, 10=RemoteInteractive, 11=CachedInteractive
                $logonSessions = Get-CimInstance -ClassName Win32_LogonSession -ErrorAction SilentlyContinue | 
                Where-Object { $_.LogonType -in @(2, 10, 11) }  # Interactive, RDP, CachedInteractive
                
                foreach ($session in $logonSessions) {
                    try {
                        $logonUser = Get-CimInstance -ClassName Win32_LoggedOnUser -ErrorAction SilentlyContinue | 
                        Where-Object { $_.Dependent.LogonId -eq $session.LogonId } | 
                        Select-Object -First 1
                        
                        if ($logonUser) {
                            $domain = $logonUser.Antecedent.Domain
                            $name = $logonUser.Antecedent.Name
                            $username = if ($domain) { "$domain\$name" } else { $name }
                            $sessionId = $session.LogonId
                            
                            $logonType = switch ($session.LogonType) {
                                2 { "Interactive" }
                                10 { "RemoteInteractive" }
                                11 { "CachedInteractive" }
                                default { "Type$($session.LogonType)" }
                            }
                            
                            $logonTimeStr = "Unknown"
                            if ($session.StartTime) {
                                try {
                                    $logonTimeStr = $session.StartTime.ToString("yyyy-MM-dd HH:mm:ss")
                                }
                                catch {
                                    $logonTimeStr = $session.StartTime.ToString()
                                }
                            }
                            
                            # Check if we already have this user from quser
                            $userKey = "$username-$sessionId"
                            if (-not $processedUsers.ContainsKey($userKey)) {
                                $users += [PSCustomObject]@{
                                    Username    = $username
                                    SessionName = $logonType
                                    ID          = $sessionId
                                    State       = "Active"
                                    IdleTime    = "Unknown"
                                    LogonTime   = $logonTimeStr
                                    Source      = "WMI"
                                }
                                $processedUsers[$userKey] = $true
                            }
                        }
                    }
                    catch {
                        Write-Verbose "Error processing logon session $($session.LogonId): $($_.Exception.Message)"
                        continue
                    }
                }
            }
            catch {
                Write-Verbose "Win32_LogonSession enumeration failed: $($_.Exception.Message)"
            }
            
            # Method 3: Get-CimInstance Win32_ComputerSystem for current console user
            try {
                $computerSystem = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction SilentlyContinue
                if ($computerSystem -and $computerSystem.UserName) {
                    $consoleUser = $computerSystem.UserName
                    
                    # Check if we already have this user
                    $alreadyExists = $users | Where-Object { $_.Username -eq $consoleUser }
                    
                    if (-not $alreadyExists) {
                        $users += [PSCustomObject]@{
                            Username    = $consoleUser
                            SessionName = "Console"
                            ID          = "0"
                            State       = "Active"
                            IdleTime    = "Unknown"
                            LogonTime   = "Unknown"
                            Source      = "ComputerSystem"
                        }
                    }
                }
            }
            catch {
                Write-Verbose "Win32_ComputerSystem query failed: $($_.Exception.Message)"
            }
            
            # Sort and return unique users
            if ($users.Count -gt 0) {
                return $users | Sort-Object Username, ID
            }
            else {
                Write-Verbose "No logged in users detected by any method"
                return @()
            }
        }
        catch {
            Write-Verbose "Get-LoggedInUsers failed: $($_.Exception.Message)"
            return @()
        }
    }

    # Helper function: Get All User Accounts
    function Get-AllUserAccounts {
        try {
            $users = @()
            $processedSIDs = @{}
            
            # Get local users with creation dates
            if (Get-Command Get-LocalUser -ErrorAction SilentlyContinue) {
                $localUsers = Get-LocalUser -ErrorAction SilentlyContinue
                if ($localUsers) {
                    foreach ($user in $localUsers) {
                        $users += [PSCustomObject]@{
                            Username    = $user.Name
                            Created     = $user.Created
                            LastLogon   = $user.LastLogon
                            Enabled     = $user.Enabled
                            Type        = "Local"
                            SID         = $user.SID.Value
                            ProfilePath = ""
                            Description = $user.Description
                        }
                        $processedSIDs[$user.SID.Value] = $true
                    }
                }
            }
            
            # Get user profiles (includes domain users and profile info)
            $profiles = Get-CimInstance -ClassName Win32_UserProfile -ErrorAction SilentlyContinue
            if ($profiles) {
                foreach ($profile in $profiles) {
                    try {
                        $sid = $profile.SID
                        if ($processedSIDs.ContainsKey($sid)) {
                            # Update existing entry with profile path
                            $existingUser = $users | Where-Object { $_.SID -eq $sid }
                            if ($existingUser) {
                                $existingUser.ProfilePath = $profile.LocalPath
                            }
                        }
                        else {
                            # New user from profile
                            $objSID = New-Object System.Security.Principal.SecurityIdentifier($sid)
                            $username = try { $objSID.Translate([System.Security.Principal.NTAccount]).Value } catch { $sid }
                            
                            # Determine account type more accurately
                            $accountType = "Profile"
                            if ($username -match '^NT AUTHORITY\\') {
                                $accountType = "System"
                            }
                            elseif ($username -match '^S-1-5-21-') {
                                $accountType = "Domain"
                            }
                            elseif ($username -match '\\') {
                                # Check if it's a well-known system account
                                if ($username -match '^(NT AUTHORITY|NT SERVICE|APPLICATION PACKAGE AUTHORITY|Window Manager)\\') {
                                    $accountType = "System"
                                }
                                else {
                                    $accountType = "Domain"
                                }
                            }
                            
                            $users += [PSCustomObject]@{
                                Username    = $username
                                Created     = $profile.LastUseTime
                                LastLogon   = $profile.LastUseTime
                                Enabled     = $true
                                Type        = $accountType
                                SID         = $sid
                                ProfilePath = $profile.LocalPath
                                Description = ""
                            }
                            $processedSIDs[$sid] = $true
                        }
                    }
                    catch {
                        continue
                    }
                }
            }
            
            # Check C:\Users for any missed profiles (hail mary)
            if (Test-Path "C:\Users") {
                $userFolders = Get-ChildItem "C:\Users" -Directory -ErrorAction SilentlyContinue | Where-Object {
                    $_.Name -notin @('All Users', 'Default', 'Default User', 'Public') -and -not $_.Name.StartsWith('$')
                }
                
                foreach ($folder in $userFolders) {
                    $folderPath = $folder.FullName
                    $folderName = $folder.Name
                    
                    # Check if we already have this user by profile path
                    $existing = $users | Where-Object { $_.ProfilePath -eq $folderPath }
                    
                    if (-not $existing) {
                        # Found a profile folder we didn't catch earlier
                        $users += [PSCustomObject]@{
                            Username    = $folderName
                            Created     = $folder.CreationTime
                            LastLogon   = $folder.LastWriteTime
                            Enabled     = $true
                            Type        = "Folder"
                            SID         = "Unknown"
                            ProfilePath = $folderPath
                            Description = "Detected from profile folder"
                        }
                    }
                }
            }
            
            return $users | Sort-Object Created
        }
        catch {
            return @()
        }
    }
    function Update-ProgressWithEstimate {
        param(
            [string]$Activity,
            [string]$Status,
            [int]$PercentComplete,
            [ref]$StepTimes
        )
        
        # Simple progress display without time estimation
        Write-Progress -Activity $Activity -Status $Status -PercentComplete $PercentComplete
    }

    # Helper function: Get System Information
    function Get-SystemInformation {
        param(
            [string]$OutputDir
        )

        $sysInfo = @{}

        try {
            Write-Host "  [-] Gathering basic system info..." -ForegroundColor DarkGray
            $sysInfo.ComputerInfo = Get-ComputerInfo -ErrorAction SilentlyContinue
            $sysInfo.OSInfo = Get-CimInstance Win32_OperatingSystem -ErrorAction SilentlyContinue

            Write-Host "  [-] Running systeminfo command..." -ForegroundColor DarkGray
            $sysInfo.SystemInfoCmd = Get-SystemInfoCommand
            
            # Diagnostic: Check if SystemInfoCmd was populated
            if ($sysInfo.SystemInfoCmd -and $sysInfo.SystemInfoCmd.Count -gt 0) {
                Write-Host "  [+] Captured $($sysInfo.SystemInfoCmd.Count) SystemInfo objects" -ForegroundColor DarkGray
            }
            else {
                Write-Host "  [!] WARNING: systeminfo command returned no data - run with -Verbose to diagnose" -ForegroundColor Yellow
            }
        
            Write-Host "  [-] Checking domain status..." -ForegroundColor DarkGray
            try {
                $sysInfo.Domain = (Get-WmiObject Win32_ComputerSystem).Domain
                $sysInfo.IsDomainJoined = (Get-WmiObject Win32_ComputerSystem).PartOfDomain
            }
            catch {
                $sysInfo.Domain = "WORKGROUP"
                $sysInfo.IsDomainJoined = $false
            }
        
            Write-Host "  [-] Extracting PowerShell history..." -ForegroundColor DarkGray
            try {
                $histPath = (Get-PSReadlineOption).HistorySavePath
                if (Test-Path $histPath) {
                    $sysInfo.PSHistory = Get-Content $histPath -ErrorAction SilentlyContinue
                }
            }
            catch {
                $sysInfo.PSHistory = @()
            }
        
            Write-Host "  [-] Getting Run MRU..." -ForegroundColor DarkGray
            try {
                $runMRU = Get-ItemProperty "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU" -ErrorAction SilentlyContinue
                if ($runMRU) {
                    # Get the MRUList order (e.g., "acb" means a is most recent, then c, then b)
                    $mruOrder = $runMRU.MRUList
                    $runMRUList = @()
                
                    # Get all command entries (single letters a-z)
                    $commandEntries = $runMRU.PSObject.Properties | Where-Object { 
                        $_.Name -match '^[a-z]$' -and ![string]::IsNullOrWhiteSpace($_.Value)
                    }
                
                    if ($commandEntries -and $commandEntries.Count -gt 0) {
                        # If we have an MRU order, sort by it; otherwise use alphabetical
                        if (![string]::IsNullOrWhiteSpace($mruOrder)) {
                            # Sort by MRU order (most recent first)
                            $orderedEntries = @()
                            foreach ($char in $mruOrder.ToCharArray()) {
                                $entry = $commandEntries | Where-Object { $_.Name -eq $char.ToString() } | Select-Object -First 1
                                if ($entry) {
                                    $orderedEntries += $entry
                                }
                            }
                            # Add any entries not in MRU list
                            foreach ($entry in $commandEntries) {
                                if ($entry.Name -notin $mruOrder.ToCharArray()) {
                                    $orderedEntries += $entry
                                }
                            }
                            $commandEntries = $orderedEntries
                        }
                    
                        # Process each command entry
                        $index = 1
                        foreach ($entry in $commandEntries) {
                            # Remove the \1 terminator if present
                            $command = $entry.Value -replace '\\1$', ''
                        
                            if (![string]::IsNullOrWhiteSpace($command)) {
                                $runMRUList += [PSCustomObject]@{
                                    Order   = $index
                                    Key     = $entry.Name
                                    Command = $command
                                }
                                $index++
                            }
                        }
                    }
                
                    $sysInfo.RunMRU = $runMRUList
                }
                else {
                    $sysInfo.RunMRU = @()
                }
            }
            catch {
                Write-Verbose "Run MRU collection error: $($_.Exception.Message)"
                $sysInfo.RunMRU = @()
            }
        
            Write-Host "  [-] Getting DNS cache..." -ForegroundColor DarkGray
            try {
                $sysInfo.DNSCache = Get-DnsClientCache -ErrorAction SilentlyContinue | Where-Object { $_ -ne $null }
            }
            catch {
                $sysInfo.DNSCache = @()
            }
        
            Write-Host "  [-] Enumerating users and sessions..." -ForegroundColor DarkGray
            $sysInfo.LoggedOnUsers = Get-CimInstance Win32_LoggedOnUser -ErrorAction SilentlyContinue
            $sysInfo.LocalUsers = Get-LocalUser -ErrorAction SilentlyContinue
            $sysInfo.LocalGroups = Get-LocalGroup -ErrorAction SilentlyContinue
            $sysInfo.LocalAdmins = Get-LocalGroupMember -Group "Administrators" -ErrorAction SilentlyContinue
            $sysInfo.UserProfiles = Get-CimInstance Win32_UserProfile -ErrorAction SilentlyContinue
            
            Write-Host "  [-] Getting all user accounts..." -ForegroundColor DarkGray
            $sysInfo.AllUserAccounts = Get-AllUserAccounts
            
            Write-Host "  [-] Getting currently logged in users..." -ForegroundColor DarkGray
            $sysInfo.CurrentlyLoggedIn = Get-LoggedInUsers
        
            Write-Host "  [-] Getting network connections..." -ForegroundColor DarkGray
            $sysInfo.NetworkConnections = Get-NetTCPConnection -State Established, Listen -ErrorAction SilentlyContinue
            $sysInfo.NetworkAdapters = Get-NetAdapter -ErrorAction SilentlyContinue
            $sysInfo.IPConfiguration = Get-NetIPConfiguration -ErrorAction SilentlyContinue
            $sysInfo.DNSServers = Get-DnsClientServerAddress -ErrorAction SilentlyContinue
            $sysInfo.FirewallRules = Get-NetFirewallRule -Enabled True -ErrorAction SilentlyContinue | Select-Object -First 100

            Write-Host "  [-] Detecting domain controller and DNS configuration..." -ForegroundColor DarkGray
            try {
                # Get primary DNS server
                $primaryDNS = @()
                if ($sysInfo.DNSServers) {
                    foreach ($dnsConfig in $sysInfo.DNSServers) {
                        if ($dnsConfig.ServerAddresses -and $dnsConfig.ServerAddresses.Count -gt 0) {
                            $primaryDNS += $dnsConfig.ServerAddresses[0]
                        }
                    }
                }
                $sysInfo.PrimaryDNSServer = if ($primaryDNS.Count -gt 0) { $primaryDNS[0] } else { "N/A" }
            
                # Try to get domain controller info if domain-joined
                $dcInfo = $null
                $logonServer = "N/A"
            
                if ($sysInfo.IsDomainJoined) {
                    # Method 1: Use environment variable
                    $logonServer = $env:LOGONSERVER -replace '\\\\', ''
                
                    # Method 2: Try nltest to get DC info
                    try {
                        $nltestOutput = nltest /dsgetdc:$($sysInfo.Domain) 2>$null
                        if ($LASTEXITCODE -eq 0 -and $nltestOutput) {
                            foreach ($line in $nltestOutput) {
                                if ($line -match 'DC:\s*(.+)') {
                                    $dcName = $matches[1].Trim()
                                    if (![string]::IsNullOrWhiteSpace($dcName)) {
                                        $logonServer = $dcName -replace '\\\\', ''
                                    }
                                }
                                elseif ($line -match 'DC Address:\s*(.+)') {
                                    $dcAddress = $matches[1].Trim()
                                    if ($dcAddress -match '\d+\.\d+\.\d+\.\d+') {
                                        $dcIP = $matches[0]
                                        if (-not $dcInfo) { $dcInfo = @{} }
                                        $dcInfo.IPAddress = $dcIP
                                    }
                                }
                            }
                        }
                    }
                    catch {
                        Write-Verbose "nltest command failed: $($_.Exception.Message)"
                    }
                
                    # Method 3: Try to resolve logon server
                    if ($logonServer -ne "N/A") {
                        try {
                            $dcResolved = Resolve-DnsName -Name $logonServer -ErrorAction SilentlyContinue
                            if ($dcResolved) {
                                if (-not $dcInfo) { $dcInfo = @{} }
                                $dcInfo.Name = $logonServer
                                $dcInfo.IPAddress = ($dcResolved | Where-Object { $_.Type -eq 'A' } | Select-Object -First 1).IPAddress
                            }
                        }
                        catch {
                            Write-Verbose "Could not resolve DC: $($_.Exception.Message)"
                        }
                    }
                }
            
                $sysInfo.LogonServer = $logonServer
                $sysInfo.DomainController = if ($dcInfo) { $dcInfo } else { @{ Name = "N/A"; IPAddress = "N/A" } }
            }
            catch {
                Write-Verbose "Domain controller detection error: $($_.Exception.Message)"
                $sysInfo.LogonServer = "N/A"
                $sysInfo.PrimaryDNSServer = "N/A"
                $sysInfo.DomainController = @{ Name = "N/A"; IPAddress = "N/A" }
            }
        
            Write-Host "  [-] Enumerating processes..." -ForegroundColor DarkGray
            $sysInfo.Processes = Get-Process -IncludeUserName -ErrorAction SilentlyContinue | 
            Select-Object Id, ProcessName, Path, Company, Product, Description, UserName, CPU, WS, StartTime
        
            Write-Host "  [-] Getting system timing info..." -ForegroundColor DarkGray
            $sysInfo.BootTime = (Get-CimInstance Win32_OperatingSystem).LastBootUpTime
            $sysInfo.LocalTime = Get-Date
            $sysInfo.TimeZone = Get-TimeZone
            $sysInfo.Uptime = (Get-Date) - $sysInfo.BootTime

            Write-Host "  [-] Checking Volume Shadow Copies..." -ForegroundColor DarkGray
            try {
                $sysInfo.ShadowCopies = Get-CimInstance -ClassName Win32_ShadowCopy -ErrorAction SilentlyContinue | 
                Select-Object ID, InstallDate, VolumeName, @{N = 'SizeMB'; E = { [math]::Round($_.AllocatedSpace / 1MB, 2) } }
                $sysInfo.ShadowCopyCount = if ($sysInfo.ShadowCopies) { $sysInfo.ShadowCopies.Count } else { 0 }
                
                $vssService = Get-Service -Name VSS -ErrorAction SilentlyContinue
                $sysInfo.VSSServiceStatus = if ($vssService) { $vssService.Status } else { "Not Found" }
            }
            catch {
                $sysInfo.ShadowCopies = @()
                $sysInfo.ShadowCopyCount = 0
                $sysInfo.VSSServiceStatus = "Error"
            }
        
            Write-Host "  [-] Checking security software..." -ForegroundColor DarkGray
            try {
                $sysInfo.AntiVirus = Get-CimInstance -Namespace root\SecurityCenter2 -ClassName AntiVirusProduct -ErrorAction SilentlyContinue
                $sysInfo.DefenderStatus = Get-MpComputerStatus -ErrorAction SilentlyContinue
                $sysInfo.DefenderPreferences = Get-MpPreference -ErrorAction SilentlyContinue
            }
            catch {
                $sysInfo.AntiVirus = @()
                $sysInfo.DefenderStatus = $null
                $sysInfo.DefenderPreferences = $null
            }
            
            Write-Host "  [-] Getting antivirus information..." -ForegroundColor DarkGray
            try {
                $sysInfo.AntiVirusInfo = Get-AntiVirusInfo
            }
            catch {
                $sysInfo.AntiVirusInfo = @{
                    SecurityCenter = @()
                    DefenderStatus = $null
                    InstalledAV    = @()
                    AVServices     = @()
                    AVDrivers      = @()
                }
            }
            
            Write-Host "  [-] Checking AMSI providers..." -ForegroundColor DarkGray
            try {
                $sysInfo.AMSIProviders = Get-AMSIProviders
            }
            catch {
                $sysInfo.AMSIProviders = @()
            }
            
            Write-Host "  [-] Checking minifilter drivers..." -ForegroundColor DarkGray
            try {
                $sysInfo.MinifilterDrivers = Get-MinifilterDrivers
            }
            catch {
                $sysInfo.MinifilterDrivers = @()
            }
            
            Write-Host "  [-] Checking WDAC policy..." -ForegroundColor DarkGray
            try {
                $sysInfo.WDACStatus = Get-WDACStatus
            }
            catch {
                $sysInfo.WDACStatus = [PSCustomObject]@{ Enabled = $false; Policies = @() }
            }
            
            Write-Host "  [-] Checking VBS status..." -ForegroundColor DarkGray
            try {
                $sysInfo.VBSStatus = Get-VBSStatus
            }
            catch {
                $sysInfo.VBSStatus = [PSCustomObject]@{ VBSEnabled = $false; VBSRunning = $false; Details = "Error" }
            }
            
            Write-Host "  [-] Checking Bitlocker status..." -ForegroundColor DarkGray
            try {
                $sysInfo.BitlockerStatus = Get-BitlockerStatus
            }
            catch {
                $sysInfo.BitlockerStatus = @()
            }
            
            Write-Host "  [-] Checking Secure Boot..." -ForegroundColor DarkGray
            try {
                $sysInfo.SecureBoot = Get-SecureBootStatus
            }
            catch {
                $sysInfo.SecureBoot = [PSCustomObject]@{ Enabled = $false; Status = "Unknown" }
            }
            
            Write-Host "  [-] Detecting virtualization..." -ForegroundColor DarkGray
            try {
                $sysInfo.VMDetection = Test-IsVirtualMachine
            }
            catch {
                $sysInfo.VMDetection = [PSCustomObject]@{ IsVirtualMachine = $false; Type = "Unknown" }
            }
            
            Write-Host "  [-] Testing internet connectivity..." -ForegroundColor DarkGray
            try {
                $sysInfo.InternetConnectivity = Test-InternetConnectivity
            }
            catch {
                $sysInfo.InternetConnectivity = [PSCustomObject]@{ CanPingCloudflare = $false; CanPingGoogle = $false; CanResolveDNS = $false; Status = "Unknown" }
            }
            
            Write-Host "  [-] Getting installed software..." -ForegroundColor DarkGray
            try {
                $sysInfo.InstalledSoftware = Get-InstalledSoftware
            }
            catch {
                $sysInfo.InstalledSoftware = @()
            }
                        
            Write-Host "  [-] Getting default browser..." -ForegroundColor DarkGray
            try {
                $sysInfo.DefaultBrowser = Get-DefaultBrowser
            }
            catch {
                $sysInfo.DefaultBrowser = "Unknown"
            }
            
            Write-Host "  [-] Getting filesystem and drive information..." -ForegroundColor DarkGray
            try {
                $sysInfo.FilesystemInfo = Get-FilesystemInfo
            }
            catch {
                $sysInfo.FilesystemInfo = @{
                    LogicalDrives = @()
                    NetworkDrives = @()
                    USBDrives     = @()
                    OpticalDrives = @()
                    NetworkShares = @()
                }
            }
            
            Write-Host "  [-] Getting browser extensions..." -ForegroundColor DarkGray
            try {
                $sysInfo.BrowserExtensions = Get-DetailedBrowserExtensions
            }
            catch {
                $sysInfo.BrowserExtensions = @()
            }

            if ($OutputDir) {
                if ($sysInfo.Processes) {
                    $sysInfo.Processes | Export-Csv -Path (Join-Path $OutputDir "SystemInfo_Processes.csv") -NoTypeInformation
                }
                if ($sysInfo.NetworkConnections) {
                    $sysInfo.NetworkConnections | Export-Csv -Path (Join-Path $OutputDir "SystemInfo_NetworkConnections.csv") -NoTypeInformation
                }
                if ($sysInfo.LocalUsers) {
                    $sysInfo.LocalUsers | Export-Csv -Path (Join-Path $OutputDir "SystemInfo_LocalUsers.csv") -NoTypeInformation
                }
                if ($sysInfo.DNSCache) {
                    $sysInfo.DNSCache | Export-Csv -Path (Join-Path $OutputDir "SystemInfo_DNSCache.csv") -NoTypeInformation
                }
                if ($sysInfo.AllUserAccounts) {
                    $sysInfo.AllUserAccounts | Export-Csv -Path (Join-Path $OutputDir "SystemInfo_AllUserAccounts.csv") -NoTypeInformation
                }
                if ($sysInfo.InstalledSoftware) {
                    $sysInfo.InstalledSoftware | Export-Csv -Path (Join-Path $OutputDir "SystemInfo_InstalledSoftware.csv") -NoTypeInformation
                }
                if ($sysInfo.BrowserExtensions) {
                    $sysInfo.BrowserExtensions | Export-Csv -Path (Join-Path $OutputDir "SystemInfo_BrowserExtensions.csv") -NoTypeInformation
                }
            
                $summary = [PSCustomObject]@{
                    Hostname         = $env:COMPUTERNAME
                    Domain           = $sysInfo.Domain
                    IsDomainJoined   = $sysInfo.IsDomainJoined        
                    OS               = "$($sysInfo.OSInfo.Caption) $($sysInfo.OSInfo.Version)"
                    Architecture     = $sysInfo.OSInfo.OSArchitecture
                    BootTime         = $sysInfo.BootTime
                    CollectionTime   = Get-Date
                    TimeZone         = $sysInfo.TimeZone.DisplayName
                    DefaultBrowser   = $sysInfo.DefaultBrowser
                    IsVirtualMachine = $sysInfo.VMDetection.IsVirtualMachine
                    VMType           = $sysInfo.VMDetection.Type
                }
                $summary | Export-Csv -Path (Join-Path $OutputDir "SystemInfo_Summary.csv") -NoTypeInformation
            }
        }
        catch {
            Write-Warning "System information collection error: $($_.Exception.Message)"
        }

        return $sysInfo
    }
    function ConvertTo-DateTime {
        param($InputValue)
    
        if ($InputValue -is [datetime]) {
            return $InputValue
        }
    
        if ($InputValue -is [string]) {
            $InputValue = $InputValue.Trim()
        
            if ($InputValue.ToLower() -eq 'now') {
                return Get-Date
            }
        
            if ($InputValue -match '^(\d+)([DHMdhm])$') {
                $number = [int]$matches[1]
                $unit = $matches[2].ToUpper()
            
                $currentTime = Get-Date
                switch ($unit) {
                    'D' { return $currentTime.AddDays(-$number) }
                    'H' { return $currentTime.AddHours(-$number) }
                    'M' { return $currentTime.AddMinutes(-$number) }
                }
            }
            else {
                try {
                    return [datetime]$InputValue
                }
                catch {
                    throw "Invalid date format: $InputValue. Use datetime, 'now', or relative format like '7D', '24H', or '30M'"
                }
            }
        }
    
        throw "Invalid date input: $InputValue"
    }

    # Helper function: Invoke Hunt-Registry for comprehensive registry analysis
    function Invoke-RegistryForensics {
        param(
            [string]$OutputDir
        )
    
        try {
            Write-Host "  [-] Running registry collection..." -ForegroundColor DarkGray
            
            # Check if Hunt-Registry function exists
            if (Get-Command Hunt-Registry -ErrorAction SilentlyContinue) {
                # Use Hunt-Registry to get all Run keys and autorun locations
                $registryResults = Hunt-Registry -RunKeys -LoadHives -PassThru -Quiet -OutputCSV (Join-Path $OutputDir "Registry_RunKeys.csv")
            }
            else {
                Write-Host "  [!] Hunt-Registry function not found, skipping registry analysis" -ForegroundColor Red
                return @()
            }
            
            if ($null -eq $registryResults) {
                $registryResults = @()
            }
            
            Write-Host "  [-] Found $($registryResults.Count) registry entries" -ForegroundColor DarkGray
            
            return $registryResults
        }
        catch {
            Write-Host "  [!] Registry analysis error: $($_.Exception.Message)" -ForegroundColor Red
            return @()
        }
    }

    # Helper function: Export data to JSON
    function Export-ForensicJSON {
        param(
            [string]$OutputDir,
            [hashtable]$ForensicData
        )
    
        $jsonDir = Join-Path $OutputDir "JSON_Files"
        if (-not (Test-Path $jsonDir)) {
            New-Item -Path $jsonDir -ItemType Directory -Force | Out-Null
        }
    
        $exports = @{
            'persistence.json' = $ForensicData.Persistence
            'logs.json'        = $ForensicData.Logs
            'browser.json'     = $ForensicData.Browser
            'services.json'    = $ForensicData.Services
            'tasks.json'       = $ForensicData.Tasks
            'files.json'       = $ForensicData.Files.All
            'registry.json'    = $ForensicData.Registry
            'systeminfo.json'  = $ForensicData.SystemInfo
        }
    
        foreach ($file in $exports.Keys) {
            try {
                $data = $exports[$file]
                if ($null -ne $data) {
                    # Handle different data types
                    $recordCount = 0
                    if ($data -is [array]) {
                        $recordCount = $data.Count
                    }
                    elseif ($data -is [hashtable] -or $data -is [PSCustomObject]) {
                        $recordCount = 1
                    }
                    
                    if ($recordCount -gt 0) {
                        $jsonPath = Join-Path $jsonDir $file
                        $limitedData = $data
                        
                        # Use Depth 2 for better performance while maintaining data integrity
                        $jsonContent = $limitedData | ConvertTo-Json -Depth 2 -Compress -ErrorAction Stop
                        $jsonContent | Out-File -FilePath $jsonPath -Encoding UTF8 -ErrorAction Stop
                        Write-Host "  [-] Exported $file ($recordCount records)" -ForegroundColor DarkGray
                    }
                }
            }
            catch {
                Write-Warning "Failed to export $file : $($_.Exception.Message)"
            }
        }
    }
    
    function Generate-HTMLReport {
        param(
            [hashtable]$ForensicData,
            [string]$OutputPath,
            [string]$CSVDir,
            $StartDate,
            $EndDate,
            [string]$Mode,
            [int]$MaxChars = 500,
            [int]$MaxRows = 0,
            [switch]$AllFields
        )
        

        # Helper function to safely encode JavaScript strings
        function ConvertTo-SafeJsString {
            param([object]$Value)
        
            if ($null -eq $Value -or [string]::IsNullOrWhiteSpace($Value.ToString())) {
                return ""
            }
        
            try {
                # Convert to string first, then encode
                $strValue = $Value.ToString()
                return [System.Web.HttpUtility]::JavaScriptStringEncode($strValue)
            }
            catch {
                # Fallback: manual escaping if JavaScriptStringEncode fails
                $strValue = $Value.ToString()
                $strValue = $strValue -replace '\\', '\\'
                $strValue = $strValue -replace "'", "\'"
                $strValue = $strValue -replace '"', '\"'
                $strValue = $strValue -replace "`n", '\n'
                $strValue = $strValue -replace "`r", '\r'
                $strValue = $strValue -replace "`t", '\t'
                return $strValue
            }
        }

        # Ensure System.Web assembly is loaded
        try {
            Add-Type -AssemblyName System.Web
        }
        catch {
            Write-Verbose "System.Web assembly already loaded or unavailable"
        }

        # HTML generation code starts here

        # Load System.Web assembly for HtmlEncode
        try {
            Add-Type -AssemblyName System.Web -ErrorAction Stop
        }
        catch {
            Write-Warning "Failed to load System.Web assembly. HTML encoding may not work properly."
        }

        $hostname = $env:COMPUTERNAME
        $reportDate = Get-Date -Format "yyyy-MM-dd HH:mm:ss"

        Write-Host "  [-] Preparing report data..." -ForegroundColor DarkGray

        # Calculate stats
        $regCount = 0
        if ($ForensicData.Registry) {
            # Registry data is now an array from Hunt-Registry, not a hashtable
            if ($ForensicData.Registry -is [array]) {
                $regCount = $ForensicData.Registry.Count
            }
            elseif ($ForensicData.Registry) {
                $regCount = 1
            }
        }

        $stats = @{
            Persistence = if ($ForensicData.Persistence) { $ForensicData.Persistence.Count } else { 0 }
            Files       = if ($ForensicData.Files -and $ForensicData.Files.All) { $ForensicData.Files.All.Count } else { 0 }
            Registry    = $regCount
            Browser     = if ($ForensicData.Browser) { $ForensicData.Browser.Count } else { 0 }
            Logs        = if ($ForensicData.Logs) { $ForensicData.Logs.Count } else { 0 }
            Services    = if ($ForensicData.Services) { $ForensicData.Services.Count } else { 0 }
            Tasks       = if ($ForensicData.Tasks) { $ForensicData.Tasks.Count } else { 0 }
        }

        # Define field omissions per data type
        $omitFields = if (-not $AllFields) {
            # Check if browser data is from LoadTool mode
            $browserOmitFields = @('String', 'Hostname', 'Source')
            if ($ForensicData.Browser -and $ForensicData.Browser.Count -gt 0) {
                try {
                    $sampleBrowser = $ForensicData.Browser[0]
                    if ($null -ne $sampleBrowser -and $sampleBrowser.PSObject.Properties['MatchPattern'] -and $sampleBrowser.MatchPattern -eq 'LoadTool') {
                        # LoadTool mode: omit additional fields
                        $browserOmitFields = @('String', 'Hostname', 'Source', 'MatchPattern', 'Length', 'Count')
                        Write-Host "  [-] Detected LoadTool browser data, adjusting field display" -ForegroundColor DarkGray
                    }
                }
                catch {
                    Write-Verbose "Could not determine browser data source mode"
                }
            }
            
            @{
                persistence = @('Hostname', 'IsBuiltInBinary', 'IsLolbin')
                logs        = @('Type', 'TimeCreated', 'RecordId', 'XML', 'Hostname', 'FilePath', 'FileName', 'CreationDate', 'LastModifiedDate', 'Text')
                browser     = $browserOmitFields
                services    = @('Hostname')
                tasks       = @('TaskFileExists', 'TaskFileModified', 'ExecutableExists', 'ScriptFileExists', 'Hostname', 'TaskFileSHA256')
                files       = @('MatchReason', 'IsDirectory', 'MatchedContent', 'MatchedNames')
            }
        }
        else {
            @{
                persistence = @()
                logs        = @()
                browser     = @()
                services    = @()
                tasks       = @()
                files       = @()
            }
        }


        # Helper function to prepare data for JSON embedding
        function Prepare-DataForJSON {
            param($Data, $Type, $MaxRows, $OmitFields)

            # Handle null or empty data
            if ($null -eq $Data -or $Data.Count -eq 0) {
                return '[]'
            }
            
            # Ensure Data is always an array
            if ($Data -isnot [array]) {
                $Data = @($Data)
            }

            $dataToProcess = $Data
            if ($MaxRows -gt 0 -and $Data.Count -gt $MaxRows) {
                Write-Host "  [-] Limiting to first $MaxRows records..." -ForegroundColor DarkGray
                $dataToProcess = $Data | Select-Object -First $MaxRows
            }

            # Collect all unique keys from sample of data
            $allKeysSet = [System.Collections.Generic.HashSet[string]]::new()
            
            # Safely calculate sample size
            $dataCount = if ($dataToProcess -is [array]) { $dataToProcess.Count } else { 1 }
            $sampleSize = [Math]::Min(50, $dataCount)

            for ($i = 0; $i -lt $sampleSize; $i++) {
                try {
                    $currentItem = if ($dataToProcess -is [array]) { $dataToProcess[$i] } else { $dataToProcess }
                    if ($currentItem -is [PSCustomObject]) {
                        foreach ($prop in $currentItem.PSObject.Properties) {
                            if (![string]::IsNullOrWhiteSpace($prop.Name)) {
                                [void]$allKeysSet.Add($prop.Name)
                            }
                        }
                    }
                }
                catch {
                    Write-Verbose "Error processing item at index $i - $($_.Exception.Message)"
                    continue
                }
            }
            $allKeys = @($allKeysSet)

            # Filter out omitted fields
            if ($OmitFields -and $OmitFields.Count -gt 0) {
                $allKeys = $allKeys | Where-Object { $_ -notin $OmitFields }
            }

            # Define critical fields that should always be included if they exist (regardless of having values)
            $criticalFields = @{
                'persistence' = @('Flag')
                'files'       = @('SHA256')
                'services'    = @()
                'tasks'       = @()
                'logs'        = @()
            }
    
            $typeCriticalFields = if ($criticalFields.ContainsKey($Type)) { $criticalFields[$Type] } else { @() }

            # Determine which keys have meaningful values
            $keysToKeep = [System.Collections.ArrayList]::new()
            foreach ($key in $allKeys) {
                # Always include critical fields if they exist in the data
                if ($typeCriticalFields -contains $key) {
                    [void]$keysToKeep.Add($key)
                    continue
                }
        
                $hasValue = $false
                $sampleLimit = [Math]::Min(50, $dataToProcess.Count)
        
                for ($i = 0; $i -lt $sampleLimit; $i++) {
                    $currentItem = $dataToProcess[$i]
                    $value = $currentItem.$key
            
                    if ($null -ne $value -and $value -ne '' -and $value -ne 0) {
                        $hasValue = $true
                        break
                    }
                }
                if ($hasValue) {
                    [void]$keysToKeep.Add($key)
                }
            }

            # Build filtered data - CRITICAL: Use proper array building
            $filteredData = [System.Collections.Generic.List[PSCustomObject]]::new()
            
            foreach ($item in $dataToProcess) {
                $newObj = [ordered]@{}
                
                foreach ($key in $keysToKeep) {
                    # Get property value safely with multiple fallback methods
                    $propValue = $null
                    $accessMethod = 'none'
                    
                    # Method 1: Try PSObject.Properties access (safest)
                    try {
                        $prop = $item.PSObject.Properties[$key]
                        if ($null -ne $prop) {
                            $propValue = $prop.Value
                            $accessMethod = 'PSObject'
                        }
                    }
                    catch {
                        Write-Verbose "PSObject access failed for key '$key': $($_.Exception.Message)"
                    }
                    
                    # Method 2: Fallback to direct access if PSObject failed
                    if ($null -eq $propValue -and $accessMethod -eq 'none') {
                        try {
                            $propValue = $item.$key
                            $accessMethod = 'Direct'
                        }
                        catch {
                            Write-Verbose "Direct access failed for key '$key': $($_.Exception.Message)"
                        }
                    }

                    # Method 3: Clean any enumerator or complex types
                    if ($null -ne $propValue) {
                        $propType = $propValue.GetType().Name
                        
                        # Handle enumerators and iterators
                        if ($propType -match 'Enumerator|Iterator') {
                            try {
                                # Convert enumerator to array
                                $propValue = @($propValue)
                                if ($propValue.Count -eq 0) {
                                    $propValue = $null
                                }
                                elseif ($propValue.Count -eq 1) {
                                    $propValue = $propValue[0]
                                }
                            }
                            catch {
                                Write-Verbose "Could not convert enumerator for key '$key'"
                                $propValue = $null
                            }
                        }
                        
                        # Convert complex objects to strings for safety
                        if ($propValue -is [System.Management.Automation.PSCustomObject] -or 
                            $propValue -is [hashtable]) {
                            try {
                                # For nested objects, convert to string representation
                                $propValue = $propValue | ConvertTo-Json -Depth 1 -Compress -ErrorAction SilentlyContinue
                            }
                            catch {
                                $propValue = $propValue.ToString()
                            }
                        }
                    }
                    
                    # Method 3: Fallback to GetType().GetProperty() for difficult cases
                    if ($null -eq $propValue -and $accessMethod -eq 'none') {
                        try {
                            $reflectionProp = $item.GetType().GetProperty($key)
                            if ($null -ne $reflectionProp) {
                                $propValue = $reflectionProp.GetValue($item, $null)
                                $accessMethod = 'Reflection'
                            }
                        }
                        catch {
                            Write-Verbose "Reflection access failed for key '$key': $($_.Exception.Message)"
                        }
                    }
                    
                    # Log if all access methods failed
                    if ($null -eq $propValue -and $accessMethod -eq 'none') {
                        Write-Verbose "All access methods failed for key '$key' in $Type data"
                    }
                    
                    # CRITICAL: Handle each type explicitly to prevent enumeration corruption
                    if ($null -eq $propValue) {
                        $newObj[$key] = ''
                    }
                    # NEW: Check for enumerator/iterator objects first (corruption indicator)
                    elseif ($propValue.GetType().Name -match 'Enumerator' -or 
                        $propValue.GetType().Name -match 'Iterator') {
                        Write-Verbose "Detected enumerator object for key '$key' - attempting to enumerate values"
                        try {
                            # Try to get the actual collection
                            $collection = @()
                            if ($propValue -is [System.Collections.IEnumerable]) {
                                foreach ($val in $propValue) {
                                    if ($null -ne $val) {
                                        $collection += $val.ToString()
                                    }
                                }
                            }
                            $newObj[$key] = if ($collection.Count -gt 0) { $collection -join ', ' } else { '' }
                        }
                        catch {
                            Write-Verbose "Failed to enumerate - using empty string for key '$key'"
                            $newObj[$key] = ''
                        }
                    }
                    # ADD THIS NEW CHECK: Validate the value is not corrupted before type checking
                    elseif ($propValue -is [System.Management.Automation.PSObject] -and 
                        $propValue.GetType().Name -notmatch 'PSCustomObject') {
                        # This might be a wrapped object - try to unwrap
                        #Write-Verbose "Unwrapping PSObject for key '$key'"
                        try {
                            $newObj[$key] = $propValue.ToString()
                        }
                        catch {
                            $newObj[$key] = ''
                        }
                    }
                    elseif ($propValue -is [string]) {
                        # Already a string, keep as-is
                        $newObj[$key] = $propValue
                    }
                    elseif ($propValue -is [datetime]) {
                        $newObj[$key] = $propValue.ToString('yyyy-MM-dd HH:mm:ss')
                    }
                    elseif ($propValue -is [bool]) {
                        $newObj[$key] = if ($propValue) { 'True' } else { 'False' }
                    }
                    elseif ($propValue -is [int] -or $propValue -is [long] -or $propValue -is [double] -or $propValue -is [decimal]) {
                        $newObj[$key] = $propValue
                    }
                    elseif ($propValue -is [System.Collections.IEnumerable] -and $propValue -isnot [string]) {
                        # Handle collections - convert to comma-separated string
                        try {
                            $strItems = @()
                            foreach ($val in $propValue) {
                                if ($null -ne $val) {
                                    $strItems += $val.ToString()
                                }
                            }
                            $newObj[$key] = if ($strItems.Count -gt 0) { $strItems -join ', ' } else { '' }
                        }
                        catch {
                            Write-Verbose "Collection enumeration failed for key '$key'"
                            $newObj[$key] = ''
                        }
                    }
                    else {
                        # Use .ToString() method for everything else
                        try {
                            $newObj[$key] = $propValue.ToString()
                        }
                        catch {
                            Write-Verbose "ToString() failed for key '$key' - using empty string"
                            $newObj[$key] = ''
                        }
                    }
                }
                
                # Add to list
                $filteredData.Add([PSCustomObject]$newObj)
            }

            # Convert to JSON with comprehensive error handling
            try {
                # Validate data size before conversion
                if ($filteredData.Count -gt 50000) {
                    Write-Host "  [!] Large dataset ($($filteredData.Count) records) - JSON conversion may be slow" -ForegroundColor Yellow
                }
                
                # Convert List to regular array before JSON conversion
                $arrayData = $filteredData.ToArray()
                
                # Attempt JSON conversion with retry logic
                $retryCount = 0
                $maxRetries = 2
                $json = $null
                
                while ($retryCount -le $maxRetries -and $null -eq $json) {
                    try {
                        $json = $arrayData | ConvertTo-Json -Depth 3 -Compress -ErrorAction Stop
                    }
                    catch {
                        $retryCount++
                        if ($retryCount -gt $maxRetries) {
                            throw
                        }
                        Write-Host "  [!] JSON conversion retry $retryCount/$maxRetries..." -ForegroundColor Yellow
                        Start-Sleep -Milliseconds 500
                    }
                }
                
                # Verify JSON doesn't contain .NET type corruption indicators
                # Check for specific .NET type serialization patterns, not just the words
                if ($json -match 'System\.Collections\.ArrayList' -or 
                    $json -match 'System\.Collections\.Generic\.List.*Enumerator' -or
                    $json -match '\@\{.*Enumerator.*\}') {
                    Write-Verbose "[DEBUG]  [!!!] JSON contains .NET type references - POTENTIAL DATA CORRUPTION DETECTED"
                    Write-Verbose "[DEBUG] Type: $Type"
                    Write-Verbose "[DEBUG] Sample: $($json.Substring(0, [Math]::Min(200, $json.Length)))"
                
                    # Try to identify which items are corrupted
                    Write-Verbose "Attempting to identify corrupted items in $Type data..."
                
                    # Don't immediately fail - log it and return what we have
                    # The JavaScript will handle empty data gracefully
                    Write-Verbose "[DEBUG] Continuing with potentially corrupted data - check console for details"
                }
                
                # Additional validation: ensure JSON is valid JavaScript
                if ([string]::IsNullOrWhiteSpace($json)) {
                    Write-Warning "JSON conversion produced empty result for $Type"
                    return '[]'
                }
                
                # Validate JSON syntax by attempting to parse it back
                try {
                    $testParse = $json | ConvertFrom-Json -ErrorAction Stop
                    Write-Verbose "JSON validation passed for $Type"
                }
                catch {
                    Write-Warning "JSON validation failed for $Type - produced invalid JSON"
                    return '[]'
                }
                
                return $json
            }
            catch {
                Write-Warning "JSON conversion failed for $Type : $($_.Exception.Message)"
                Write-Verbose "Stack trace: $($_.ScriptStackTrace)"
                return '[]'
            }
        }

        # Helper function to translate task state values
        function ConvertTo-TaskStateString {
            param([int]$State)
            switch ($State) {
                0 { return "Unknown" }
                1 { return "Disabled" }
                2 { return "Queued" }
                3 { return "Ready" }
                4 { return "Running" }
                default { return "Unknown ($State)" }
            }
        }
        
        # Helper function to translate service status
        function ConvertTo-ServiceStatusString {
            param($Status)
            if ($null -eq $Status) { return "Unknown" }
            switch ($Status.ToString()) {
                "1" { return "Stopped" }
                "2" { return "StartPending" }
                "3" { return "StopPending" }
                "4" { return "Running" }
                "5" { return "ContinuePending" }
                "6" { return "PausePending" }
                "7" { return "Paused" }
                "Stopped" { return "Stopped" }
                "Running" { return "Running" }
                "Paused" { return "Paused" }
                default { return $Status.ToString() }
            }
        }
        
        # Helper function to translate service start type
        function ConvertTo-ServiceStartTypeString {
            param($StartType)
            if ($null -eq $StartType) { return "Unknown" }
            switch ($StartType.ToString()) {
                "0" { return "Boot" }
                "1" { return "System" }
                "2" { return "Automatic" }
                "3" { return "Manual" }
                "4" { return "Disabled" }
                "Automatic" { return "Automatic" }
                "Manual" { return "Manual" }
                "Disabled" { return "Disabled" }
                "Boot" { return "Boot" }
                "System" { return "System" }
                default { return $StartType.ToString() }
            }
        }

        # Prepare log data with provider categorization
        Write-Host "  [-] Preparing Logs JSON with provider categorization..." -ForegroundColor DarkGray
        $logsWithProvider = @{}
        $allLogs = @()
    
        if ($ForensicData.Logs -and $ForensicData.Logs.Count -gt 0) {
            foreach ($log in $ForensicData.Logs) {
                $provider = if ($log.LogName) { $log.LogName } else { "Unknown" }
            
                if (-not $logsWithProvider.ContainsKey($provider)) {
                    $logsWithProvider[$provider] = @()
                }
                $logsWithProvider[$provider] += $log
                $allLogs += $log
            }
        }
    
        $logProviders = @("All") + ($logsWithProvider.Keys | Sort-Object)
        $logsJson = Prepare-DataForJSON -Data $allLogs -Type 'logs' -MaxRows $MaxRows -OmitFields $omitFields['logs']
    
        $logsByProviderJson = @{}
        foreach ($provider in $logsWithProvider.Keys) {
            $providerData = Prepare-DataForJSON -Data $logsWithProvider[$provider] -Type "logs_$provider" -MaxRows $MaxRows -OmitFields $omitFields['logs']
            $logsByProviderJson[$provider] = $providerData
        }

        # Prepare other data types
        Write-Host "  [-] Preparing Persistence JSON..." -ForegroundColor DarkGray
        $persistenceJson = Prepare-DataForJSON -Data $ForensicData.Persistence -Type 'persistence' -MaxRows $MaxRows -OmitFields $omitFields['persistence']
        if ($persistenceJson -eq '[]') {
            Write-Host "      WARNING: Persistence JSON is empty" -ForegroundColor Yellow
        }
        else {
            Write-Host "      Persistence JSON size: $([math]::Round($persistenceJson.Length / 1KB, 2)) KB" -ForegroundColor DarkGray
        }
    
        Write-Host "  [-] Preparing Browser JSON..." -ForegroundColor DarkGray
        $browserJson = Prepare-DataForJSON -Data $ForensicData.Browser -Type 'browser' -MaxRows $MaxRows -OmitFields $omitFields['browser']
        if ($browserJson -eq '[]') {
            Write-Host "      WARNING: Browser JSON is empty" -ForegroundColor Yellow
        }
        else {
            Write-Host "      Browser JSON size: $([math]::Round($browserJson.Length / 1KB, 2)) KB" -ForegroundColor DarkGray
        }
    
        Write-Host "  [-] Preparing Services JSON with translations..." -ForegroundColor DarkGray
        # Translate service status and start type values
        $servicesTranslated = @()
        if ($ForensicData.Services -and $ForensicData.Services.Count -gt 0) {
            foreach ($service in $ForensicData.Services) {
                try {
                    # Create ordered hashtable with ServiceName and DisplayName first
                    $orderedProps = [ordered]@{}
                    
                    # Add ServiceName and DisplayName first
                    if ($service.PSObject.Properties['ServiceName']) {
                        $orderedProps['ServiceName'] = $service.ServiceName
                    }
                    if ($service.PSObject.Properties['DisplayName']) {
                        $orderedProps['DisplayName'] = $service.DisplayName
                    }
                    
                    # Add all other properties
                    foreach ($prop in $service.PSObject.Properties) {
                        if ($prop.Name -ne 'ServiceName' -and $prop.Name -ne 'DisplayName') {
                            $orderedProps[$prop.Name] = $prop.Value
                        }
                    }
                    
                    # Translate Status field (use Contains() for OrderedDictionary, not ContainsKey())
                    if ($orderedProps.Contains('Status')) {
                        $orderedProps['Status'] = ConvertTo-ServiceStatusString -Status $orderedProps['Status']
                    }

                    # Translate StartType field
                    if ($orderedProps.Contains('StartType')) {
                        $orderedProps['StartType'] = ConvertTo-ServiceStartTypeString -StartType $orderedProps['StartType']
                    }
                    
                    $servicesTranslated += [PSCustomObject]$orderedProps
                }
                catch {
                    Write-Verbose "Service translation error: $($_.Exception.Message)"
                    $servicesTranslated += $service
                }
            }
        }
        $servicesJson = Prepare-DataForJSON -Data $servicesTranslated -Type 'services' -MaxRows $MaxRows -OmitFields $omitFields['services']    
        Write-Host "  [-] Preparing Tasks JSON with translations..." -ForegroundColor DarkGray
        # Translate task state values
        $tasksTranslated = @()
        if ($ForensicData.Tasks -and $ForensicData.Tasks.Count -gt 0) {
            foreach ($task in $ForensicData.Tasks) {
                try {
                    $translatedTask = $task.PSObject.Copy()
                    
                    # Translate State field if it's numeric
                    if ($translatedTask.PSObject.Properties['State']) {
                        $stateValue = $translatedTask.State
                        if ($stateValue -is [int] -or ($stateValue -match '^\d+$')) {
                            $translatedTask.State = ConvertTo-TaskStateString -State ([int]$stateValue)
                        }
                    }
                    
                    $tasksTranslated += $translatedTask
                }
                catch {
                    $tasksTranslated += $task
                    continue
                }
            }
        }
        $tasksJson = Prepare-DataForJSON -Data $tasksTranslated -Type 'tasks' -MaxRows $MaxRows -OmitFields $omitFields['tasks']
    
        Write-Host "  [-] Preparing Files JSON..." -ForegroundColor DarkGray
        # Validate Files data structure
        $filesData = @()
        if ($null -ne $ForensicData.Files) {
            if ($ForensicData.Files -is [hashtable] -and $ForensicData.Files.ContainsKey('All')) {
                $filesData = $ForensicData.Files.All
            }
            elseif ($ForensicData.Files -is [array]) {
                $filesData = $ForensicData.Files
            }
        }
        
        if ($null -eq $filesData -or $filesData.Count -eq 0) {
            Write-Host "  [!] WARNING: No files data found" -ForegroundColor Yellow
            $filesJson = '[]'
        }
        else {
            Write-Host "  [-] Processing $($filesData.Count) files..." -ForegroundColor DarkGray
            $filesJson = Prepare-DataForJSON -Data $filesData -Type 'files' -MaxRows $MaxRows -OmitFields $omitFields['files']
        }

        Write-Host "  [-] Preparing Registry JSON..." -ForegroundColor DarkGray
        # Registry data validation and normalization
        $registryData = @()
        try {
            if ($null -ne $ForensicData.Registry) {
                if ($ForensicData.Registry -is [array]) {
                    $registryData = $ForensicData.Registry
                }
                elseif ($ForensicData.Registry -is [hashtable]) {
                    Write-Host "  [!] Registry data in hashtable format, converting to array" -ForegroundColor Yellow
                    $registryData = @($ForensicData.Registry.Values)
                }
                else {
                    $registryData = @($ForensicData.Registry)
                }
            }
        }
        catch {
            Write-Host "  [!] Error processing registry data: $($_.Exception.Message)" -ForegroundColor Yellow
            $registryData = @()
        }
        $registryJson = Prepare-DataForJSON -Data $registryData -Type 'registry' -MaxRows $MaxRows -OmitFields @('Hostname', 'SearchTerm', 'MatchLocation', 'CSVExportPath')


        # Build System Info sections as static HTML
        $psHistoryHtml = ""
        if ($ForensicData.SystemInfo.PSHistory -and $ForensicData.SystemInfo.PSHistory.Count -gt 0) {
            $psHistoryHtml = @"
<div class="table-wrapper">
    <table id="pshistory-table">
        <thead>
            <tr>
                <th onclick="sortSystemTable('pshistory-table', 0)" style="width: 80px; position: relative;">#<div class="resizer"></div></th>
                <th onclick="sortSystemTable('pshistory-table', 1)" style="position: relative;">Command<div class="resizer"></div></th>
            </tr>
        </thead>
        <tbody>
"@
            $i = 0
            foreach ($cmd in $ForensicData.SystemInfo.PSHistory) {
                $i++
                $cmdEscaped = [System.Web.HttpUtility]::HtmlEncode($cmd)
                $psHistoryHtml += "            <tr><td>$i</td><td style='font-family: Consolas, monospace;'>$cmdEscaped</td></tr>`n"
            }
            $psHistoryHtml += @"
        </tbody>
    </table>
</div>
"@
        }
        else {
            $psHistoryHtml = "<p style='color: #95a5a6;'>No PowerShell history found.</p>"
        }

        $processHtml = ""
        if ($ForensicData.SystemInfo.Processes -and $ForensicData.SystemInfo.Processes.Count -gt 0) {
            $processHtml = @"
<div class="table-controls">
    <input type="text" id="process-search" placeholder="Search processes..." onkeyup="filterSystemTable('process-table')">
</div>
<div class="table-wrapper">
    <table id="process-table">
        <thead>
            <tr>
                <th onclick="sortSystemTable('process-table', 0)" style="position: relative;">PID<div class="resizer"></div></th>
                <th onclick="sortSystemTable('process-table', 1)" style="position: relative;">Process Name<div class="resizer"></div></th>
                <th onclick="sortSystemTable('process-table', 2)" style="position: relative;">User<div class="resizer"></div></th>
                <th onclick="sortSystemTable('process-table', 3)" style="position: relative;">Path<div class="resizer"></div></th>
                <th onclick="sortSystemTable('process-table', 4)" style="position: relative;">Company<div class="resizer"></div></th>
                <th onclick="sortSystemTable('process-table', 5)" style="position: relative;">Memory (MB)<div class="resizer"></div></th>
                <th onclick="sortSystemTable('process-table', 6)" style="position: relative;">CPU Time (s)<div class="resizer"></div></th>
                <th onclick="sortSystemTable('process-table', 7)" style="position: relative;">Start Time<div class="resizer"></div></th>
            </tr>
        </thead>
        <tbody>
"@
            foreach ($proc in $ForensicData.SystemInfo.Processes) {
                $memMB = if ($proc.WS -and $proc.WS -gt 0) { [math]::Round($proc.WS / 1MB, 2) } else { 0 }
                $cpu = if ($proc.CPU -and $proc.CPU -gt 0) { [math]::Round($proc.CPU, 2) } else { 0 }
                $path = if ($proc.Path) { [System.Web.HttpUtility]::HtmlEncode($proc.Path) } else { "N/A" }
                $company = if ($proc.Company) { [System.Web.HttpUtility]::HtmlEncode($proc.Company) } else { "N/A" }
                $user = if ($proc.UserName) { [System.Web.HttpUtility]::HtmlEncode($proc.UserName) } else { "N/A" }
                $start = if ($proc.StartTime) { $proc.StartTime.ToString("yyyy-MM-dd HH:mm:ss") } else { "N/A" }
                $processHtml += "            <tr><td>$($proc.Id)</td><td>$($proc.ProcessName)</td><td>$user</td><td style='max-width: 300px; overflow: hidden; text-overflow: ellipsis;' title='$path'>$path</td><td>$company</td><td>$memMB</td><td>$cpu</td><td>$start</td></tr>`n"
            }
            $processHtml += @"
        </tbody>
    </table>
</div>
"@
        }
        else {
            $processHtml = "<p style='color: #95a5a6;'>No process information available.</p>"
        }

        $dnsHtml = ""
        if ($ForensicData.SystemInfo.DNSCache -and $ForensicData.SystemInfo.DNSCache.Count -gt 0) {
            $dnsHtml = @"
<div class="table-controls">
    <input type="text" id="dns-search" placeholder="Search DNS cache..." onkeyup="filterSystemTable('dns-table')">
</div>
<div class="table-wrapper">
    <table id="dns-table">
        <thead>
            <tr>
                <th onclick="sortSystemTable('dns-table', 0)" style="position: relative;">Name<div class="resizer"></div></th>
                <th onclick="sortSystemTable('dns-table', 1)" style="position: relative;">Type<div class="resizer"></div></th>
                <th onclick="sortSystemTable('dns-table', 2)" style="position: relative;">Data<div class="resizer"></div></th>
                <th onclick="sortSystemTable('dns-table', 3)" style="position: relative;">TTL<div class="resizer"></div></th>
            </tr>
        </thead>
        <tbody>
"@
            foreach ($dns in $ForensicData.SystemInfo.DNSCache) {
                # Extract actual record name (Entry or RecordName property)
                $nameRaw = if ($dns.Entry) { 
                    $dns.Entry 
                }
                elseif ($dns.RecordName) { 
                    $dns.RecordName 
                }
                elseif ($dns.Name) { 
                    $dns.Name 
                }
                else { 
                    "N/A" 
                }
                
                # Create hyperlink for domain names
                $name = if ($nameRaw -ne "N/A" -and $nameRaw -match '^[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,}$') {
                    $encodedName = [System.Web.HttpUtility]::HtmlEncode($nameRaw)
                    "<a href='https://www.virustotal.com/gui/domain/$encodedName' target='_blank' class='vt-link' title='Lookup on VirusTotal'>$encodedName</a>"
                }
                else {
                    [System.Web.HttpUtility]::HtmlEncode($nameRaw)
                }
                
                # Get record type
                $type = if ($dns.Type) { 
                    $dns.Type 
                }
                elseif ($dns.RecordType) { 
                    $dns.RecordType 
                }
                else { 
                    "N/A" 
                }
                
                # Get data/record value
                $dataRaw = if ($dns.Data) { 
                    $dns.Data 
                }
                elseif ($dns.Record) { 
                    $dns.Record 
                }
                else { 
                    "N/A" 
                }
                
                # Create hyperlink for IP addresses or domains in data field
                $data = if ($dataRaw -ne "N/A") {
                    if ($dataRaw -match '^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$') {
                        # It's an IP address
                        "<a href='https://scamalytics.com/ip/$dataRaw' target='_blank' class='vt-link' title='Lookup on Scamalytics'>$dataRaw</a>"
                    }
                    elseif ($dataRaw -match '^[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,}$') {
                        # It's a domain
                        $encodedData = [System.Web.HttpUtility]::HtmlEncode($dataRaw)
                        "<a href='https://www.virustotal.com/gui/domain/$encodedData' target='_blank' class='vt-link' title='Lookup on VirusTotal'>$encodedData</a>"
                    }
                    else {
                        [System.Web.HttpUtility]::HtmlEncode($dataRaw)
                    }
                }
                else {
                    "N/A"
                }
                
                # Get TTL
                $ttl = if ($dns.TimeToLive) { 
                    $dns.TimeToLive 
                }
                elseif ($dns.TTL) { 
                    $dns.TTL 
                }
                else { 
                    "N/A" 
                }
                
                # Only add row if we have meaningful data (skip AAAA NoRecords entries)
                if ($nameRaw -ne "N/A" -or $dataRaw -ne "N/A") {
                    $dnsHtml += "            <tr><td>$name</td><td>$type</td><td>$data</td><td>$ttl</td></tr>`n"
                }
            }
            $dnsHtml += @"
        </tbody>
    </table>
</div>
"@
        }
        else {
            $dnsHtml = "<p style='color: #95a5a6;'>No DNS cache entries found.</p>"
        }

        $networkHtml = ""
        if ($ForensicData.SystemInfo.NetworkConnections -and $ForensicData.SystemInfo.NetworkConnections.Count -gt 0) {
            $networkHtml = @"
<div class="table-controls">
    <input type="text" id="network-search" placeholder="Search connections..." onkeyup="filterSystemTable('network-table')">
</div>
<div class="table-wrapper">
    <table id="network-table">
        <thead>
            <tr>
                <th onclick="sortSystemTable('network-table', 0)" style="position: relative;">Local Address<div class="resizer"></div></th>
                <th onclick="sortSystemTable('network-table', 1)" style="position: relative;">Local Port<div class="resizer"></div></th>
                <th onclick="sortSystemTable('network-table', 2)" style="position: relative;">Remote Address<div class="resizer"></div></th>
                <th onclick="sortSystemTable('network-table', 3)" style="position: relative;">Remote Port<div class="resizer"></div></th>
                <th onclick="sortSystemTable('network-table', 4)" style="position: relative;">State<div class="resizer"></div></th>
                <th onclick="sortSystemTable('network-table', 5)" style="position: relative;">Process ID<div class="resizer"></div></th>
            </tr>
        </thead>
        <tbody>
"@
            $limitedConnections = $ForensicData.SystemInfo.NetworkConnections | Select-Object -First 500
            foreach ($conn in $limitedConnections) {
                # Create hyperlinks for IP addresses
                $localAddr = if ($conn.LocalAddress -and $conn.LocalAddress -ne '0.0.0.0' -and $conn.LocalAddress -ne '::' -and $conn.LocalAddress -ne '127.0.0.1' -and $conn.LocalAddress -notlike '*:*') {
                    "<a href='https://scamalytics.com/ip/$($conn.LocalAddress)' target='_blank' class='vt-link' title='Lookup on Scamalytics'>$($conn.LocalAddress)</a>"
                }
                else {
                    $conn.LocalAddress
                }
                
                $remoteAddr = if ($conn.RemoteAddress -and $conn.RemoteAddress -ne '0.0.0.0' -and $conn.RemoteAddress -ne '::' -and $conn.RemoteAddress -notlike '*:*') {
                    "<a href='https://scamalytics.com/ip/$($conn.RemoteAddress)' target='_blank' class='vt-link' title='Lookup on Scamalytics'>$($conn.RemoteAddress)</a>"
                }
                else {
                    $conn.RemoteAddress
                }
                
                $networkHtml += "            <tr><td>$localAddr</td><td>$($conn.LocalPort)</td><td>$remoteAddr</td><td>$($conn.RemotePort)</td><td>$($conn.State)</td><td>$($conn.OwningProcess)</td></tr>`n"
            }
            $networkHtml += @"
        </tbody>
    </table>
</div>
"@
            if ($ForensicData.SystemInfo.NetworkConnections.Count -gt 500) {
                $networkHtml += "<p style='color: #f39c12; margin-top: 10px;'>Showing first 500 of $($ForensicData.SystemInfo.NetworkConnections.Count) connections. See CSV for complete data.</p>"
            }
        }
        else {
            $networkHtml = "<p style='color: #95a5a6;'>No active network connections.</p>"
        }

        $shadowHtml = ""
        $vssStatusColor = '#e74c3c'
        if ($ForensicData.SystemInfo -and $ForensicData.SystemInfo.VSSServiceStatus -eq 'Running') {
            $vssStatusColor = '#2ecc71'
        }
        $shadowCountColor = '#e74c3c'
        if ($ForensicData.SystemInfo -and $ForensicData.SystemInfo.ShadowCopyCount -gt 0) {
            $shadowCountColor = '#2ecc71'
        }
    
        if ($ForensicData.SystemInfo.ShadowCopies -and $ForensicData.SystemInfo.ShadowCopies.Count -gt 0) {
            $shadowHtml = @"
<div class="table-wrapper">
    <table id="shadow-table">
        <thead>
            <tr>
                <th onclick="sortSystemTable('shadow-table', 0)" style="position: relative;">Shadow Copy ID<div class="resizer"></div></th>
                <th onclick="sortSystemTable('shadow-table', 1)" style="position: relative;">Install Date<div class="resizer"></div></th>
                <th onclick="sortSystemTable('shadow-table', 2)" style="position: relative;">Volume Name<div class="resizer"></div></th>
                <th onclick="sortSystemTable('shadow-table', 3)" style="position: relative;">Size (MB)<div class="resizer"></div></th>
            </tr>
        </thead>
        <tbody>
"@
            foreach ($shadow in $ForensicData.SystemInfo.ShadowCopies) {
                $shadowHtml += "            <tr><td>$($shadow.ID)</td><td>$($shadow.InstallDate)</td><td>$($shadow.VolumeName)</td><td>$($shadow.SizeMB)</td></tr>`n"
            }
            $shadowHtml += @"
        </tbody>
    </table>
</div>
"@
        }
        else {
            $shadowHtml = "<p style='color: #95a5a6;'>No shadow copies found on this system.</p>"
        }

        $usersHtml = ""
        if ($ForensicData.SystemInfo.LocalUsers -and $ForensicData.SystemInfo.LocalUsers.Count -gt 0) {
            $usersHtml = @"
<div class="table-wrapper">
    <table id="users-table">
        <thead>
            <tr>
                <th onclick="sortSystemTable('users-table', 0)" style="position: relative;">Name<div class="resizer"></div></th>
                <th onclick="sortSystemTable('users-table', 1)" style="position: relative;">Enabled<div class="resizer"></div></th>
                <th onclick="sortSystemTable('users-table', 2)" style="position: relative;">Last Logon<div class="resizer"></div></th>
                <th onclick="sortSystemTable('users-table', 3)" style="position: relative;">Password Last Set<div class="resizer"></div></th>
                <th onclick="sortSystemTable('users-table', 4)" style="position: relative;">Description<div class="resizer"></div></th>
            </tr>
        </thead>
        <tbody>
"@
            foreach ($user in $ForensicData.SystemInfo.LocalUsers) {
                $desc = if ($user.Description) { [System.Web.HttpUtility]::HtmlEncode($user.Description) } else { "" }
                $lastLogon = if ($user.LastLogon) { $user.LastLogon.ToString("yyyy-MM-dd HH:mm:ss") } else { "Never" }
                $pwdSet = if ($user.PasswordLastSet) { $user.PasswordLastSet.ToString("yyyy-MM-dd HH:mm:ss") } else { "Never" }
                $usersHtml += "            <tr><td>$($user.Name)</td><td>$($user.Enabled)</td><td>$lastLogon</td><td>$pwdSet</td><td>$desc</td></tr>`n"
            }
            $usersHtml += @"
        </tbody>
    </table>
</div>
"@
        }
        else {
            $usersHtml = "<p style='color: #95a5a6;'>No local user information available.</p>"
        }

        $adaptersHtml = ""
        if ($ForensicData.SystemInfo.NetworkAdapters -and $ForensicData.SystemInfo.NetworkAdapters.Count -gt 0) {
            $adaptersHtml = @"
<div class="table-wrapper">
    <table id="adapters-table">
        <thead>
            <tr>
                <th onclick="sortSystemTable('adapters-table', 0)" style="position: relative;">Name<div class="resizer"></div></th>
                <th onclick="sortSystemTable('adapters-table', 1)" style="position: relative;">Status<div class="resizer"></div></th>
                <th onclick="sortSystemTable('adapters-table', 2)" style="position: relative;">MAC Address<div class="resizer"></div></th>
                <th onclick="sortSystemTable('adapters-table', 3)" style="position: relative;">Link Speed<div class="resizer"></div></th>
            </tr>
        </thead>
        <tbody>
"@
            foreach ($adapter in $ForensicData.SystemInfo.NetworkAdapters) {
                $name = [System.Web.HttpUtility]::HtmlEncode($adapter.Name)
                $adaptersHtml += "            <tr><td>$name</td><td>$($adapter.Status)</td><td>$($adapter.MacAddress)</td><td>$($adapter.LinkSpeed)</td></tr>`n"
            }
            $adaptersHtml += @"
        </tbody>
    </table>
</div>
"@
        }
        else {
            $adaptersHtml = "<p style='color: #95a5a6;'>No network adapter information available.</p>"
        }

        # Build log provider selector JSON
        $logProvidersJson = $logProviders | ConvertTo-Json -Compress

        $html = @"
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forensic Report - $hostname</title>
    <style>
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2c2c2c;
            --bg-tertiary: #333;
            --bg-quaternary: #2a2a2a;
            --bg-header: linear-gradient(135deg, #2c3e50, #34495e);
            --bg-card: linear-gradient(135deg, #34495e, #2c3e50);
            --text-primary: #e0e0e0;
            --text-secondary: #bdc3c7;
            --text-muted: #95a5a6;
            --text-dark: #7f8c8d;
            --border-color: #444;
            --border-accent: #34495e;
            --accent-blue: #3498db;
            --accent-blue-hover: #2980b9;
            --accent-green: #2ecc71;
            --accent-red: #e74c3c;
            --accent-yellow: #f39c12;
            --hover-bg: #3a3a3a;
            --table-header: #34495e;
            --table-header-hover: #415b76;
            --input-bg: #1a1a1a;
            --input-border: #555;
            --button-bg: #34495e;
            --shadow: rgba(0, 0, 0, 0.4);
        }
        
        [data-theme="light"] {
            --bg-primary: #e8eaed;
            --bg-secondary: #f1f3f5;
            --bg-tertiary: #e0e3e7;
            --bg-quaternary: #ebedef;
            --bg-header: linear-gradient(135deg, #5b7a9e, #4a6b8a);
            --bg-card: linear-gradient(135deg, #6b8aae, #5b7a9e);
            --text-primary: #2d3748;
            --text-secondary: #4a5568;
            --text-muted: #718096;
            --text-dark: #a0aec0;
            --border-color: #cbd5e0;
            --border-accent: #5b7a9e;
            --accent-blue: #4a7ba7;
            --accent-blue-hover: #5a8bb7;
            --accent-green: #48a564;
            --accent-red: #d65745;
            --accent-yellow: #db8b3a;
            --hover-bg: #dde1e6;
            --table-header: #5b7a9e;
            --table-header-hover: #6b8aae;
            --input-bg: #f7f9fb;
            --input-border: #b8c5d0;
            --button-bg: #5b7a9e;
            --shadow: rgba(0, 0, 0, 0.08);
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            background: var(--bg-primary); 
            color: var(--text-primary);
            transition: background-color 0.4s ease, color 0.4s ease;
        }
        html {
            transition: background-color 0.4s ease;
        }
        [data-theme="light"] body {
            filter: brightness(0.98);
        }
        [data-theme="light"] .header {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        [data-theme="light"] table {
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }
        .header { 
            background: var(--bg-header); 
            padding: 30px; 
            text-align: center;
            position: relative;
        }
        .header h1 { color: #ecf0f1; font-size: 2.5em; margin-bottom: 10px; }
        .header .info { color: var(--text-secondary); font-size: 0.9em; }
        
        .theme-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            color: white;
            font-weight: bold;
            transition: background 0.3s;
            font-size: 14px;
            backdrop-filter: blur(10px);
        }
        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .footer {
            background: var(--bg-secondary);
            padding: 30px;
            text-align: center;
            border-top: 2px solid var(--border-accent);
            margin-top: 40px;
        }
        .footer a {
            color: var(--accent-blue);
            text-decoration: none;
            font-weight: bold;
            margin: 0 10px;
        }
        .footer a:hover {
            color: var(--accent-blue-hover);
            text-decoration: underline;
        }
        .footer .footer-info {
            color: var(--text-muted);
            margin-top: 10px;
            font-size: 0.9em;
        }
        
        .tab-container { background: var(--bg-secondary); border-bottom: 2px solid var(--border-accent); }
        .tabs { display: flex; flex-wrap: wrap; padding: 0 20px; overflow-x: auto; }
        .tab-button { 
            padding: 15px 25px; 
            background: transparent; 
            border: none; 
            color: var(--text-muted); 
            cursor: pointer; 
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease, background-color 0.4s ease, color 0.4s ease, border-color 0.4s ease;
            white-space: nowrap;
            font-size: 14px;
        }
        .tab-button:hover { color: var(--text-primary); background: var(--bg-tertiary); }
        .tab-button.active { color: var(--accent-blue); border-bottom-color: var(--accent-blue); }
        
        .container { max-width: 98%; margin: 20px auto; }
        .tab-content { display: none; padding: 20px; }
        .tab-content.active { display: block; }
        
        .sysinfo-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin: 20px 0; }
        .sysinfo-card { 
            background: var(--bg-secondary); 
            padding: 20px; 
            border-radius: 8px; 
            border-left: 4px solid var(--accent-blue);
            transition: background-color 0.4s ease, border-color 0.4s ease;
        }
        .sysinfo-card h3 { color: var(--accent-blue); margin-bottom: 15px; }
        .sysinfo-item { margin: 8px 0; }
        .sysinfo-label { color: var(--text-muted); display: inline-block; width: 150px; }
        .sysinfo-value { color: var(--text-primary); }
        
        .stat-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }
        .stat-card { background: var(--bg-card); padding: 20px; border-radius: 8px; text-align: center; }
        .stat-number { font-size: 2.5em; color: var(--accent-blue); font-weight: bold; }
        .stat-label { color: var(--text-secondary); margin-top: 5px; }
        
        .section-card { 
            background: var(--bg-secondary); 
            padding: 20px; 
            border-radius: 8px; 
            margin-bottom: 20px;
            border-left: 4px solid var(--accent-blue);
        }
        .section-card h3 { 
            color: var(--accent-blue); 
            margin-bottom: 15px; 
            font-size: 1.2em;
        }
        
        .export-info-card {
            background: var(--bg-secondary);
            padding: 25px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid var(--accent-green);
        }
        .export-info-card h3 {
            color: var(--accent-green);
            margin-bottom: 15px;
        }
        .export-info-item {
            margin: 10px 0;
            padding: 10px;
            background: var(--bg-tertiary);
            border-radius: 4px;
        }
        .export-info-label {
            color: var(--text-muted);
            font-weight: bold;
            display: inline-block;
            width: 180px;
        }
        .export-info-value {
            color: var(--text-primary);
        }
        .export-link {
            color: var(--accent-blue);
            text-decoration: none;
            font-weight: bold;
        }
        .export-link:hover {
            color: var(--accent-blue-hover);
            text-decoration: underline;
        }
        
        .log-provider-selector {
            margin: 15px 0;
            padding: 10px;
            background: var(--bg-primary);
            border-radius: 4px;
        }
        .log-provider-selector label {
            color: var(--text-muted);
            margin-right: 10px;
            font-weight: bold;
        }
        .log-provider-selector select {
            padding: 8px 15px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
        }
        .log-provider-selector select:hover {
            background: var(--hover-bg);
        }
        
        .loading { text-align: center; padding: 20px; color: var(--accent-blue); }
        
        /* Tab content loading spinner */
        .tab-loader {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 300px;
            padding: 40px;
        }
        
        .tab-spinner {
            width: 50px;
            height: 50px;
            position: relative;
            margin-bottom: 20px;
        }
        
        .tab-spinner-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 3px solid transparent;
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: tab-spin 1s linear infinite;
        }
        
        .tab-spinner-ring:nth-child(2) {
            border-top-color: var(--accent-green);
            animation-duration: 1.5s;
            animation-direction: reverse;
        }
        
        @keyframes tab-spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .tab-loader-text {
            color: var(--text-muted);
            font-size: 0.95em;
        }
        .error { color: var(--accent-red); padding: 10px; }
        .warning { background: var(--accent-yellow); color: #000; padding: 10px; border-radius: 4px; margin: 10px 0; }
        .table-controls { margin: 10px 0; }
        .table-controls input { 
            padding: 8px; 
            margin-right: 10px; 
            background: var(--bg-tertiary); 
            border: 1px solid var(--border-color); 
            color: var(--text-primary); 
            border-radius: 4px; 
            min-width: 200px;
        }
        
        table { 
            width: 100%; 
            border-collapse: collapse; 
            background: var(--bg-tertiary); 
            margin: 10px 0; 
            font-size: 0.85em; 
            table-layout: auto;
            transition: background-color 0.4s ease;
        }

        th { 
            background: var(--table-header); 
            color: #ecf0f1; 
            padding: 10px 8px; 
            text-align: left; 
            cursor: pointer; 
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: ellipsis;
            min-width: 80px;
            max-width: 400px;
            font-size: 13px;
            user-select: none;
            position: relative;
        }
        th:hover { background: var(--table-header-hover); }
        th::after { content: ' \25B8'; font-size: 0.7em; opacity: 0.5; }
        
        .resizer {
            position: absolute;
            top: 0;
            right: 0;
            width: 8px;
            cursor: col-resize;
            user-select: none;
            height: 100%;
            z-index: 10;
            background: transparent;
            transition: background 0.2s ease;
        }
        .resizer:hover {
            background: var(--accent-blue);
            opacity: 0.5;
        }
        .resizer.active {
            background: var(--accent-blue);
            opacity: 0.8;
        }
        th.resizing {
            border-right: 2px solid var(--accent-blue);
            background: var(--hover-bg);
        }
        th.resizing .resizer {
            background: var(--accent-blue);
        }
        
        td { 
            padding: 8px; 
            border-bottom: 1px solid var(--border-color); 
            color: var(--text-primary); 
            word-wrap: break-word; 
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 400px;
        }
        td.truncated { cursor: help; }
        tr:hover { background: var(--hover-bg); }
        
        .table-wrapper { 
            max-height: 600px; 
            overflow-y: auto; 
            overflow-x: auto;
            position: relative;
            border: 1px solid var(--border-color);
        }
        
        .table-wrapper table {
            border-collapse: separate;
            border-spacing: 0;
        }
        
        .table-wrapper thead {
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .table-wrapper thead th {
            position: sticky;
            top: 0;
            z-index: 10;
            background: var(--table-header);
            box-shadow: 0 2px 2px -1px rgba(0, 0, 0, 0.4);
        }
        
        .section-card .table-wrapper thead {
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .section-card .table-wrapper thead th {
            position: sticky;
            top: 0;
            z-index: 10;
            background: var(--table-header);
            box-shadow: 0 2px 2px -1px rgba(0, 0, 0, 0.4);
        }
        .csv-section {margin: 20px 0; background: var(--bg-secondary); padding: 20px; border-radius: 8px; }
        .csv-link { 
            display: block; 
            padding: 12px 20px; 
            margin: 8px 0; 
            background: var(--accent-blue); 
            color: white; 
            text-decoration: none; 
            border-radius: 4px; 
            text-align: center;
            transition: background 0.3s;
        }
        .csv-link:hover { background: var(--accent-blue-hover); }
        .record-count { color: var(--text-muted); font-size: 0.9em; margin: 10px 0; }
        .vt-link { color: var(--accent-blue); text-decoration: none; font-weight: 500; }
        .vt-link:hover { color: var(--accent-blue-hover); text-decoration: underline; }
    </style>
</head>
<body>
<!-- Initial page loading overlay -->
    <div id="page-loader" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg-primary); z-index: 9999; display: flex; align-items: center; justify-content: center; flex-direction: column;">
        <div style="text-align: center;">
            <!-- ThreatHunter Multi-Module Hunt Radar -->
            <svg width="100" height="100" viewBox="0 0 50 50" style="color: var(--accent-blue); margin-bottom: 20px;">
                
                <!-- Outer targeting rings -->
                <circle cx="25" cy="25" r="22" fill="none" stroke="currentColor" stroke-width="0.5" opacity="0.2"></circle>
                <circle cx="25" cy="25" r="18" fill="none" stroke="currentColor" stroke-width="0.5" opacity="0.3"></circle>
                <circle cx="25" cy="25" r="14" fill="none" stroke="currentColor" stroke-width="0.5" opacity="0.4"></circle>
                
                <!-- Crosshair -->
                <line x1="25" y1="3" x2="25" y2="10" stroke="currentColor" stroke-width="1.5" opacity="0.6"></line>
                <line x1="25" y1="40" x2="25" y2="47" stroke="currentColor" stroke-width="1.5" opacity="0.6"></line>
                <line x1="3" y1="25" x2="10" y2="25" stroke="currentColor" stroke-width="1.5" opacity="0.6"></line>
                <line x1="40" y1="25" x2="47" y2="25" stroke="currentColor" stroke-width="1.5" opacity="0.6"></line>
                
                <!-- Radar sweep line -->
                <line x1="25" y1="25" x2="25" y2="7" stroke="currentColor" stroke-width="2" opacity="0.8"
                      style="animation: radar-sweep 3s linear infinite; transform-origin: 25px 25px;"></line>
                
                <!-- Target indicators (representing different Hunt modules) -->
                <g style="animation: module-activate 3s ease-in-out infinite;">
                    <circle cx="35" cy="15" r="1.5" fill="currentColor"></circle>
                    <text x="35" y="13" font-size="3" fill="currentColor" text-anchor="middle" opacity="0.8">P</text>
                </g>
                
                <g style="animation: module-activate 3s ease-in-out infinite; animation-delay: 0.3s;">
                    <circle cx="40" cy="25" r="1.5" fill="currentColor"></circle>
                    <text x="40" y="23" font-size="3" fill="currentColor" text-anchor="middle" opacity="0.8">L</text>
                </g>
                
                <g style="animation: module-activate 3s ease-in-out infinite; animation-delay: 0.6s;">
                    <circle cx="35" cy="35" r="1.5" fill="currentColor"></circle>
                    <text x="35" y="33" font-size="3" fill="currentColor" text-anchor="middle" opacity="0.8">B</text>
                </g>
                
                <g style="animation: module-activate 3s ease-in-out infinite; animation-delay: 0.9s;">
                    <circle cx="15" cy="35" r="1.5" fill="currentColor"></circle>
                    <text x="15" y="33" font-size="3" fill="currentColor" text-anchor="middle" opacity="0.8">F</text>
                </g>
                
                <g style="animation: module-activate 3s ease-in-out infinite; animation-delay: 1.2s;">
                    <circle cx="10" cy="25" r="1.5" fill="currentColor"></circle>
                    <text x="10" y="23" font-size="3" fill="currentColor" text-anchor="middle" opacity="0.8">R</text>
                </g>
                
                <g style="animation: module-activate 3s ease-in-out infinite; animation-delay: 1.5s;">
                    <circle cx="15" cy="15" r="1.5" fill="currentColor"></circle>
                    <text x="15" y="13" font-size="3" fill="currentColor" text-anchor="middle" opacity="0.8">S</text>
                </g>
                
                <!-- Center dot (no pulsing) -->
                <circle cx="25" cy="25" r="1.5" fill="currentColor"></circle>
                
            </svg>
            
            <h2 style="color: var(--text-primary); margin-bottom: 10px;">Loading Forensic Report...</h2>
            <p style="color: var(--text-muted); font-size: 0.9em;">ThreatHunter</p>
            <div id="load-progress" style="margin-top: 15px; color: var(--text-dark); font-size: 0.85em;"></div>
           
            <!-- Loading bar -->
            <div style="width: 300px; height: 4px; background: var(--bg-tertiary); border-radius: 2px; margin: 20px auto; overflow: hidden;">
                <div style="width: 100%; height: 100%; background: linear-gradient(90deg, var(--accent-blue), var(--accent-green)); animation: loading-bar 2s ease-in-out infinite;"></div>
            </div>
            
            <!-- Module legend -->
            <p style="color: var(--text-dark); font-size: 0.75em; margin-top: 10px;">github.com/blwhit</p>
        </div>
    </div>
   
    <style>
        @keyframes radar-sweep {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        @keyframes module-activate {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
       
        @keyframes loading-bar {
            0% { transform: translateX(-100%); }
            50% { transform: translateX(0%); }
            100% { transform: translateX(100%); }
        }
    </style>
    
    <div class="header">
        <button class="theme-toggle" onclick="toggleTheme()" id="theme-toggle-btn">Light/Dark Mode</button>
        <h1>Forensic Analysis Report</h1>
        <div class="info">
            <strong>Host:</strong> $hostname | 
            <strong>Generated:</strong> $reportDate | 
            <strong>Time Range:</strong> $StartDate to $EndDate | 
            <strong>Mode:</strong> $Mode
        </div>
    </div>
    
    <div class="tab-container">
        <div class="tabs">
            <button class="tab-button active" onclick="showTab('overview')">Overview</button>
            <button class="tab-button" onclick="showTab('search')">Search</button>
            <button class="tab-button" onclick="showTab('sysinfo')">System Info</button>
            <button class="tab-button" onclick="showTab('persistence')">Persistence ($($stats.Persistence))</button>
            <button class="tab-button" onclick="showTab('registry')">Registry ($($stats.Registry))</button>
            <button class="tab-button" onclick="showTab('logs')">Event Logs ($($stats.Logs))</button>
            <button class="tab-button" onclick="showTab('browser')">Browser ($($stats.Browser))</button>
            <button class="tab-button" onclick="showTab('services')">Services ($($stats.Services))</button>
            <button class="tab-button" onclick="showTab('tasks')">Tasks ($($stats.Tasks))</button>
            <button class="tab-button" onclick="showTab('files')">Files ($($stats.Files))</button>
            <button class="tab-button" onclick="showTab('export')">Export Info</button>
            <button class="tab-button" onclick="showTab('settings')">Settings</button>
        </div>
    </div>
    
    <div class="container">
        <div id="overview-tab" class="tab-content active">
            <h2 style="color: #3498db; margin-bottom: 20px;">System Overview</h2>
            <div class="sysinfo-grid">
                <div class="sysinfo-card">
                    <h3>Basic Information</h3>
                    <div class="sysinfo-item"><span class="sysinfo-label">Hostname:</span><span class="sysinfo-value">$hostname</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Domain:</span><span class="sysinfo-value">$($ForensicData.SystemInfo.Domain)</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Domain Joined:</span><span class="sysinfo-value">$($ForensicData.SystemInfo.IsDomainJoined)</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Default Browser:</span><span class="sysinfo-value">$($ForensicData.SystemInfo.DefaultBrowser)</span></div>
                </div>
                
                <div class="sysinfo-card">
                    <h3>Operating System</h3>
                    <div class="sysinfo-item"><span class="sysinfo-label">OS:</span><span class="sysinfo-value">$(if ($ForensicData.SystemInfo.OSInfo) { "$($ForensicData.SystemInfo.OSInfo.Caption) $($ForensicData.SystemInfo.OSInfo.Version)" } else { 'N/A' })</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Architecture:</span><span class="sysinfo-value">$(if ($ForensicData.SystemInfo.OSInfo) { $ForensicData.SystemInfo.OSInfo.OSArchitecture } else { 'N/A' })</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Build:</span><span class="sysinfo-value">$(if ($ForensicData.SystemInfo.OSInfo) { $ForensicData.SystemInfo.OSInfo.BuildNumber } else { 'N/A' })</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Install Date:</span><span class="sysinfo-value">$(
                        if ($ForensicData.SystemInfo.SystemInfoCmd -and $ForensicData.SystemInfo.SystemInfoCmd.InstallDate) { 
                            $ForensicData.SystemInfo.SystemInfoCmd.InstallDate 
                        } elseif ($ForensicData.SystemInfo.OSInfo -and $ForensicData.SystemInfo.OSInfo.InstallDate) {
                            $ForensicData.SystemInfo.OSInfo.InstallDate.ToString("yyyy-MM-dd HH:mm:ss")
                        } else { 
                            'Unknown' 
                        }
                    )</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">System Locale:</span><span class="sysinfo-value">$(
                        if ($ForensicData.SystemInfo.SystemInfoCmd -and $ForensicData.SystemInfo.SystemInfoCmd.SystemLocale) { 
                            $ForensicData.SystemInfo.SystemInfoCmd.SystemLocale -replace ';', ' - '
                        } else { 
                            'Unknown' 
                        }
                    )</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Boot Time:</span><span class="sysinfo-value">$($ForensicData.SystemInfo.BootTime)</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Uptime:</span><span class="sysinfo-value">$(if ($ForensicData.SystemInfo.Uptime) { "$($ForensicData.SystemInfo.Uptime.Days)d $($ForensicData.SystemInfo.Uptime.Hours)h $($ForensicData.SystemInfo.Uptime.Minutes)m" } else { 'N/A' })</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Time Zone:</span><span class="sysinfo-value">$(if ($ForensicData.SystemInfo.TimeZone) { $ForensicData.SystemInfo.TimeZone.DisplayName } else { 'N/A' })</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Hotfixes Installed:</span><span class="sysinfo-value">$(if ($ForensicData.SystemInfo.SystemInfoCmd.HotfixCount) { $ForensicData.SystemInfo.SystemInfoCmd.HotfixCount } else { 'N/A' })</span></div>
                </div>
                
                <div class="sysinfo-card">
                    <h3>Hardware</h3>
                    <div class="sysinfo-item"><span class="sysinfo-label">System Manufacturer:</span> <span class="sysinfo-value">$(
                        $mfg = $null
                        if ($ForensicData.SystemInfo.SystemInfoCmd.SystemManufacturer) { 
                            $mfg = $ForensicData.SystemInfo.SystemInfoCmd.SystemManufacturer 
                        }
                        elseif ($ForensicData.SystemInfo.ComputerInfo.CsManufacturer) {
                            $mfg = $ForensicData.SystemInfo.ComputerInfo.CsManufacturer
                        }
                        if ($mfg) { [System.Web.HttpUtility]::HtmlEncode($mfg) } else { 'Unknown' }
                    )</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">System Model:</span> <span class="sysinfo-value">$(
                        $model = $null
                        if ($ForensicData.SystemInfo.SystemInfoCmd.SystemModel) { 
                            $model = $ForensicData.SystemInfo.SystemInfoCmd.SystemModel 
                        }
                        elseif ($ForensicData.SystemInfo.ComputerInfo.CsModel) {
                            $model = $ForensicData.SystemInfo.ComputerInfo.CsModel
                        }
                        if ($model) { [System.Web.HttpUtility]::HtmlEncode($model) } else { 'Unknown' }
                    )</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">System Type:</span> <span class="sysinfo-value">$(
                        $type = $null
                        if ($ForensicData.SystemInfo.SystemInfoCmd.SystemType) { 
                            $type = $ForensicData.SystemInfo.SystemInfoCmd.SystemType 
                        }
                        elseif ($ForensicData.SystemInfo.ComputerInfo.CsSystemType) {
                            $type = $ForensicData.SystemInfo.ComputerInfo.CsSystemType
                        }
                        if ($type) { [System.Web.HttpUtility]::HtmlEncode($type) } else { 'Unknown' }
                    )</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Processor:</span> <span class="sysinfo-value">$(
                        $proc = $null
                        if ($ForensicData.SystemInfo.SystemInfoCmd.ProcessorDetails -and $ForensicData.SystemInfo.SystemInfoCmd.ProcessorDetails.Count -gt 0) { 
                            $proc = $ForensicData.SystemInfo.SystemInfoCmd.ProcessorDetails[0] 
                        }
                        elseif ($ForensicData.SystemInfo.ComputerInfo.CsProcessors -and $ForensicData.SystemInfo.ComputerInfo.CsProcessors.Count -gt 0) {
                            $proc = $ForensicData.SystemInfo.ComputerInfo.CsProcessors[0].Name
                        }
                        if ($proc) { [System.Web.HttpUtility]::HtmlEncode($proc) } else { 'Unknown' }
                    )</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">BIOS Version:</span> <span class="sysinfo-value">$(
                        $bios = $null
                        if ($ForensicData.SystemInfo.SystemInfoCmd.BIOSVersion) { 
                            $bios = $ForensicData.SystemInfo.SystemInfoCmd.BIOSVersion 
                        }
                        elseif ($ForensicData.SystemInfo.ComputerInfo.BiosVersion) {
                            $bios = $ForensicData.SystemInfo.ComputerInfo.BiosVersion
                        }
                        if ($bios) { [System.Web.HttpUtility]::HtmlEncode($bios) } else { 'Unknown' }
                    )</span></div>
                </div>
                
                <div class="sysinfo-card">
                    <h3>Memory</h3>
                    <div class="sysinfo-item"><span class="sysinfo-label">Total Physical Memory:</span><span class="sysinfo-value">$(if ($ForensicData.SystemInfo.SystemInfoCmd.TotalPhysicalMemory) { $ForensicData.SystemInfo.SystemInfoCmd.TotalPhysicalMemory } else { 'N/A' })</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Available Physical Memory:</span><span class="sysinfo-value">$(if ($ForensicData.SystemInfo.SystemInfoCmd.AvailablePhysicalMemory) { $ForensicData.SystemInfo.SystemInfoCmd.AvailablePhysicalMemory } else { 'N/A' })</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Virtual Memory Max:</span><span class="sysinfo-value">$(if ($ForensicData.SystemInfo.SystemInfoCmd.VirtualMemoryMax) { $ForensicData.SystemInfo.SystemInfoCmd.VirtualMemoryMax } else { 'N/A' })</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Virtual Memory Available:</span><span class="sysinfo-value">$(if ($ForensicData.SystemInfo.SystemInfoCmd.VirtualMemoryAvailable) { $ForensicData.SystemInfo.SystemInfoCmd.VirtualMemoryAvailable } else { 'N/A' })</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Virtual Memory In Use:</span><span class="sysinfo-value">$(if ($ForensicData.SystemInfo.SystemInfoCmd.VirtualMemoryInUse) { $ForensicData.SystemInfo.SystemInfoCmd.VirtualMemoryInUse } else { 'N/A' })</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Page File Location:</span><span class="sysinfo-value" style="font-size: 0.85em;">$(if ($ForensicData.SystemInfo.SystemInfoCmd.PageFileLocation) { $ForensicData.SystemInfo.SystemInfoCmd.PageFileLocation } else { 'N/A' })</span></div>
                </div>
                
                <div class="sysinfo-card">
                    <h3>Security</h3>
                    <div class="sysinfo-item"><span class="sysinfo-label">Defender Status:</span><span class="sysinfo-value" style="color: $(if ($ForensicData.SystemInfo.DefenderStatus -and $ForensicData.SystemInfo.DefenderStatus.RealTimeProtectionEnabled) { '#2ecc71' } else { '#e74c3c' })">$(if ($ForensicData.SystemInfo.DefenderStatus) { if ($ForensicData.SystemInfo.DefenderStatus.RealTimeProtectionEnabled) { 'Enabled' } else { 'Disabled' } } else { 'N/A' })</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">AntiVirus:</span><span class="sysinfo-value">$(
                        if ($ForensicData.SystemInfo.AntiVirus) { 
                            $avNames = $ForensicData.SystemInfo.AntiVirus | ForEach-Object { $_.displayName } | Where-Object { $_ } | Select-Object -Unique
                            if ($avNames) {
                                ($avNames -join ', ')
                            } else {
                                'None detected'
                            }
                        } else { 
                            'None detected' 
                        }
                    )</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">AMSI Providers:</span><span class="sysinfo-value">$(if ($ForensicData.SystemInfo.AMSIProviders) { $ForensicData.SystemInfo.AMSIProviders.Count } else { 0 })</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Secure Boot:</span><span class="sysinfo-value" style="color: $(if ($ForensicData.SystemInfo.SecureBoot.Enabled) { '#2ecc71' } else { '#e74c3c' })">$($ForensicData.SystemInfo.SecureBoot.Status)</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">VBS Status:</span><span class="sysinfo-value" style="color: $(if ($ForensicData.SystemInfo.VBSStatus.VBSEnabled) { '#2ecc71' } else { '#e74c3c' })">$(if ($ForensicData.SystemInfo.VBSStatus.VBSEnabled) { 'Enabled' } else { 'Disabled' })</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">WDAC:</span><span class="sysinfo-value" style="color: $(if ($ForensicData.SystemInfo.WDACStatus.Enabled) { '#2ecc71' } else { '#e74c3c' })">$(if ($ForensicData.SystemInfo.WDACStatus.Enabled) { 'Enabled' } else { 'Not Configured' })</span></div>
                </div>
                <div class="sysinfo-card">
                    <h3>Event Log Max Size</h3>
                    <div class="sysinfo-item"><span class="sysinfo-label">Security:</span><span class="sysinfo-value">$(
                        try {
                            $secLog = Get-WinEvent -ListLog Security -ErrorAction SilentlyContinue
                            if ($secLog) { "$([math]::Round($secLog.MaximumSizeInBytes / 1MB, 2)) MB" } else { "Unknown" }
                        } catch { "Unknown" }
                    )</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">System:</span><span class="sysinfo-value">$(
                        try {
                            $sysLog = Get-WinEvent -ListLog System -ErrorAction SilentlyContinue
                            if ($sysLog) { "$([math]::Round($sysLog.MaximumSizeInBytes / 1MB, 2)) MB" } else { "Unknown" }
                        } catch { "Unknown" }
                    )</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Application:</span><span class="sysinfo-value">$(
                        try {
                            $appLog = Get-WinEvent -ListLog Application -ErrorAction SilentlyContinue
                            if ($appLog) { "$([math]::Round($appLog.MaximumSizeInBytes / 1MB, 2)) MB" } else { "Unknown" }
                        } catch { "Unknown" }
                    )</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">PowerShell:</span><span class="sysinfo-value">$(
                        try {
                            $psLog = Get-WinEvent -ListLog "Microsoft-Windows-PowerShell/Operational" -ErrorAction SilentlyContinue
                            if ($psLog) { "$([math]::Round($psLog.MaximumSizeInBytes / 1MB, 2)) MB" } else { "Unknown" }
                        } catch { "Unknown" }
                    )</span></div>
                </div>
                <div class="sysinfo-card">
                    <h3>Virtualization & Hardware</h3>
                    <div class="sysinfo-item"><span class="sysinfo-label">Virtual Machine:</span><span class="sysinfo-value" style="color: $(if ($ForensicData.SystemInfo.VMDetection.IsVirtualMachine) { '#f39c12' } else { '#2ecc71' })">$(if ($ForensicData.SystemInfo.VMDetection.IsVirtualMachine) { "Yes ($($ForensicData.SystemInfo.VMDetection.Type))" } else { 'No (Physical)' })</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Bitlocker:</span><span class="sysinfo-value">$(if ($ForensicData.SystemInfo.BitlockerStatus -and $ForensicData.SystemInfo.BitlockerStatus.Count -gt 0) { "$($ForensicData.SystemInfo.BitlockerStatus.Count) volume(s)" } else { 'Not Configured' })</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Minifilter Drivers:</span><span class="sysinfo-value">$(if ($ForensicData.SystemInfo.MinifilterDrivers) { $ForensicData.SystemInfo.MinifilterDrivers.Count } else { 0 })</span></div>
                </div>
                
                <div class="sysinfo-card">
                    <h3>Network & Internet</h3>
                    <div class="sysinfo-item"><span class="sysinfo-label">Internet Status:</span><span class="sysinfo-value" style="color: $(
                        if ($ForensicData.SystemInfo.InternetConnectivity.Status -eq 'Online') { '#2ecc71' } 
                        elseif ($ForensicData.SystemInfo.InternetConnectivity.Status -eq 'Limited') { '#f39c12' } 
                        else { '#e74c3c' }
                    )">$($ForensicData.SystemInfo.InternetConnectivity.Status)</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">DNS Resolution:</span><span class="sysinfo-value" style="color: $(if ($ForensicData.SystemInfo.InternetConnectivity.DNSWorking) { '#2ecc71' } else { '#e74c3c' })">$(if ($ForensicData.SystemInfo.InternetConnectivity.DNSWorking) { 'Working' } else { 'Failed' })</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">HTTP Connectivity:</span><span class="sysinfo-value" style="color: $(if ($ForensicData.SystemInfo.InternetConnectivity.HTTPWorking) { '#2ecc71' } else { '#e74c3c' })">$(if ($ForensicData.SystemInfo.InternetConnectivity.HTTPWorking) { 'Working' } else { 'Failed' })</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Primary DNS Server:</span><span class="sysinfo-value">$(if ($ForensicData.SystemInfo.PrimaryDNSServer) { $ForensicData.SystemInfo.PrimaryDNSServer } else { 'N/A' })</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Logon Server:</span><span class="sysinfo-value">$(if ($ForensicData.SystemInfo.LogonServer) { $ForensicData.SystemInfo.LogonServer } else { 'N/A' })</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">Domain Controller:</span><span class="sysinfo-value">$(if ($ForensicData.SystemInfo.DomainController -and $ForensicData.SystemInfo.DomainController.Name -ne 'N/A') { "$($ForensicData.SystemInfo.DomainController.Name) ($($ForensicData.SystemInfo.DomainController.IPAddress))" } else { 'N/A' })</span></div>
                    <div class="sysinfo-item"><span class="sysinfo-label">DNS Servers:</span><span class="sysinfo-value">$(
                        if ($ForensicData.SystemInfo.DNSServers) { 
                            $dnsAddresses = @()
                            foreach ($dnsServer in $ForensicData.SystemInfo.DNSServers) {
                                if ($dnsServer.ServerAddresses -and $dnsServer.ServerAddresses.Count -gt 0) {
                                    $dnsAddresses += $dnsServer.ServerAddresses
                                }
                            }
                            if ($dnsAddresses.Count -gt 0) {
                                $dnsLinks = ($dnsAddresses | Select-Object -First 3 -Unique) | ForEach-Object {
                                    "<a href='https://scamalytics.com/ip/$_' target='_blank' class='vt-link' title='Lookup on Scamalytics'>$_</a>"
                                }
                                $dnsLinks -join ', '
                            } else {
                                'N/A'
                            }
                        } else { 
                            'N/A' 
                        }
                    )</span></div>
                </div>
            </div>
        </div>
        
        <div id="export-tab" class="tab-content">
            <h2 style="color: #3498db; margin-bottom: 20px;">Export Information</h2>
            
            <div class="export-info-card">
                <h3>Collection Details</h3>
                <div class="export-info-item">
                    <span class="export-info-label">Report Generated:</span>
                    <span class="export-info-value">$reportDate</span>
                </div>
                <div class="export-info-item">
                    <span class="export-info-label">Collection Period:</span>
                    <span class="export-info-value">$StartDate to $EndDate</span>
                </div>
                <div class="export-info-item">
                    <span class="export-info-label">Collection Mode:</span>
                    <span class="export-info-value">$Mode</span>
                </div>
                <div class="export-info-item">
                    <span class="export-info-label">Total Runtime:</span>
                    <span class="export-info-value" id="runtime-display">Calculating...</span>
                </div>
                <div class="export-info-item">
                    <span class="export-info-label">PowerShell Version:</span>
                    <span class="export-info-value">$($PSVersionTable.PSVersion)</span>
                </div>
            </div>
            
            <div class="export-info-card">
                <h3>Output Locations</h3>
                <div class="export-info-item">
                    <span class="export-info-label">Output Folder:</span>
                    <span class="export-info-value"><a href="file:///$($OutputDir.Replace('\', '/'))" class="export-link" title="Open folder in Explorer">$OutputDir</a></span>
                </div>
                <div class="export-info-item">
                    <span class="export-info-label">HTML Report:</span>
                    <span class="export-info-value"><a href="file:///$($OutputDir.Replace('\', '/'))/ForensicReport.html" class="export-link" title="Open HTML report">$(Join-Path $OutputDir 'ForensicReport.html')</a></span>
                </div>
                <div class="export-info-item">
                    <span class="export-info-label">CSV Data Folder:</span>
                    <span class="export-info-value"><a href="file:///$($OutputDir.Replace('\', '/'))/ForensicData_CSV/" class="export-link" title="Open CSV folder">$(Join-Path $OutputDir 'ForensicData_CSV')</a></span>
                </div>
            </div>
            
            <div class="export-info-card">
                <h3>Data Collection Summary</h3>
                <div class="export-info-item">
                    <span class="export-info-label">Persistence Items:</span>
                    <span class="export-info-value">$($stats.Persistence) records</span>
                </div>
                <div class="export-info-item">
                    <span class="export-info-label">Files Analyzed:</span>
                    <span class="export-info-value">$($stats.Files) files</span>
                </div>
                <div class="export-info-item">
                    <span class="export-info-label">Registry Entries:</span>
                    <span class="export-info-value">$($stats.Registry) entries</span>
                </div>
                <div class="export-info-item">
                    <span class="export-info-label">Browser History:</span>
                    <span class="export-info-value">$($stats.Browser) records</span>
                </div>
                <div class="export-info-item">
                    <span class="export-info-label">Event Logs:</span>
                    <span class="export-info-value">$($stats.Logs) events</span>
                </div>
                <div class="export-info-item">
                    <span class="export-info-label">Services:</span>
                    <span class="export-info-value">$($stats.Services) services</span>
                </div>
                <div class="export-info-item">
                    <span class="export-info-label">Scheduled Tasks:</span>
                    <span class="export-info-value">$($stats.Tasks) tasks</span>
                </div>
            </div>
        </div>
        
        <div id="sysinfo-tab" class="tab-content">
            <h2 style="color: #3498db; margin-bottom: 20px;">System Information</h2>
            
            <div class="section-card">
                <h3>PowerShell Command History</h3>
                $psHistoryHtml
            </div>
            
            <div class="section-card">
                <h3>Running Processes ($($ForensicData.SystemInfo.Processes.Count) total)</h3>
                $processHtml
            </div>
            
            <div class="section-card">
                <h3>DNS Client Cache ($($ForensicData.SystemInfo.DNSCache.Count) entries)</h3>
                $dnsHtml
            </div>
            
            <div class="section-card">
                <h3>Active Network Connections ($($ForensicData.SystemInfo.NetworkConnections.Count) connections)</h3>
                $networkHtml
            </div>
            
            <div class="section-card">
                <h3>Volume Shadow Copies</h3>
                <div style="background: #1a1a1a; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <div>
                            <span style="color: #95a5a6;">VSS Service Status:</span>
                            <span style="color: $vssStatusColor; font-weight: bold; margin-left: 10px;">$($ForensicData.SystemInfo.VSSServiceStatus)</span>
                        </div>
                        <div>
                            <span style="color: #95a5a6;">Shadow Copy Count:</span>
                            <span style="color: $shadowCountColor; font-weight: bold; margin-left: 10px;">$($ForensicData.SystemInfo.ShadowCopyCount)</span>
                        </div>
                    </div>
                </div>
                $shadowHtml
            </div>
                     
            <div class="section-card">
                <h3>Network Adapters ($($ForensicData.SystemInfo.NetworkAdapters.Count) adapters)</h3>
                $adaptersHtml
            </div>
            <div class="section-card">
                <h3>User Accounts ($($ForensicData.SystemInfo.AllUserAccounts.Count) accounts)</h3>
                <div class="table-wrapper">
                    <table id="users-accounts-table">
                        <thead>
                            <tr>
                                <th onclick="sortSystemTable('users-accounts-table', 0)" style="position: relative;">Username<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('users-accounts-table', 1)" style="position: relative;">Type<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('users-accounts-table', 2)" style="position: relative;">Created<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('users-accounts-table', 3)" style="position: relative;">Last Logon<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('users-accounts-table', 4)" style="position: relative;">Enabled<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('users-accounts-table', 5)" style="position: relative;">Profile Path<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('users-accounts-table', 6)" style="position: relative;">Description<div class="resizer"></div></th>
                            </tr>
                        </thead>
                        <tbody>
$(
    if ($ForensicData.SystemInfo.AllUserAccounts -and $ForensicData.SystemInfo.AllUserAccounts.Count -gt 0) {
        $userHtml = ""
        foreach ($user in $ForensicData.SystemInfo.AllUserAccounts) {
            $username = [System.Web.HttpUtility]::HtmlEncode($user.Username)
            $created = if ($user.Created) { $user.Created.ToString("yyyy-MM-dd HH:mm:ss") } else { "Unknown" }
            $lastLogon = if ($user.LastLogon) { $user.LastLogon.ToString("yyyy-MM-dd HH:mm:ss") } else { "Never" }
            $enabled = if ($null -ne $user.Enabled) { $user.Enabled.ToString() } else { "N/A" }
            $profilePath = if ($user.ProfilePath) { [System.Web.HttpUtility]::HtmlEncode($user.ProfilePath) } else { "N/A" }
            $desc = if ($user.Description) { [System.Web.HttpUtility]::HtmlEncode($user.Description) } else { "" }
            $userHtml += "                            <tr><td>$username</td><td>$($user.Type)</td><td>$created</td><td>$lastLogon</td><td>$enabled</td><td style='font-size: 0.8em;'>$profilePath</td><td>$desc</td></tr>`n"
        }
        $userHtml
    } else {
        "                            <tr><td colspan='7' style='text-align: center; color: #95a5a6;'>No user account data available</td></tr>"
    }
)
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="section-card">
                <h3>Currently Logged In Users ($(if ($ForensicData.SystemInfo.CurrentlyLoggedIn) { $ForensicData.SystemInfo.CurrentlyLoggedIn.Count } else { 0 }) sessions)</h3>
                <div class="table-wrapper">
                    <table id="loggedin-table">
                        <thead>
                            <tr>
                                <th onclick="sortSystemTable('loggedin-table', 0)" style="position: relative;">Username<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('loggedin-table', 1)" style="position: relative;">Session Name<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('loggedin-table', 2)" style="position: relative;">Session ID<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('loggedin-table', 3)" style="position: relative;">State<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('loggedin-table', 4)" style="position: relative;">Idle Time<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('loggedin-table', 5)" style="position: relative;">Logon Time<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('loggedin-table', 6)" style="position: relative;">Source<div class="resizer"></div></th>
                            </tr>
                        </thead>
                        <tbody>
$(
    if ($ForensicData.SystemInfo.CurrentlyLoggedIn -and $ForensicData.SystemInfo.CurrentlyLoggedIn.Count -gt 0) {
        $loggedHtml = ""
        foreach ($loggedUser in $ForensicData.SystemInfo.CurrentlyLoggedIn) {
            $username = [System.Web.HttpUtility]::HtmlEncode($loggedUser.Username)
            $sessionName = [System.Web.HttpUtility]::HtmlEncode($loggedUser.SessionName)
            $logonTime = if ($loggedUser.PSObject.Properties['LogonTime']) { $loggedUser.LogonTime } else { "Unknown" }
            $source = if ($loggedUser.PSObject.Properties['Source']) { $loggedUser.Source } else { "Unknown" }
            $loggedHtml += "                            <tr><td>$username</td><td>$sessionName</td><td>$($loggedUser.ID)</td><td>$($loggedUser.State)</td><td>$($loggedUser.IdleTime)</td><td>$logonTime</td><td>$source</td></tr>`n"
        }
        $loggedHtml
    } else {
        "                            <tr><td colspan='7' style='text-align: center; color: #95a5a6;'>No users currently logged in (or detection failed)</td></tr>"
    }
)
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="section-card">
                <h3>Run MRU (Recent Run Commands)</h3>
$(
    if ($ForensicData.SystemInfo.RunMRU -and $ForensicData.SystemInfo.RunMRU.Count -gt 0) {
        $runMRUHtml = @"
                <div class="table-wrapper">
                    <table id="runmru-table">
                        <thead>
                            <tr>
                                <th onclick="sortSystemTable('runmru-table', 0)" style="position: relative; width: 80px;">Order<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('runmru-table', 1)" style="position: relative; width: 80px;">Key<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('runmru-table', 2)" style="position: relative;">Command<div class="resizer"></div></th>
                            </tr>
                        </thead>
                        <tbody>
"@
        foreach ($item in $ForensicData.SystemInfo.RunMRU) {
            $order = $item.Order
            $key = [System.Web.HttpUtility]::HtmlEncode($item.Key)
            $command = [System.Web.HttpUtility]::HtmlEncode($item.Command)
            $runMRUHtml += "                            <tr><td>$order</td><td>$key</td><td style='font-family: Consolas, monospace;'>$command</td></tr>`n"
        }
        $runMRUHtml += @"
                        </tbody>
                    </table>
                </div>
"@
        $runMRUHtml
    } else {
        "                <p style='color: #95a5a6;'>No Run MRU entries found.</p>"
    }
)
            </div>          
            <div class="section-card">
                <h3>AMSI Providers ($($ForensicData.SystemInfo.AMSIProviders.Count) providers)</h3>
                <div class="table-wrapper">
                    <table id="amsi-table">
                        <thead>
                            <tr>
                                <th onclick="sortSystemTable('amsi-table', 0)" style="position: relative;">Provider Name<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('amsi-table', 1)" style="position: relative;">DLL Path<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('amsi-table', 2)" style="position: relative;">Exists<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('amsi-table', 3)" style="position: relative;">Size (KB)<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('amsi-table', 4)" style="position: relative;">MD5<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('amsi-table', 5)" style="position: relative;">GUID<div class="resizer"></div></th>
                            </tr>
                        </thead>
                        <tbody>
$(
    if ($ForensicData.SystemInfo.AMSIProviders -and $ForensicData.SystemInfo.AMSIProviders.Count -gt 0) {
        $amsiHtml = ""
        foreach ($provider in $ForensicData.SystemInfo.AMSIProviders) {
            $name = [System.Web.HttpUtility]::HtmlEncode($provider.Name)
            $dllPath = if ($provider.DLLPath) { [System.Web.HttpUtility]::HtmlEncode($provider.DLLPath) } else { "N/A" }
            $dllExists = if ($provider.DLLExists) { "<span style='color: #2ecc71;'>Yes</span>" } else { "<span style='color: #e74c3c;'>No</span>" }
            $dllSize = if ($provider.DLLSizeKB -and $provider.DLLSizeKB -gt 0) { $provider.DLLSizeKB } else { "N/A" }
            $dllMD5 = if ($provider.DLLMd5) { [System.Web.HttpUtility]::HtmlEncode($provider.DLLMd5) } else { "N/A" }
            $dllMD5Link = if ($dllMD5 -ne "N/A" -and $dllMD5 -ne "Error") { "<a href='https://www.virustotal.com/gui/file/$dllMD5' target='_blank' class='vt-link' title='Lookup on VirusTotal'>$dllMD5</a>" } else { $dllMD5 }
            $guid = [System.Web.HttpUtility]::HtmlEncode($provider.GUID)
            $amsiHtml += "                            <tr><td><strong>$name</strong></td><td style='font-family: Consolas, monospace; max-width: 400px; overflow: hidden; text-overflow: ellipsis;' title='$dllPath'>$dllPath</td><td style='text-align: center;'>$dllExists</td><td style='text-align: center;'>$dllSize</td><td style='font-family: Consolas, monospace;'>$dllMD5Link</td><td style='font-family: Consolas, monospace;'>$guid</td></tr>`n"
        }
        $amsiHtml
    } else {
        "                            <tr><td colspan='6' style='text-align: center; color: #95a5a6;'>No AMSI providers detected</td></tr>"
    }
)
                        </tbody>
                    </table>
                </div>

                </div>
            
            <div class="section-card">
                <h3>AntiVirus Providers</h3>
                
                <h4 style="color: var(--accent-blue); margin-top: 20px; margin-bottom: 10px;">Registered AntiVirus Products ($(if ($ForensicData.SystemInfo.AntiVirusInfo.SecurityCenter) { $ForensicData.SystemInfo.AntiVirusInfo.SecurityCenter.Count } else { 0 }))</h4>
                <div class="table-wrapper">
                    <table id="av-products-table">
                        <thead>
                            <tr>
                                <th onclick="sortSystemTable('av-products-table', 0)" style="position: relative;">Product Name<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('av-products-table', 1)" style="position: relative;">Enabled<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('av-products-table', 2)" style="position: relative;">Up-to-Date<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('av-products-table', 3)" style="position: relative;">Product Executable<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('av-products-table', 4)" style="position: relative;">Last Updated<div class="resizer"></div></th>
                            </tr>
                        </thead>
                        <tbody>
$(
    if ($ForensicData.SystemInfo.AntiVirusInfo.SecurityCenter -and $ForensicData.SystemInfo.AntiVirusInfo.SecurityCenter.Count -gt 0) {
        $avHtml = ""
        foreach ($av in $ForensicData.SystemInfo.AntiVirusInfo.SecurityCenter) {
            $name = [System.Web.HttpUtility]::HtmlEncode($av.DisplayName)
            $enabled = if ($av.Enabled) { "<span style='color: #2ecc71; font-weight: bold;'>Yes</span>" } else { "<span style='color: #e74c3c; font-weight: bold;'>No</span>" }
            $upToDate = if ($av.UpToDate) { "<span style='color: #2ecc71; font-weight: bold;'>Yes</span>" } else { "<span style='color: #f39c12; font-weight: bold;'>Out of Date</span>" }
            $exe = if ($av.PathToSignedProductExe) { [System.Web.HttpUtility]::HtmlEncode($av.PathToSignedProductExe) } else { "N/A" }
            $timestamp = if ($av.Timestamp) { $av.Timestamp } else { "Unknown" }
            $avHtml += "                            <tr><td><strong>$name</strong></td><td style='text-align: center;'>$enabled</td><td style='text-align: center;'>$upToDate</td><td style='font-family: Consolas, monospace; font-size: 0.8em;'>$exe</td><td>$timestamp</td></tr>`n"
        }
        $avHtml
    } else {
        "                            <tr><td colspan='5' style='text-align: center; color: #95a5a6;'>No antivirus products registered in Security Center</td></tr>"
    }
)
                        </tbody>
                    </table>
                </div>
                
                <h4 style="color: var(--accent-blue); margin-top: 20px; margin-bottom: 10px;">Windows Defender Status</h4>
$(
    if ($ForensicData.SystemInfo.AntiVirusInfo.DefenderStatus) {
        $def = $ForensicData.SystemInfo.AntiVirusInfo.DefenderStatus
        $defHtml = @"
                <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                        <div>
                            <span style="color: var(--text-muted);">Real-Time Protection:</span>
                            <span style="color: $(if ($def.RealTimeProtectionEnabled) { '#2ecc71' } else { '#e74c3c' }); font-weight: bold; margin-left: 10px;">$(if ($def.RealTimeProtectionEnabled) { 'Enabled' } else { 'Disabled' })</span>
                        </div>
                        <div>
                            <span style="color: var(--text-muted);">Behavior Monitor:</span>
                            <span style="color: $(if ($def.BehaviorMonitorEnabled) { '#2ecc71' } else { '#e74c3c' }); font-weight: bold; margin-left: 10px;">$(if ($def.BehaviorMonitorEnabled) { 'Enabled' } else { 'Disabled' })</span>
                        </div>
                        <div>
                            <span style="color: var(--text-muted);">Product Version:</span>
                            <span style="color: var(--text-primary); margin-left: 10px;">$($def.AMProductVersion)</span>
                        </div>
                        <div>
                            <span style="color: var(--text-muted);">Signature Updated:</span>
                            <span style="color: var(--text-primary); margin-left: 10px;">$(if ($def.AntivirusSignatureLastUpdated) { $def.AntivirusSignatureLastUpdated.ToString('yyyy-MM-dd HH:mm') } else { 'Unknown' })</span>
                        </div>
                        <div>
                            <span style="color: var(--text-muted);">Last Full Scan:</span>
                            <span style="color: var(--text-primary); margin-left: 10px;">$(if ($def.FullScanAge -and $def.FullScanAge -ne 4294967295) { "$($def.FullScanAge) days ago" } else { 'Never' })</span>
                        </div>
                        <div>
                            <span style="color: var(--text-muted);">Last Quick Scan:</span>
                            <span style="color: var(--text-primary); margin-left: 10px;">$(if ($def.QuickScanAge -and $def.QuickScanAge -ne 4294967295) { "$($def.QuickScanAge) days ago" } else { 'Never' })</span>
                        </div>
                    </div>
                </div>
"@
        $defHtml
    } else {
        "                <p style='color: #95a5a6;'>Windows Defender status unavailable</p>"
    }
)
            </div>
            <div class="section-card">
                <h3>Minifilter Drivers ($($ForensicData.SystemInfo.MinifilterDrivers.Count) drivers)</h3>
                <div class="table-wrapper">
                    <table id="minifilter-table">
                        <thead>
                            <tr>
                                <th onclick="sortSystemTable('minifilter-table', 0)" style="position: relative;">Filter Name<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('minifilter-table', 1)" style="position: relative;">Instances<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('minifilter-table', 2)" style="position: relative;">Altitude<div class="resizer"></div></th>
                            </tr>
                        </thead>
                        <tbody>
$(
    if ($ForensicData.SystemInfo.MinifilterDrivers -and $ForensicData.SystemInfo.MinifilterDrivers.Count -gt 0) {
        $minifilterHtml = ""
        foreach ($driver in $ForensicData.SystemInfo.MinifilterDrivers) {
            $name = [System.Web.HttpUtility]::HtmlEncode($driver.FilterName)
            $minifilterHtml += "                            <tr><td>$name</td><td>$($driver.Instances)</td><td>$($driver.Altitude)</td></tr>`n"
        }
        $minifilterHtml
    } else {
        "                            <tr><td colspan='3' style='text-align: center; color: #95a5a6;'>No minifilter drivers detected</td></tr>"
    }
)
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="section-card">
                <h3>Installed Software ($($ForensicData.SystemInfo.InstalledSoftware.Count) programs)</h3>
                <div class="table-controls">
                    <input type="text" id="software-search" placeholder="Search software..." onkeyup="filterSystemTable('software-table')">
                </div>
                <div class="table-wrapper">
                    <table id="software-table">
                        <thead>
                            <tr>
                                <th onclick="sortSystemTable('software-table', 0)" style="position: relative;">Name<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('software-table', 1)" style="position: relative;">Version<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('software-table', 2)" style="position: relative;">Publisher<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('software-table', 3)" style="position: relative;">Install Date<div class="resizer"></div></th>
                            </tr>
                        </thead>
                        <tbody>
$(
    if ($ForensicData.SystemInfo.InstalledSoftware -and $ForensicData.SystemInfo.InstalledSoftware.Count -gt 0) {
        $softwareHtml = ""
        foreach ($software in $ForensicData.SystemInfo.InstalledSoftware) {
            $name = [System.Web.HttpUtility]::HtmlEncode($software.DisplayName)
            $version = if ($software.DisplayVersion) { [System.Web.HttpUtility]::HtmlEncode($software.DisplayVersion) } else { "N/A" }
            $publisher = if ($software.Publisher) { [System.Web.HttpUtility]::HtmlEncode($software.Publisher) } else { "N/A" }
            $installDate = if ($software.InstallDate) { $software.InstallDate } else { "Unknown" }
            $softwareHtml += "                            <tr><td>$name</td><td>$version</td><td>$publisher</td><td>$installDate</td></tr>`n"
        }
        $softwareHtml
    } else {
        "                            <tr><td colspan='4' style='text-align: center; color: #95a5a6;'>No installed software found</td></tr>"
    }
)
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="section-card">
                <h3>Filesystem & Storage</h3>
                
                <h4 style="color: var(--accent-blue); margin-top: 20px; margin-bottom: 10px;">Local Fixed Drives ($(if ($ForensicData.SystemInfo.FilesystemInfo.LogicalDrives) { $ForensicData.SystemInfo.FilesystemInfo.LogicalDrives.Count } else { 0 }))</h4>
                <div class="table-wrapper">
                    <table id="drives-table">
                        <thead>
                            <tr>
                                <th onclick="sortSystemTable('drives-table', 0)" style="position: relative;">Drive<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('drives-table', 1)" style="position: relative;">Label<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('drives-table', 2)" style="position: relative;">File System<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('drives-table', 3)" style="position: relative;">Total Size (GB)<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('drives-table', 4)" style="position: relative;">Used (GB)<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('drives-table', 5)" style="position: relative;">Free (GB)<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('drives-table', 6)" style="position: relative;">% Free<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('drives-table', 7)" style="position: relative;">BitLocker<div class="resizer"></div></th>
                            </tr>
                        </thead>
                        <tbody>
$(
    if ($ForensicData.SystemInfo.FilesystemInfo.LogicalDrives -and $ForensicData.SystemInfo.FilesystemInfo.LogicalDrives.Count -gt 0) {
        $drivesHtml = ""
        foreach ($drive in $ForensicData.SystemInfo.FilesystemInfo.LogicalDrives) {
            $label = [System.Web.HttpUtility]::HtmlEncode($drive.Label)
            $percentColor = if ($drive.PercentFree -lt 10) { '#e74c3c' } elseif ($drive.PercentFree -lt 20) { '#f39c12' } else { '#2ecc71' }
            
            # Get BitLocker status for this drive
            $bitlockerInfo = "Not Encrypted"
            $bitlockerColor = "#95a5a6"
            if ($ForensicData.SystemInfo.BitlockerStatus) {
                $blVolume = $ForensicData.SystemInfo.BitlockerStatus | Where-Object { $_.MountPoint -eq "$($drive.DriveLetter):" }
                if ($blVolume) {
                    if ($blVolume.ProtectionStatus -eq 'On') {
                        $bitlockerInfo = "Protected ($($blVolume.EncryptionPercentage)%)"
                        $bitlockerColor = "#2ecc71"
                    } elseif ($blVolume.ProtectionStatus -eq 'Off') {
                        $bitlockerInfo = "Encrypted but Suspended"
                        $bitlockerColor = "#f39c12"
                    } else {
                        $bitlockerInfo = "Status: $($blVolume.VolumeStatus)"
                        $bitlockerColor = "#f39c12"
                    }
                }
            }
            
            $drivesHtml += "                            <tr><td><strong>$($drive.DriveLetter):\</strong></td><td>$label</td><td>$($drive.FileSystem)</td><td>$($drive.TotalSizeGB)</td><td>$($drive.UsedSpaceGB)</td><td>$($drive.FreeSpaceGB)</td><td style='color: $percentColor; font-weight: bold;'>$($drive.PercentFree)%</td><td style='color: $bitlockerColor; font-weight: bold;'>$bitlockerInfo</td></tr>`n"
        }
        $drivesHtml
    } else {
        "                            <tr><td colspan='8' style='text-align: center; color: #95a5a6;'>No local drives found</td></tr>"
    }
)
                        </tbody>
                    </table>
                </div>
                
                <h4 style="color: var(--accent-blue); margin-top: 20px; margin-bottom: 10px;">Removable/USB Drives ($(if ($ForensicData.SystemInfo.FilesystemInfo.USBDrives) { $ForensicData.SystemInfo.FilesystemInfo.USBDrives.Count } else { 0 }))</h4>
$(
    if ($ForensicData.SystemInfo.FilesystemInfo.USBDrives -and $ForensicData.SystemInfo.FilesystemInfo.USBDrives.Count -gt 0) {
        $usbHtml = @"
                <div class="table-wrapper">
                    <table id="usb-table">
                        <thead>
                            <tr>
                                <th onclick="sortSystemTable('usb-table', 0)" style="position: relative;">Drive<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('usb-table', 1)" style="position: relative;">Label<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('usb-table', 2)" style="position: relative;">File System<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('usb-table', 3)" style="position: relative;">Total Size (GB)<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('usb-table', 4)" style="position: relative;">Free (GB)<div class="resizer"></div></th>
                            </tr>
                        </thead>
                        <tbody>
"@
        foreach ($usb in $ForensicData.SystemInfo.FilesystemInfo.USBDrives) {
            $label = [System.Web.HttpUtility]::HtmlEncode($usb.Label)
            $usbHtml += "                            <tr><td><strong>$($usb.DriveLetter):\</strong></td><td>$label</td><td>$($usb.FileSystem)</td><td>$($usb.TotalSizeGB)</td><td>$($usb.FreeSpaceGB)</td></tr>`n"
        }
        $usbHtml += @"
                        </tbody>
                    </table>
                </div>
"@
        $usbHtml
    } else {
        "                <p style='color: #95a5a6;'>No removable drives currently connected</p>"
    }
)
                
                <h4 style="color: var(--accent-blue); margin-top: 20px; margin-bottom: 10px;">Network Mapped Drives ($(if ($ForensicData.SystemInfo.FilesystemInfo.NetworkDrives) { $ForensicData.SystemInfo.FilesystemInfo.NetworkDrives.Count } else { 0 }))</h4>
$(
    if ($ForensicData.SystemInfo.FilesystemInfo.NetworkDrives -and $ForensicData.SystemInfo.FilesystemInfo.NetworkDrives.Count -gt 0) {
        $netHtml = @"
                <div class="table-wrapper">
                    <table id="network-drives-table">
                        <thead>
                            <tr>
                                <th onclick="sortSystemTable('network-drives-table', 0)" style="position: relative;">Drive<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('network-drives-table', 1)" style="position: relative;">Network Path<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('network-drives-table', 2)" style="position: relative;">Label<div class="resizer"></div></th>
                            </tr>
                        </thead>
                        <tbody>
"@
        foreach ($net in $ForensicData.SystemInfo.FilesystemInfo.NetworkDrives) {
            $label = [System.Web.HttpUtility]::HtmlEncode($net.Label)
            $path = if ($net.ProviderName) { [System.Web.HttpUtility]::HtmlEncode($net.ProviderName) } else { "Unknown" }
            $netHtml += "                            <tr><td><strong>$($net.DriveLetter):\</strong></td><td style='font-family: Consolas, monospace; font-size: 0.85em;'>$path</td><td>$label</td></tr>`n"
        }
        $netHtml += @"
                        </tbody>
                    </table>
                </div>
"@
        $netHtml
    } else {
        "                <p style='color: #95a5a6;'>No network drives mapped</p>"
    }
)
                
                <h4 style="color: var(--accent-blue); margin-top: 20px; margin-bottom: 10px;">Network Shares ($(if ($ForensicData.SystemInfo.FilesystemInfo.NetworkShares) { $ForensicData.SystemInfo.FilesystemInfo.NetworkShares.Count } else { 0 }))</h4>
$(
    if ($ForensicData.SystemInfo.FilesystemInfo.NetworkShares -and $ForensicData.SystemInfo.FilesystemInfo.NetworkShares.Count -gt 0) {
        $shareHtml = @"
                <div class="table-wrapper">
                    <table id="shares-table">
                        <thead>
                            <tr>
                                <th onclick="sortSystemTable('shares-table', 0)" style="position: relative;">Share Name<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('shares-table', 1)" style="position: relative;">Local Path<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('shares-table', 2)" style="position: relative;">Type<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('shares-table', 3)" style="position: relative;">Description<div class="resizer"></div></th>
                            </tr>
                        </thead>
                        <tbody>
"@
        foreach ($share in $ForensicData.SystemInfo.FilesystemInfo.NetworkShares) {
            $name = [System.Web.HttpUtility]::HtmlEncode($share.ShareName)
            $path = [System.Web.HttpUtility]::HtmlEncode($share.Path)
            $desc = if ($share.Description) { [System.Web.HttpUtility]::HtmlEncode($share.Description) } else { "" }
            $shareHtml += "                            <tr><td><strong>$name</strong></td><td style='font-family: Consolas, monospace; font-size: 0.85em;'>$path</td><td>$($share.ShareType)</td><td>$desc</td></tr>`n"
        }
        $shareHtml += @"
                        </tbody>
                    </table>
                </div>
"@
        $shareHtml
    } else {
        "                <p style='color: #95a5a6;'>No network shares configured</p>"
    }
)
                
                <h4 style="color: var(--accent-blue); margin-top: 20px; margin-bottom: 10px;">Optical Drives ($(if ($ForensicData.SystemInfo.FilesystemInfo.OpticalDrives) { $ForensicData.SystemInfo.FilesystemInfo.OpticalDrives.Count } else { 0 }))</h4>
$(
    if ($ForensicData.SystemInfo.FilesystemInfo.OpticalDrives -and $ForensicData.SystemInfo.FilesystemInfo.OpticalDrives.Count -gt 0) {
        $optHtml = @"
                <div class="table-wrapper">
                    <table id="optical-table">
                        <thead>
                            <tr>
                                <th onclick="sortSystemTable('optical-table', 0)" style="position: relative;">Drive<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('optical-table', 1)" style="position: relative;">Label<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('optical-table', 2)" style="position: relative;">Status<div class="resizer"></div></th>
                            </tr>
                        </thead>
                        <tbody>
"@
        foreach ($opt in $ForensicData.SystemInfo.FilesystemInfo.OpticalDrives) {
            $label = if ($opt.Label -and $opt.Label -ne "(No label)") { [System.Web.HttpUtility]::HtmlEncode($opt.Label) } else { "No disc" }
            $status = if ($opt.TotalSizeGB -gt 0) { "Media present" } else { "Empty" }
            $optHtml += "                            <tr><td><strong>$($opt.DriveLetter):\</strong></td><td>$label</td><td>$status</td></tr>`n"
        }
        $optHtml += @"
                        </tbody>
                    </table>
                </div>
"@
        $optHtml
    } else {
        "                <p style='color: #95a5a6;'>No optical drives detected</p>"
    }
)
            </div>
            
        </div>
        </div>
        <div id="persistence-tab" class="tab-content">
            <h2 style="color: #3498db; margin-bottom: 15px;">Persistence Mechanisms</h2>
            <p style="color: var(--text-muted); margin-bottom: 20px;">A list of all autoruns and persistence mechanisms.</p>
            <div id="persistence-content"></div>
        </div>

        <div id="registry-tab" class="tab-content">
            <h2 style="color: #3498db; margin-bottom: 15px;">Registry Analysis</h2>
            <p style="color: var(--text-muted); margin-bottom: 20px;">A small list of commonly abused registry paths.</p>
            <div id="registry-content">
                </div>
            </div>
        </div>

        <div id="logs-tab" class="tab-content">
            <h2 style="color: #3498db; margin-bottom: 15px;">Event Logs</h2>
            <p style="color: var(--text-muted); margin-bottom: 20px;">A collection of Windows Event Logs (EVTX) matching the report's time range.</p>
            <div class="log-provider-selector">
                <label for="log-provider-select">Filter by Log Provider:</label>
                <select id="log-provider-select" onchange="changeLogProvider()">
                </select>
            </div>
            <div id="logs-content">
            </div>
        </div>

        <div id="browser-tab" class="tab-content">
            <h2 style="color: #3498db; margin-bottom: 15px;">Browser History & Extensions</h2>
            <p style="color: var(--text-muted); margin-bottom: 20px;">Browser history and browser extensions found on this machine.</p>
            <div id="browser-content">
            </div>
            
            <div class="section-card" style="margin-top: 20px;">
                <h3>Browser Extensions ($($ForensicData.SystemInfo.BrowserExtensions.Count) extensions)</h3>
                <p style="color: var(--text-muted); margin-bottom: 15px;">Installed browser extensions across all users and browsers on this system.</p>
                <div class="table-controls">
                    <input type="text" id="extensions-search" placeholder="Search extensions..." onkeyup="filterSystemTable('extensions-table')">
                </div>
                <div class="table-wrapper">
                    <table id="extensions-table">
                        <thead>
                            <tr>
                                <th onclick="sortSystemTable('extensions-table', 0)" style="position: relative;">User<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('extensions-table', 1)" style="position: relative;">Browser<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('extensions-table', 2)" style="position: relative;">Profile<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('extensions-table', 3)" style="position: relative;">Name<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('extensions-table', 4)" style="position: relative;">Version<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('extensions-table', 5)" style="position: relative;">Extension ID<div class="resizer"></div></th>
                                <th onclick="sortSystemTable('extensions-table', 6)" style="position: relative;">Description<div class="resizer"></div></th>
                            </tr>
                        </thead>
                        <tbody>
$(
    if ($ForensicData.SystemInfo.BrowserExtensions -and $ForensicData.SystemInfo.BrowserExtensions.Count -gt 0) {
        # Sort by Name column before displaying
        $sortedExtensions = $ForensicData.SystemInfo.BrowserExtensions | Sort-Object -Property Name
        $extHtml = ""
        foreach ($ext in $sortedExtensions | Select-Object -First 200) {
            $user = [System.Web.HttpUtility]::HtmlEncode($ext.User)
            $browser = [System.Web.HttpUtility]::HtmlEncode($ext.Browser)
            $profile = [System.Web.HttpUtility]::HtmlEncode($ext.Profile)
            $name = [System.Web.HttpUtility]::HtmlEncode($ext.Name)
            $version = [System.Web.HttpUtility]::HtmlEncode($ext.Version)
            $extId = [System.Web.HttpUtility]::HtmlEncode($ext.ID)
            $desc = if ($ext.Description) { [System.Web.HttpUtility]::HtmlEncode($ext.Description) } else { "" }
            $extHtml += "                            <tr><td>$user</td><td>$browser</td><td style='font-size: 0.85em;'>$profile</td><td><strong>$name</strong></td><td style='text-align: center;'>$version</td><td style='font-family: Consolas, monospace; font-size: 0.75em; max-width: 200px; overflow: hidden; text-overflow: ellipsis;' title='$extId'>$extId</td><td style='font-size: 0.85em; max-width: 300px; overflow: hidden; text-overflow: ellipsis;' title='$desc'>$desc</td></tr>`n"
        }
        $extHtml
    } else {
        "                            <tr><td colspan='7' style='text-align: center; color: #95a5a6;'>No browser extensions found</td></tr>"
    }
)
                        </tbody>
                    </table>
                </div>
                $(if ($ForensicData.SystemInfo.BrowserExtensions -and $ForensicData.SystemInfo.BrowserExtensions.Count -gt 200) {
                    "<p style='color: #f39c12; margin-top: 10px;'>Showing first 200 of $($ForensicData.SystemInfo.BrowserExtensions.Count) extensions. See CSV for complete data.</p>"
                })
            </div>
            <script>
                // Mark extensions table as pre-sorted by Name (column 3)
                if (typeof systemSortState === 'undefined') { systemSortState = {}; }
                systemSortState['extensions-table-3'] = 'asc';
            </script>
        </div>

        <div id="services-tab" class="tab-content">
            <h2 style="color: #3498db; margin-bottom: 15px;">Windows Services</h2>
            <p style="color: var(--text-muted); margin-bottom: 20px;">All Windows Services found on the machine.</p>
            <div id="services-content">
            </div>
        </div>
        
        <div id="tasks-tab" class="tab-content">
            <h2 style="color: #3498db; margin-bottom: 15px;">Scheduled Tasks</h2>
            <p style="color: var(--text-muted); margin-bottom: 20px;">All Scheduled Tasks found on the machine.</p>
            <div id="tasks-content">
            </div>
        </div>
        
        <div id="files-tab" class="tab-content">
            <h2 style="color: #3498db; margin-bottom: 15px;">File System Analysis</h2>
            <p style="color: var(--text-muted); margin-bottom: 20px;">Recently accessed, modified, or created files and folders.</p>
            <div id="files-content"></div>
        </div>
        
        <div id="search-tab" class="tab-content">
            <div class="csv-section">
                <h2 style="color: #3498db; margin-bottom: 15px;">Search</h2>
                <p style="margin-bottom: 20px; color: #bdc3c7;">Search across all forensic data.</p>
                
                <div style="background: var(--bg-secondary); padding: 25px; border-radius: 8px; border: 1px solid var(--border-color);">
                    <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                        <input type="text" id="global-search-input" placeholder="Enter search string (minimum 3 characters)..." 
                            style="flex: 1; padding: 12px; background: var(--input-bg); border: 2px solid var(--input-border); color: var(--text-primary); border-radius: 4px; font-size: 16px;"
                            onkeypress="if(event.key === 'Enter') performGlobalSearch()">
                        <button onclick="performGlobalSearch()" 
                            style="padding: 12px 30px; background: var(--accent-blue); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; font-weight: bold;"
                            onmouseover="this.style.background='var(--accent-blue-hover)'"
                            onmouseout="this.style.background='var(--accent-blue)'">
                            Search
                        </button>
                        <button onclick="clearGlobalSearch()" 
                            style="padding: 12px 30px; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer; font-size: 16px;"
                            onmouseover="this.style.background='var(--hover-bg)'"
                            onmouseout="this.style.background='var(--bg-tertiary)'">
                            Clear
                        </button>
                    </div>
                    
                    <div style="display: flex; gap: 15px; align-items: center; margin-bottom: 15px; flex-wrap: wrap;">
                        <label style="color: var(--text-muted);">
                            <input type="checkbox" id="search-case-sensitive" style="margin-right: 5px;">
                            Case Sensitive
                        </label>
                        <label style="color: var(--text-muted);">
                            <input type="checkbox" id="search-whole-word" style="margin-right: 5px;">
                            Whole Word Only
                        </label>
                        <label style="color: var(--text-muted);">
                            Search in:
                            <select id="search-scope" style="margin-left: 10px; padding: 5px; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px;">
                                <option value="all">All Data</option>
                                <option value="persistence">Persistence Only</option>
                                <option value="files">Files Only</option>
                                <option value="registry">Registry Only</option>
                                <option value="browser">Browser Only</option>
                                <option value="logs">Logs Only</option>
                                <option value="services">Services Only</option>
                                <option value="tasks">Tasks Only</option>
                            </select>
                        </label>
                    </div>
                    
                    <div id="search-status" style="color: var(--text-muted); margin-bottom: 15px; min-height: 20px;"></div>
                    
                    <div id="search-results" style="margin-top: 20px;"></div>
                </div>
            </div>
        </div>
        
        <div id="settings-tab" class="tab-content">
            <div class="csv-section">
                <h2 style="color: #3498db; margin-bottom: 15px;">Display Settings</h2>
                <div style="background: var(--bg-secondary); padding: 20px; border-radius: 8px; max-width: 700px; border: 1px solid var(--border-color);">
                    <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 6px; margin-bottom: 20px; border-left: 4px solid var(--accent-blue);">
                        <p style="color: var(--text-secondary); font-size: 0.9em; margin: 0; line-height: 1.6;">
                            Data up to the initial MaxRows limit ($MaxRows) is embedded in this report. 
                            These settings control how much of that embedded data is displayed in tables. 
                            Reducing limits improves browser performance with large datasets.
                        </p>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; color: var(--text-primary); margin-bottom: 10px; font-weight: bold;">
                            <span style="font-size: 1.1em;">Maximum Rows Per Table</span>
                        </label>
                        <p style="color: var(--text-muted); font-size: 0.9em; margin-bottom: 10px;">
                            Limit how many records/rows display in each table. Set to 0 to show all embedded data.
                        </p>
                        <input type="number" id="settings-maxrows" value="$MaxRows" min="0" step="100" 
                            style="width: 100%; padding: 10px; background: var(--input-bg); border: 1px solid var(--input-border); color: var(--text-primary); border-radius: 4px; font-size: 1em;">
                        <p style="color: var(--text-dark); font-size: 0.85em; margin-top: 8px;">
                            Currently displaying: <span id="current-maxrows" style="color: var(--accent-blue); font-weight: bold;">$(if ($MaxRows -eq 0) { 'All' } else { $MaxRows })</span> rows per table
                        </p>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; color: var(--text-primary); margin-bottom: 10px; font-weight: bold;">
                            <span style="font-size: 1.1em;">Maximum Characters Per Cell</span>
                        </label>
                                        <p style="color: var(--text-muted); font-size: 0.9em; margin-bottom: 10px;">
                            Text longer than this limit will be truncated with "..." Hover over truncated cells to see preview of content.
                        </p>
                        <input type="number" id="settings-maxchars" value="$MaxChars" min="50" step="50" 
                            style="width: 100%; padding: 10px; background: var(--input-bg); border: 1px solid var(--input-border); color: var(--text-primary); border-radius: 4px; font-size: 1em;">
                        <p style="color: var(--text-dark); font-size: 0.85em; margin-top: 8px;">
                            Currently truncating at: <span id="current-maxchars" style="color: var(--accent-blue); font-weight: bold;">$MaxChars</span> characters
                        </p>
                    </div>                    
                    <button onclick="applySettings()" 
                        style="width: 100%; padding: 15px; background: var(--accent-blue); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 1.1em; font-weight: bold; transition: background 0.3s;"
                        onmouseover="this.style.background='var(--accent-blue-hover)'"
                        onmouseout="this.style.background='var(--accent-blue)'">
                        Apply Settings
                    </button>

                    <div style="margin-top: 15px; padding: 12px; background: var(--bg-tertiary); border-radius: 4px; border-left: 4px solid var(--accent-yellow);">
                        <p style="color: var(--text-secondary); font-size: 0.85em; margin: 0; line-height: 1.5;">
                            <strong>Note:</strong> After applying, switch to any data tab to see the updated display limits. 
                            For full datasets beyond the embedded limit, download CSV files.
                        </p>
                    </div>                
                </div>
            </div>
        </div>
    </div>

    <script>
        var MAX_CHARS = $MaxChars;
        var MAX_ROWS = $MaxRows;
        
        var embeddedData = {
            persistence: $persistenceJson,
            registry: $registryJson,
            logs: $logsJson,
            browser: $browserJson,
            services: $servicesJson,
            tasks: $tasksJson,
            files: $filesJson
        };
        
        // System info data for searching - dynamically built from all system info
        var systemInfoSearchData = [];
        
        // Add PowerShell History
$(
    if ($ForensicData.SystemInfo.PSHistory -and $ForensicData.SystemInfo.PSHistory.Count -gt 0) {
        $psJson = "["
        for ($i = 0; $i -lt $ForensicData.SystemInfo.PSHistory.Count; $i++) {
            $cmdRaw = $ForensicData.SystemInfo.PSHistory[$i]
            $cmd = ConvertTo-SafeJsString $cmdRaw
            $psJson += "{Category:'PowerShell History',Field:'Command',Value:'$cmd',TableRef:'pshistory-table',RowIndex:$i}"
            if ($i -lt $ForensicData.SystemInfo.PSHistory.Count - 1) { $psJson += "," }
        }
        $psJson += "]"
        "        systemInfoSearchData = systemInfoSearchData.concat($psJson);`n"
    }
)
        
        // Add Processes
$(
    if ($ForensicData.SystemInfo.Processes -and $ForensicData.SystemInfo.Processes.Count -gt 0) {
        $procJson = "["
        $procLimit = [Math]::Min(500, $ForensicData.SystemInfo.Processes.Count)
        for ($i = 0; $i -lt $procLimit; $i++) {
            $proc = $ForensicData.SystemInfo.Processes[$i]
            $name = ConvertTo-SafeJsString $proc.ProcessName
            $path = ConvertTo-SafeJsString $proc.Path
            $user = ConvertTo-SafeJsString $proc.UserName
            $procJson += "{Category:'Processes',Field:'$name',Value:'$path $user',TableRef:'process-table',RowIndex:$i}"
            if ($i -lt $procLimit - 1) { $procJson += "," }
        }
        $procJson += "]"
        "        systemInfoSearchData = systemInfoSearchData.concat($procJson);`n"
    }
)
        
        // Add DNS Cache
$(
    if ($ForensicData.SystemInfo.DNSCache -and $ForensicData.SystemInfo.DNSCache.Count -gt 0) {
        $dnsJson = "["
        $dnsLimit = [Math]::Min(500, $ForensicData.SystemInfo.DNSCache.Count)
        for ($i = 0; $i -lt $dnsLimit; $i++) {
            $dns = $ForensicData.SystemInfo.DNSCache[$i]
            $name = if ($dns.Entry) { ConvertTo-SafeJsString $dns.Entry } elseif ($dns.RecordName) { ConvertTo-SafeJsString $dns.RecordName } else { "" }
            $data = ConvertTo-SafeJsString $dns.Data
            if (![string]::IsNullOrWhiteSpace($name) -or ![string]::IsNullOrWhiteSpace($data)) {
                $dnsJson += "{Category:'DNS Cache',Field:'$name',Value:'$data',TableRef:'dns-table',RowIndex:$i}"
                if ($i -lt $dnsLimit - 1) { $dnsJson += "," }
            }
        }
        $dnsJson += "]"
        "        systemInfoSearchData = systemInfoSearchData.concat($dnsJson);`n"
    }
)
        
        // Add Network Connections
$(
    if ($ForensicData.SystemInfo.NetworkConnections -and $ForensicData.SystemInfo.NetworkConnections.Count -gt 0) {
        $netJson = "["
        $netLimit = [Math]::Min(500, $ForensicData.SystemInfo.NetworkConnections.Count)
        for ($i = 0; $i -lt $netLimit; $i++) {
            $conn = $ForensicData.SystemInfo.NetworkConnections[$i]
            $netJson += "{Category:'Network Connections',Field:'$($conn.LocalAddress):$($conn.LocalPort)',Value:'$($conn.RemoteAddress):$($conn.RemotePort) $($conn.State)',TableRef:'network-table',RowIndex:$i}"
            if ($i -lt $netLimit - 1) { $netJson += "," }
        }
        $netJson += "]"
        "        systemInfoSearchData = systemInfoSearchData.concat($netJson);`n"
    }
)
        
        // Add Installed Software
$(
    if ($ForensicData.SystemInfo.InstalledSoftware -and $ForensicData.SystemInfo.InstalledSoftware.Count -gt 0) {
        $swJson = "["
        for ($i = 0; $i -lt $ForensicData.SystemInfo.InstalledSoftware.Count; $i++) {
            $sw = $ForensicData.SystemInfo.InstalledSoftware[$i]
            $name = ConvertTo-SafeJsString $sw.DisplayName
            $pub = ConvertTo-SafeJsString $sw.Publisher
            $ver = ConvertTo-SafeJsString $sw.DisplayVersion
            $swJson += "{Category:'Installed Software',Field:'$name',Value:'$pub $ver',TableRef:'software-table',RowIndex:$i}"
            if ($i -lt $ForensicData.SystemInfo.InstalledSoftware.Count - 1) { $swJson += "," }
        }
        $swJson += "]"
        "        systemInfoSearchData = systemInfoSearchData.concat($swJson);`n"
    }
)
        
// Add Browser Extensions to browser search data
        var browserExtensionsData = [];
$(
    if ($ForensicData.SystemInfo.BrowserExtensions -and $ForensicData.SystemInfo.BrowserExtensions.Count -gt 0) {
        $sortedExtensionsForSearch = $ForensicData.SystemInfo.BrowserExtensions | Sort-Object -Property Name
        
        $extJson = "["
        $extLimit = [Math]::Min(200, $sortedExtensionsForSearch.Count)
        for ($i = 0; $i -lt $extLimit; $i++) {
            $ext = $sortedExtensionsForSearch[$i]
            $name = ConvertTo-SafeJsString $ext.Name
            $extId = ConvertTo-SafeJsString $ext.ID
            $browser = ConvertTo-SafeJsString $ext.Browser
            $user = ConvertTo-SafeJsString $ext.User
            
            $extJson += "{User:'$user',Browser:'$browser',Name:'$name',ID:'$extId',RowIndex:$i}"
            if ($i -lt $extLimit - 1) { $extJson += "," }
        }
        $extJson += "];"
        "        browserExtensionsData = $extJson`n"
    }
)
        
        // Add User Accounts
$(
    if ($ForensicData.SystemInfo.AllUserAccounts -and $ForensicData.SystemInfo.AllUserAccounts.Count -gt 0) {
        $userJson = "["
        for ($i = 0; $i -lt $ForensicData.SystemInfo.AllUserAccounts.Count; $i++) {
            $user = $ForensicData.SystemInfo.AllUserAccounts[$i]
            $username = ConvertTo-SafeJsString $user.Username
            $profile = ConvertTo-SafeJsString $user.ProfilePath
            $userJson += "{Category:'User Accounts',Field:'$username',Value:'$profile $($user.Type)',TableRef:'users-accounts-table',RowIndex:$i}"
            if ($i -lt $ForensicData.SystemInfo.AllUserAccounts.Count - 1) { $userJson += "," }
        }
        $userJson += "]"
        "        systemInfoSearchData = systemInfoSearchData.concat($userJson);`n"
    }
)
        
        // Add Network Adapters
$(
    if ($ForensicData.SystemInfo.NetworkAdapters -and $ForensicData.SystemInfo.NetworkAdapters.Count -gt 0) {
        $adapterJson = "["
        for ($i = 0; $i -lt $ForensicData.SystemInfo.NetworkAdapters.Count; $i++) {
            $adapter = $ForensicData.SystemInfo.NetworkAdapters[$i]
            $name = ConvertTo-SafeJsString $adapter.Name
            $mac = if ($adapter.MacAddress) { $adapter.MacAddress } else { "" }
            $adapterJson += "{Category:'Network Adapters',Field:'$name',Value:'$mac $($adapter.Status)',TableRef:'adapters-table',RowIndex:$i}"
            if ($i -lt $ForensicData.SystemInfo.NetworkAdapters.Count - 1) { $adapterJson += "," }
        }
        $adapterJson += "]"
        "        systemInfoSearchData = systemInfoSearchData.concat($adapterJson);`n"
    }
)
        
        var logsByProvider = {
"@

        # Add log provider data to JavaScript
        foreach ($provider in $logsByProviderJson.Keys) {
            $providerSafe = $provider -replace "'", "\'"
            $html += "            '$providerSafe': $($logsByProviderJson[$provider]),`n"
        }

        $html += @"
        };
        
        var logProviders = $logProvidersJson;
        var currentLogProvider = 'All';

        var loadedData = {};
        var sortState = {};
        var systemSortState = {};
        var currentTab = 'overview';

        function showTab(tabName) {
            var tabs = document.querySelectorAll('.tab-content');
            for (var i = 0; i < tabs.length; i++) {
                tabs[i].classList.remove('active');
            }
            
            var buttons = document.querySelectorAll('.tab-button');
            for (var i = 0; i < buttons.length; i++) {
                buttons[i].classList.remove('active');
            }
            
            var tabContent = document.getElementById(tabName + '-tab');
            if (tabContent) {
                tabContent.classList.add('active');
            }
            
            var clickedButton = event ? event.target : null;
            if (clickedButton) {
                clickedButton.classList.add('active');
            }
            
            currentTab = tabName;
            
            var dataTypes = ['persistence', 'registry', 'logs', 'browser', 'services', 'tasks', 'files'];
            if (dataTypes.indexOf(tabName) !== -1) {
                // Show loading spinner while data loads
                var contentDiv = document.getElementById(tabName + '-content');
                if (contentDiv && !loadedData[tabName]) {
                    contentDiv.innerHTML = '<div class="tab-loader"><div class="tab-spinner"><div class="tab-spinner-ring"></div><div class="tab-spinner-ring"></div></div><div class="tab-loader-text">Loading data...</div></div>';
                }
                
                if (tabName === 'logs') {
                    initializeLogProviderSelector();
                }
                
                // Use setTimeout to allow spinner to render before loading data
                setTimeout(function() {
                    loadData(tabName);
                }, 50);
            }
        }

        function initializeLogProviderSelector() {
            var select = document.getElementById('log-provider-select');
            if (select && select.options.length === 0) {
                for (var i = 0; i < logProviders.length; i++) {
                    var option = document.createElement('option');
                    option.value = logProviders[i];
                    option.text = logProviders[i];
                    select.appendChild(option);
                }
            }
        }

        function changeLogProvider() {
            var select = document.getElementById('log-provider-select');
            if (!select) return;
            
            currentLogProvider = select.value;
            delete loadedData['logs'];
            
            var logsContent = document.getElementById('logs-content');
            if (logsContent) {
                logsContent.innerHTML = '<div class="loading">Loading data...</div>';
            }
            
            setTimeout(function() {
                loadData('logs');
            }, 100);
        }

        function isHashField(fieldName) {
            var hashFields = ['sha256', 'sha1', 'md5', 'hash', 'taskfilesha256', 'executablesha256', 'scriptfilesha256', 'lnktargetsha256'];
            var lowerField = fieldName.toLowerCase();
            for (var i = 0; i < hashFields.length; i++) {
                if (lowerField.indexOf(hashFields[i]) !== -1) {
                    return true;
                }
            }
            return false;
        }
        
        function isFileNameField(fieldName) {
            var fileNameFields = ['name', 'filename', 'file'];
            var lowerField = fieldName.toLowerCase();
            // Only match exact field names to avoid false positives
            for (var i = 0; i < fileNameFields.length; i++) {
                if (lowerField === fileNameFields[i]) {
                    return true;
                }
            }
            return false;
        }

        function createVTLink(hash) {
            if (!hash || hash === 'N/A' || hash === '') return hash;
            var cleanHash = String(hash).trim().toLowerCase();
            if (!/^[a-f0-9]{32,64}$/i.test(cleanHash)) return hash;
            return '<a href="https://www.virustotal.com/gui/file/' + cleanHash + '" target="_blank" class="vt-link" title="Lookup on VirusTotal">' + cleanHash + '</a>';
        }
        
        function isIPAddress(value) {
            if (!value) return false;
            var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
            return ipv4Regex.test(String(value).trim());
        }
        
        function createIPLink(ip) {
            var cleanIP = String(ip).trim();
            return '<a href="https://scamalytics.com/ip/' + cleanIP + '" target="_blank" class="vt-link" title="Lookup on Scamalytics">' + cleanIP + '</a>';
        }
        
        function isDomainOrURL(value) {
            if (!value) return false;
            var str = String(value).trim();
            // Check for URL patterns
            if (str.match(/^https?:\/\//i)) return 'url';
            // Check for domain patterns (simple check)
            if (str.match(/^[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,}$/i)) return 'domain';
            return false;
        }

        function extractDomainFromURL(url) {
            try {
                var str = String(url).trim();
                // Remove protocol
                var withoutProtocol = str.replace(/^https?:\/\//i, '');
                // Extract domain (everything before first /)
                var domain = withoutProtocol.split('/')[0];
                // Remove port if present
                domain = domain.split(':')[0];
                return domain;
            } catch (e) {
                return null;
            }
        }

        function createDomainLink(value) {
            var type = isDomainOrURL(value);
            if (!type) return value;
            
            var domain = type === 'url' ? extractDomainFromURL(value) : value;
            if (!domain) return value;
            
            // More specific title based on whether it's a URL or domain
            var titleText = type === 'url' ? 'Lookup Domain on VirusTotal' : 'Lookup on VirusTotal';
            
            return '<a href="https://www.virustotal.com/gui/domain/' + domain + '" target="_blank" class="vt-link" title="' + titleText + '">' + value + '</a>';
        }

        function truncateCell(value) {
            if (value === null || value === undefined) return '';
            var strValue = String(value);
            if (strValue.length > MAX_CHARS) {
                // Escape HTML entities for title attribute
                var escapedValue = strValue.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                // Limit hover preview to 5000 characters to avoid browser issues
                var hoverPreview = escapedValue.length > 5000 ? escapedValue.substring(0, 5000) + '... (truncated for display)' : escapedValue;
                return '<span class="truncated" title="' + hoverPreview + '">' + 
                       strValue.substring(0, MAX_CHARS) + '...' + '</span>';
            }
            return strValue;
        }

        function loadData(type) {
            var content = document.getElementById(type + '-content');
            if (!content) {
                console.error('Content element not found for type: ' + type);
                return;
            }
            
            // CRITICAL FIX: Check if we're forcing a reload (settings changed)
            // If loadedData exists but we're forcing reload, we'll re-process it
            var forceReload = window.forceDataReload || false;
            
            // If data already loaded and not forcing reload, skip loading entirely
            if (loadedData[type] && !forceReload) {
                return;
            }
            
            try {
                var data;
                
                // Handle log provider selection
                if (type === 'logs') {
                    if (currentLogProvider === 'All') {
                        data = embeddedData.logs;
                    } else {
                        data = logsByProvider[currentLogProvider];
                        // If provider has no data, set to empty array
                        if (!data) {
                            data = [];
                        }
                    }
                } else {
                    data = embeddedData[type];
                }
                
                // Handle empty or missing data
                if (!data || data.length === 0) {
                    var typeNames = {
                        'persistence': 'Persistence Mechanisms',
                        'registry': 'Registry Entries',
                        'logs': 'Event Logs',
                        'browser': 'Browser History',
                        'services': 'Services',
                        'tasks': 'Scheduled Tasks',
                        'files': 'Files'
                    };
                    var typeName = typeNames[type] || type.charAt(0).toUpperCase() + type.slice(1);
                    
                    var emptyMessage = '<div style="padding: 40px; text-align: center; background: var(--bg-secondary); border-radius: 8px; margin: 20px 0; border: 1px solid var(--border-color);">';
                    emptyMessage += '<svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: var(--text-muted); margin-bottom: 15px;">';
                    emptyMessage += '<circle cx="12" cy="12" r="10"></circle>';
                    emptyMessage += '<line x1="12" y1="8" x2="12" y2="12"></line>';
                    emptyMessage += '<line x1="12" y1="16" x2="12.01" y2="16"></line>';
                    emptyMessage += '</svg>';
                    emptyMessage += '<p style="color: var(--text-muted); font-size: 1.2em; margin-bottom: 10px; font-weight: 600;">No ' + typeName + ' Found</p>';
                    
                    if (type === 'logs' && currentLogProvider !== 'All') {
                        emptyMessage += '<p style="color: var(--text-dark); font-size: 0.95em; margin-bottom: 10px;">No events found for log provider: <strong>' + currentLogProvider + '</strong></p>';
                        emptyMessage += '<p style="color: var(--text-dark); font-size: 0.9em; margin-top: 10px;">Try selecting a different log provider from the dropdown above.</p>';
                    } else {
                        emptyMessage += '<p style="color: var(--text-dark); font-size: 0.95em; line-height: 1.6; max-width: 600px; margin: 10px auto;">No data was collected for this category. This could mean no items matched the criteria, this module was not included in the scan, or the date range excluded all relevant data.</p>';
                    }
                    
                    emptyMessage += '</div>';
                    content.innerHTML = emptyMessage;
                    loadedData[type] = [];
                    return;
                }
                
                // Create a copy to avoid mutating embedded data
                data = JSON.parse(JSON.stringify(data));
                
                // Auto-sort logs by TimeCreated (newest first) on initial load
                if (type === 'logs' && data.length > 0) {
                    data.sort(function(a, b) {
                        var dateA = a.TimeCreated || a['Formatted Time'] || '';
                        var dateB = b.TimeCreated || b['Formatted Time'] || '';
                        if (!dateA) return 1;
                        if (!dateB) return -1;
                        var cleanA = dateA.toString().split(' (')[0];
                        var cleanB = dateB.toString().split(' (')[0];
                        return cleanB.localeCompare(cleanA, undefined, {numeric: true});
                    });
                    sortState['logs-TimeCreated'] = 'desc';
                }
                
                // Auto-sort files by LastModifiedDate (newest first) on initial load
                if (type === 'files' && data.length > 0) {
                    data.sort(function(a, b) {
                        var dateA = a.LastModifiedDate || a.LastModified || a.CreationDate || '';
                        var dateB = b.LastModifiedDate || b.LastModified || b.CreationDate || '';
                        if (!dateA || dateA === 'N/A') return 1;
                        if (!dateB || dateB === 'N/A') return -1;
                        return dateB.localeCompare(dateA, undefined, {numeric: true});
                    });
                    sortState['files-LastModifiedDate'] = 'desc';
                }
                
                // Auto-sort tasks by LastRunTime (newest first) on initial load
                if (type === 'tasks' && data.length > 0) {
                    data.sort(function(a, b) {
                        var dateA = a.LastRunTime || a.NextRunTime || '';
                        var dateB = b.LastRunTime || b.NextRunTime || '';
                        if (!dateA || dateA === 'N/A' || dateA === '') return 1;
                        if (!dateB || dateB === 'N/A' || dateB === '') return -1;
                        return dateB.localeCompare(dateA, undefined, {numeric: true});
                    });
                    sortState['tasks-LastRunTime'] = 'desc';
                }
                
                // Auto-sort services by LastModified (newest first) on initial load
                if (type === 'services' && data.length > 0) {
                    data.sort(function(a, b) {
                        var dateA = a.LastModified || a.LastModifiedDate || '';
                        var dateB = b.LastModified || b.LastModifiedDate || '';
                        if (!dateA || dateA === 'N/A' || dateA === '') return 1;
                        if (!dateB || dateB === 'N/A' || dateB === '') return -1;
                        return dateB.localeCompare(dateA, undefined, {numeric: true});
                    });
                    sortState['services-LastModified'] = 'desc';
                }
                
                // Auto-sort browser by timestamp fields (newest first) on initial load
                if (type === 'browser' && data.length > 0) {
                    // Check if this is LoadTool mode data by checking for VisitTime field
                    var hasVisitTime = data[0] && data[0].VisitTime;
                    
                    if (hasVisitTime) {
                        // LoadTool mode - sort by VisitTime
                        data.sort(function(a, b) {
                            var dateA = a.VisitTime || '';
                            var dateB = b.VisitTime || '';
                            if (!dateA || dateA === 'N/A') return 1;
                            if (!dateB || dateB === 'N/A') return -1;
                            return dateB.localeCompare(dateA, undefined, {numeric: true});
                        });
                        sortState['browser-VisitTime'] = 'desc';
                    } else {
                        // Standard mode - sort by FullString or Timestamp
                        data.sort(function(a, b) {
                            var dateA = a.FullString || a.Timestamp || '';
                            var dateB = b.FullString || b.Timestamp || '';
                            if (!dateA || dateA === 'N/A') return 1;
                            if (!dateB || dateB === 'N/A') return -1;
                            return dateB.localeCompare(dateA, undefined, {numeric: true});
                        });
                        sortState['browser-FullString'] = 'desc';
                    }
                }
                
                // Auto-sort registry by recent activity (newest first) on initial load
                if (type === 'registry' && data.length > 0) {
                    data.sort(function(a, b) {
                        var pathA = a.KeyPath || '';
                        var pathB = b.KeyPath || '';
                        return pathB.localeCompare(pathA, undefined, {numeric: true});
                    });
                    sortState['registry-KeyPath'] = 'desc';
                }
                
                // Auto-sort persistence by Flag (highest priority first) on initial load
                if (type === 'persistence' && data.length > 0) {
                    data.sort(function(a, b) {
                        var flagA = a.Flag || '';
                        var flagB = b.Flag || '';
                        var priority = {'Critical': 5, 'High': 4, 'Medium': 3, 'Low': 2, 'Info': 1, '': 0};
                        var valA = priority[flagA] || 0;
                        var valB = priority[flagB] || 0;
                        return valB - valA;
                    });
                    sortState['persistence-Flag'] = 'desc';
                }
                    
                
            // Store the sorted data
                loadedData[type] = data;
                
                // Render the table immediately
                renderTable(type, data);
            
            } catch (error) {
                var errorHtml = '<div style="padding: 30px; background: #2c2c2c; border-radius: 8px; border-left: 4px solid #e74c3c; margin: 20px 0;">';
                errorHtml += '<h3 style="color: #e74c3c; margin-bottom: 10px;">Error Loading Data</h3>';
                errorHtml += '<p style="color: #ecf0f1;">An error occurred while loading ' + type + ' data:</p>';
                errorHtml += '<p style="color: #95a5a6; font-family: monospace; margin-top: 10px;">' + error.message + '</p>';
                errorHtml += '<p style="color: #7f8c8d; margin-top: 15px; font-size: 0.9em;">Please check the browser console for more details.</p>';
                errorHtml += '</div>';
                content.innerHTML = errorHtml;
                console.error('Error loading ' + type + ':', error);
                loadedData[type] = [];
            }
        }

        function renderTable(type, data) {
            var content = document.getElementById(type + '-content');
            if (!content) return;
            
            if (!data || data.length === 0) {
                var typeNames = {
                    'persistence': 'Persistence Mechanisms',
                    'registry': 'Registry Entries',
                    'logs': 'Event Logs',
                    'browser': 'Browser History',
                    'services': 'Services',
                    'tasks': 'Scheduled Tasks',
                    'files': 'Files'
                };
                var typeName = typeNames[type] || type.charAt(0).toUpperCase() + type.slice(1);
                
                content.innerHTML = '<div style="padding: 40px; text-align: center; background: var(--bg-secondary); border-radius: 8px; margin: 20px 0; border: 1px solid var(--border-color);">' +
                    '<svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: var(--text-muted); margin-bottom: 15px;">' +
                    '<circle cx="12" cy="12" r="10"></circle>' +
                    '<line x1="12" y1="8" x2="12" y2="12"></line>' +
                    '<line x1="12" y1="16" x2="12.01" y2="16"></line>' +
                    '</svg>' +
                    '<p style="color: var(--text-muted); font-size: 1.2em; margin-bottom: 10px; font-weight: 600;">No ' + typeName + ' Found</p>' +
                    '<p style="color: var(--text-dark); font-size: 0.95em; line-height: 1.6; max-width: 600px; margin: 0 auto;">No data was collected for this category during the forensic analysis. This could mean:</p>' +
                    '<ul style="color: var(--text-dark); font-size: 0.9em; text-align: left; max-width: 500px; margin: 15px auto; line-height: 1.8;">' +
                    '<li>No items matched the collection criteria</li>' +
                    '<li>This module was not included in the scan configuration</li>' +
                    '<li>The date range excluded all relevant data</li>' +
                    '</ul>' +
                    '</div>';
                return;
            }

            try {
                // Memory safety: validate data before processing
                if (data.length > 100000) {
                    var proceed = confirm('Large dataset detected (' + data.length + ' records). Display may be slow. Continue?');
                    if (!proceed) {
                        content.innerHTML = '<div class="warning">Display cancelled. Use CSV files for large datasets.</div>';
                        return;
                    }
                }

                // Apply MAX_ROWS limit and track original count
            var originalDataLength = data.length;
            var fullData = data;
            var displayData = fullData;
            var isLimited = false;
            if (MAX_ROWS > 0 && fullData.length > MAX_ROWS) {
                displayData = fullData.slice(0, MAX_ROWS);
                isLimited = true;
            }          
            var keys = [];
            var keySet = {};
            for (var i = 0; i < displayData.length; i++) {
                for (var key in displayData[i]) {
                    if (displayData[i].hasOwnProperty(key) && !keySet[key]) {
                        keys.push(key);
                        keySet[key] = true;
                    }
                }
            }
            
            var totalRecords = originalDataLength;
            var displayingRecords = displayData.length;
            
            var html = '<div class="record-count">Displaying: ' + displayingRecords.toLocaleString() + ' of ' + totalRecords.toLocaleString() + ' records</div>';
            
            // Show banner if limited by MAX_ROWS OR if displaying fewer records than total
            if (isLimited || displayingRecords < totalRecords) {
                html += '<div style="background: linear-gradient(135deg, #f39c12, #e67e22); color: #fff; padding: 12px 20px; border-radius: 6px; margin: 10px 0; border-left: 4px solid #d35400; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">';
                html += '<strong> Limited Display:</strong> Showing first ' + displayingRecords.toLocaleString() + ' of ' + totalRecords.toLocaleString() + ' records (' + Math.round((displayingRecords / totalRecords) * 100) + '% of total data). ';
                html += 'MAX_ROWS setting: ' + (MAX_ROWS === 0 ? 'Unlimited' : MAX_ROWS.toLocaleString()) + '. ';
                html += 'Adjust in <strong>Settings</strong> tab or download CSV files for complete dataset.';
                html += '</div>';
            }
            
            html += '<div class="table-controls">';
            html += '<input type="text" id="' + type + '-search" placeholder="Search..." onkeyup="filterTable(\'' + type + '\')">';
            html += '</div>';
            html += '<div class="table-wrapper">';
            html += '<table id="' + type + '-table"><thead><tr>';
            
            for (var i = 0; i < keys.length; i++) {
                html += '<th onclick="if(!this.classList.contains(\'resizing\')) sortTable(\'' + type + '\', \'' + keys[i] + '\')" title="Click to sort by ' + keys[i] + '" style="position: relative;">' + keys[i] + '<div class="resizer" onclick="event.stopPropagation();"></div></th>';
            }
            
            html += '</tr></thead><tbody>';
            
            for (var i = 0; i < displayData.length; i++) {
                var item = displayData[i];
                if (!item) {
                    console.warn('Null item at index ' + i + ' in ' + type);
                    continue;
                }
                html += '<tr>';
                
                for (var j = 0; j < keys.length; j++) {
                    var key = keys[j];
                    
                    // Access property value directly from the object
                    // Avoid using displayData[i][key] which can cause enumeration issues
                    var val = item[key];

                    // Check if this is the Reference field in persistence data
                    var isReferenceField = (type === 'persistence' && key === 'Reference');
                    
                    // Check if we got an enumerator instead of actual value (corruption detection)
                    if (val && typeof val === 'object' && val.constructor && 
                        val.constructor.name && val.constructor.name.indexOf('Enumerator') !== -1) {
                        // Corruption detected - try to extract actual value
                        console.warn('Enumerator detected for key: ' + key + ' in item ' + i);
                        val = '';
                    }
                    
                    if (val === null || val === undefined) {
                        val = '';
                    } else if (typeof val === 'object' && val !== null) {
                        // If it's still an object, stringify it
                        try {
                            val = JSON.stringify(val);
                        } catch (e) {
                            val = String(val);
                        }
                    } else {
                        val = String(val);
                    }
                    
                    if (isHashField(key)) {
                        val = createVTLink(val);
                        html += '<td>' + val + '</td>';
                    } else if (isIPAddress(val)) {
                        val = createIPLink(val);
                        html += '<td>' + val + '</td>';
                    } else if (type === 'files' && isFileNameField(key)) {
                        // Don't hyperlink file names - they're not domains or URLs
                        var escaped = val.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                        html += '<td>' + truncateCell(escaped) + '</td>';
                    } else if (isDomainOrURL(val)) {
                        val = createDomainLink(val);
                        html += '<td>' + val + '</td>';
                    } else if (isReferenceField && val && val.match(/^https?:\/\//i)) {
                        // Reference field with URL - create direct hyperlink (not VirusTotal lookup)
                        var escaped = val.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                        html += '<td><a href="' + escaped + '" target="_blank" class="vt-link" title="Open reference: ' + escaped + '">' + truncateCell(escaped) + '</a></td>';
                    } else {
                        var escaped = val.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                        html += '<td>' + truncateCell(escaped) + '</td>';
                    }
                }
                html += '</tr>';
            }
            
            html += '</tbody></table></div>';
                
                // Clear any existing content and resize state
                var existingTable = document.getElementById(type + '-table');
                if (existingTable) {
                    existingTable.removeAttribute('data-resizable-enabled');
                }
                
                content.innerHTML = html;
                
                // Small delay to ensure DOM is ready
                setTimeout(function() {
                    makeColumnsResizable(type + '-table');
                }, 10);
            }
            catch (error) {
                content.innerHTML = '<div class="error">Error rendering table: ' + error.message + '</div>';
                console.error('renderTable error:', error);
            }
        }

        function makeColumnsResizable(tableId) {
            var table = document.getElementById(tableId);
            if (!table) {
                console.warn('Table not found for resizing: ' + tableId);
                return;
            }
            
            // Check if table already has resizing enabled
            if (table.hasAttribute('data-resizable-enabled')) {
                console.log('Table already has resizing enabled: ' + tableId);
                return;
            }
            
            // Mark table as having resizing enabled
            table.setAttribute('data-resizable-enabled', 'true');
            
            var headers = table.querySelectorAll('th');
            if (!headers || headers.length === 0) {
                console.warn('No headers found in table: ' + tableId);
                return;
            }
            
            for (var i = 0; i < headers.length; i++) {
                var header = headers[i];
                var resizer = header.querySelector('.resizer');
                
                if (!resizer) {
                    console.warn('No resizer found in header ' + i + ' of table: ' + tableId);
                    continue;
                }
                
                // Store reference to avoid closure issues
                (function(th, resizerElement) {
                    var isResizing = false;
                    var startX = 0;
                    var startWidth = 0;
                    var currentDragHandler = null;
                    var currentStopHandler = null;
                    
                    function handleMouseDown(e) {
                        // Prevent if already resizing
                        if (isResizing) {
                            console.log('Already resizing, ignoring mousedown');
                            return;
                        }
                        
                        e.preventDefault();
                        e.stopPropagation();
                        
                        isResizing = true;
                        startX = e.pageX;
                        startWidth = th.offsetWidth;
                        
                        // Visual feedback
                        th.classList.add('resizing');
                        resizerElement.classList.add('active');
                        document.body.style.cursor = 'col-resize';
                        document.body.style.userSelect = 'none';
                        
                        // Define handlers in this scope
                        currentDragHandler = function(e) {
                            if (!isResizing) return;
                            
                            e.preventDefault();
                            e.stopPropagation();
                            
                            var deltaX = e.pageX - startX;
                            var newWidth = startWidth + deltaX;
                            
                            // Enforce minimum width
                            if (newWidth < 50) {
                                newWidth = 50;
                            }
                            
                            // Apply width with important to override any conflicting styles
                            th.style.width = newWidth + 'px';
                            th.style.minWidth = newWidth + 'px';
                            th.style.maxWidth = newWidth + 'px';
                        };
                        
                        currentStopHandler = function(e) {
                            if (!isResizing) return;
                            
                            e.preventDefault();
                            e.stopPropagation();
                            
                            isResizing = false;
                            
                            // Remove visual feedback
                            th.classList.remove('resizing');
                            resizerElement.classList.remove('active');
                            document.body.style.cursor = '';
                            document.body.style.userSelect = '';
                            
                            // Remove event listeners
                            if (currentDragHandler) {
                                document.removeEventListener('mousemove', currentDragHandler);
                                currentDragHandler = null;
                            }
                            if (currentStopHandler) {
                                document.removeEventListener('mouseup', currentStopHandler);
                                currentStopHandler = null;
                            }
                            
                            console.log('Resize complete for column: ' + th.textContent.trim());
                        };
                        
                        // Add listeners
                        document.addEventListener('mousemove', currentDragHandler);
                        document.addEventListener('mouseup', currentStopHandler);
                        
                        console.log('Started resizing column: ' + th.textContent.trim());
                    }
                    
                    // Remove any existing listener by cloning
                    var newResizer = resizerElement.cloneNode(true);
                    resizerElement.parentNode.replaceChild(newResizer, resizerElement);
                    
                    // Add new listener
                    newResizer.addEventListener('mousedown', handleMouseDown);
                    
                    // Store reference for potential cleanup
                    newResizer.setAttribute('data-resize-initialized', 'true');
                    
                })(header, resizer);
            }
            
            console.log('Resizing enabled for table: ' + tableId + ' with ' + headers.length + ' columns');
        }

        function filterTable(type) {
            var input = document.getElementById(type + '-search');
            var filter = input.value.toLowerCase();
            var table = document.getElementById(type + '-table');
            
            if (!table) return;
            
            var rows = table.getElementsByTagName('tr');
            
            for (var i = 1; i < rows.length; i++) {
                var row = rows[i];
                var text = row.textContent.toLowerCase();
                row.style.display = text.indexOf(filter) > -1 ? '' : 'none';
            }
        }

        function sortTable(type, key) {
            // Check if we're currently resizing - if so, ignore sort
            var resizingHeaders = document.querySelectorAll('th.resizing');
            if (resizingHeaders.length > 0) {
                console.log('Resizing in progress, ignoring sort');
                return;
            }
            
            var data = loadedData[type];
            if (!data) return;
            
            var currentSort = sortState[type + '-' + key] || 'none';
            var newSort = currentSort === 'asc' ? 'desc' : 'asc';
            sortState[type + '-' + key] = newSort;
            
            data.sort(function(a, b) {
                var valA = a[key];
                var valB = b[key];
                
                if (valA === null || valA === undefined) valA = '';
                if (valB === null || valB === undefined) valB = '';
                
                if (typeof valA === 'object') valA = JSON.stringify(valA);
                if (typeof valB === 'object') valB = JSON.stringify(valB);
                
                valA = String(valA);
                valB = String(valB);
                
                var result = valA.localeCompare(valB, undefined, {numeric: true});
                return newSort === 'asc' ? result : -result;
            });
            
            renderTable(type, data);
        }

        function filterSystemTable(tableId) {
            var searchId = tableId.replace('-table', '-search');
            var input = document.getElementById(searchId);
            if (!input) return;
            
            var filter = input.value.toLowerCase();
            var table = document.getElementById(tableId);
            if (!table) return;
            
            var rows = table.getElementsByTagName('tr');
            for (var i = 1; i < rows.length; i++) {
                var row = rows[i];
                var text = row.textContent.toLowerCase();
                row.style.display = text.indexOf(filter) > -1 ? '' : 'none';
            }
        }

        function sortSystemTable(tableId, columnIndex) {
            var table = document.getElementById(tableId);
            if (!table) return;
            
            var tbody = table.getElementsByTagName('tbody')[0];
            if (!tbody) return;
            
            var rows = Array.prototype.slice.call(tbody.getElementsByTagName('tr'));
            if (rows.length === 0) return;
            
            var sortKey = tableId + '-' + columnIndex;
            var currentSort = systemSortState[sortKey] || 'none';
            var newSort = currentSort === 'asc' ? 'desc' : 'asc';
            systemSortState[sortKey] = newSort;
            
            rows.sort(function(a, b) {
                var cellA = a.getElementsByTagName('td')[columnIndex];
                var cellB = b.getElementsByTagName('td')[columnIndex];
                
                if (!cellA || !cellB) return 0;
                
                var valA = cellA.textContent.trim();
                var valB = cellB.textContent.trim();
                
                var numA = parseFloat(valA);
                var numB = parseFloat(valB);
                
                if (!isNaN(numA) && !isNaN(numB)) {
                    return newSort === 'asc' ? numA - numB : numB - numA;
                }
                
                var result = valA.localeCompare(valB, undefined, {numeric: true, sensitivity: 'base'});
                return newSort === 'asc' ? result : -result;
            });
            
            for (var i = 0; i < rows.length; i++) {
                tbody.appendChild(rows[i]);
            }
        }

        function applySettings() {
            var newMaxRows = parseInt(document.getElementById('settings-maxrows').value) || 0;
            var newMaxChars = parseInt(document.getElementById('settings-maxchars').value) || 200;
            
            // Validate inputs
            if (newMaxRows < 0) {
                alert('Max Rows must be 0 or greater (0 = unlimited)');
                return;
            }
            if (newMaxChars < 50) {
                alert('Max Characters must be at least 50');
                return;
            }
            
            // CRITICAL FIX: Update global settings BEFORE any processing
            MAX_ROWS = newMaxRows;
            MAX_CHARS = newMaxChars;
            
            // Update display
            document.getElementById('current-maxrows').textContent = newMaxRows === 0 ? 'Unlimited' : newMaxRows;
            document.getElementById('current-maxchars').textContent = newMaxChars;
            
            // Clear all cached/processed data to force fresh processing with new limits
            window.forceDataReload = true;
            sortState = {};
            systemSortState = {};
            loadedData = {};
            
            // Show loading message on all data tabs
            var dataTypes = ['persistence', 'registry', 'logs', 'browser', 'services', 'tasks', 'files'];
            for (var i = 0; i < dataTypes.length; i++) {
                var content = document.getElementById(dataTypes[i] + '-content');
                if (content) {
                    content.innerHTML = '<div class="loading">Reloading with new settings...</div>';
                }
            }
            
            // Force reload current tab if it's a data tab
            setTimeout(function() {
                if (dataTypes.indexOf(currentTab) !== -1) {
                    loadData(currentTab);
                    window.forceDataReload = false;
                    
                    var displayMsg = 'Settings applied successfully!\n\n';
                    displayMsg += 'Max Rows: ' + (newMaxRows === 0 ? 'Unlimited' : newMaxRows) + '\n';
                    displayMsg += 'Max Chars: ' + newMaxChars + '\n\n';
                    displayMsg += 'Current tab (' + currentTab + ') has been reloaded.\n';
                    displayMsg += 'Switch to other tabs to see them with new settings.';
                    alert(displayMsg);
                } else {
                    window.forceDataReload = false;
                    alert('Settings applied successfully.\n\nSwitch to any data tab to see results with new limits.');
                }
            }, 100);
        }

        // Global search functionality
        function performGlobalSearch() {
            var searchTerm = document.getElementById('global-search-input').value;
            var caseSensitive = document.getElementById('search-case-sensitive').checked;
            var wholeWord = document.getElementById('search-whole-word').checked;
            var scope = document.getElementById('search-scope').value;
            var statusDiv = document.getElementById('search-status');
            var resultsDiv = document.getElementById('search-results');
            
            // Trim and validate search term
            searchTerm = searchTerm.trim();
            
            if (!searchTerm || searchTerm.length < 3) {
                statusDiv.innerHTML = '<span style="color: var(--accent-red);">Please enter at least 3 characters to search.</span>';
                resultsDiv.innerHTML = '';
                return;
            }
            
            statusDiv.innerHTML = '<span style="color: var(--accent-blue);">Searching...</span>';
            resultsDiv.innerHTML = '';
            
            // Normalize whitespace in search term (replace multiple spaces with single space)
            searchTerm = searchTerm.replace(/\s+/g, ' ');
            
            // Prepare search term
            var searchQuery = caseSensitive ? searchTerm : searchTerm.toLowerCase();
            
            // Build search pattern
            var searchPattern;
            if (wholeWord) {
                var escapedTerm = searchQuery.replace(/[.*+?^`${}()|[\]\\]/g, '\\`$&');
                searchPattern = new RegExp('\\b' + escapedTerm + '\\b', caseSensitive ? 'g' : 'gi');
            } else {
                searchPattern = caseSensitive ? searchQuery : null;
            }
            
            var allResults = [];
            var searchStartTime = Date.now();
            
            // Determine which datasets to search
            var datasetsToSearch = [];
            var includeSystemInfo = false;
            if (scope === 'all') {
                datasetsToSearch = ['persistence', 'files', 'registry', 'browser', 'logs', 'services', 'tasks'];
                includeSystemInfo = true;
            } else {
                datasetsToSearch = [scope];
            }
            
            // Search system info data if scope is 'all'
            if (includeSystemInfo && systemInfoSearchData) {
                for (var si = 0; si < systemInfoSearchData.length; si++) {
                    var sysItem = systemInfoSearchData[si];
                    var matchFound = false;
                    var matchedFields = [];
                    
                    // Search Category, Field, and Value
                    var searchableText = sysItem.Category + ' ' + sysItem.Field + ' ' + sysItem.Value;
                    
                    // Normalize whitespace in searchable text
                    searchableText = searchableText.replace(/\s+/g, ' ').trim();
                    
                    var searchIn = caseSensitive ? searchableText : searchableText.toLowerCase();
                    
                    var foundMatch = false;
                    if (wholeWord && searchPattern) {
                        foundMatch = searchPattern.test(searchIn);
                    } else {
                        foundMatch = searchIn.indexOf(searchQuery) !== -1;
                    }
                    
                    if (foundMatch) {
                        // Find which specific field matched
                        if (caseSensitive ? sysItem.Field.indexOf(searchQuery) !== -1 : sysItem.Field.toLowerCase().indexOf(searchQuery) !== -1) {
                            matchedFields.push({
                                field: 'Field',
                                value: sysItem.Category + ' - ' + sysItem.Field,
                                preview: getMatchPreview(sysItem.Field, searchTerm, caseSensitive)
                            });
                        }
                        if (caseSensitive ? sysItem.Value.indexOf(searchQuery) !== -1 : sysItem.Value.toLowerCase().indexOf(searchQuery) !== -1) {
                            matchedFields.push({
                                field: 'Value',
                                value: sysItem.Value,
                                preview: getMatchPreview(sysItem.Value, searchTerm, caseSensitive)
                            });
                        }
                        if (caseSensitive ? sysItem.Category.indexOf(searchQuery) !== -1 : sysItem.Category.toLowerCase().indexOf(searchQuery) !== -1) {
                            matchedFields.push({
                                field: 'Category',
                                value: sysItem.Category,
                                preview: getMatchPreview(sysItem.Category, searchTerm, caseSensitive)
                            });
                        }
                        
                        if (matchedFields.length > 0) {
                            allResults.push({
                                dataType: 'systeminfo',
                                rowIndex: si,
                                item: sysItem,
                                matches: matchedFields
                            });
                        }
                    }
                }
            }

            // Search browser extensions data if scope is 'all' or 'browser'
            if ((scope === 'all' || scope === 'browser') && browserExtensionsData && browserExtensionsData.length > 0) {
                for (var bei = 0; bei < browserExtensionsData.length; bei++) {
                    var extItem = browserExtensionsData[bei];
                    var matchedFields = [];
                    
                    var searchableText = extItem.User + ' ' + extItem.Browser + ' ' + extItem.Name + ' ' + extItem.ID;
                    searchableText = searchableText.replace(/\s+/g, ' ').trim();
                    
                    var searchIn = caseSensitive ? searchableText : searchableText.toLowerCase();
                    
                    var foundMatch = false;
                    if (wholeWord && searchPattern) {
                        foundMatch = searchPattern.test(searchIn);
                    } else {
                        foundMatch = searchIn.indexOf(searchQuery) !== -1;
                    }
                    
                    if (foundMatch) {
                        if ((caseSensitive ? extItem.Name.indexOf(searchQuery) !== -1 : extItem.Name.toLowerCase().indexOf(searchQuery) !== -1)) {
                            matchedFields.push({
                                field: 'Extension Name',
                                value: extItem.Name,
                                preview: getMatchPreview(extItem.Name, searchTerm, caseSensitive)
                            });
                        }
                        if ((caseSensitive ? extItem.Browser.indexOf(searchQuery) !== -1 : extItem.Browser.toLowerCase().indexOf(searchQuery) !== -1)) {
                            matchedFields.push({
                                field: 'Browser',
                                value: extItem.Browser,
                                preview: getMatchPreview(extItem.Browser, searchTerm, caseSensitive)
                            });
                        }
                        if ((caseSensitive ? extItem.ID.indexOf(searchQuery) !== -1 : extItem.ID.toLowerCase().indexOf(searchQuery) !== -1)) {
                            matchedFields.push({
                                field: 'Extension ID',
                                value: extItem.ID,
                                preview: getMatchPreview(extItem.ID, searchTerm, caseSensitive)
                            });
                        }
                        
                        if (matchedFields.length > 0) {
                            allResults.push({
                                dataType: 'browser',
                                rowIndex: extItem.RowIndex,
                                item: {
                                    TableRef: 'extensions-table',
                                    Name: extItem.Name,
                                    Browser: extItem.Browser,
                                    User: extItem.User
                                },
                                matches: matchedFields
                            });
                        }
                    }
                }
            }            
            
            // Search each dataset
            for (var i = 0; i < datasetsToSearch.length; i++) {
                var dataType = datasetsToSearch[i];
                var data = embeddedData[dataType];
                
                if (!data || data.length === 0) continue;
                
                // Handle logs specially (search by provider if needed)
                if (dataType === 'logs' && currentLogProvider !== 'All') {
                    data = logsByProvider[currentLogProvider] || [];
                }
                
                // CRITICAL: Store reference to original data array for accurate indexing
                var originalDataRef = data;
                
                // Search through data
                for (var j = 0; j < data.length; j++) {
                    var item = data[j];
                    var matchFound = false;
                    var matchedFields = [];
                    
                    // Search all fields in the item
                    for (var key in item) {
                        if (!item.hasOwnProperty(key)) continue;
                        
                        var value = item[key];
                        if (value === null || value === undefined) continue;
                        
                        var valueStr = String(value);
                        
                        // Normalize whitespace in value (replace multiple spaces/tabs/newlines with single space)
                        valueStr = valueStr.replace(/\s+/g, ' ').trim();
                        
                        var searchIn = caseSensitive ? valueStr : valueStr.toLowerCase();
                        
                        var foundMatch = false;
                        if (wholeWord && searchPattern) {
                            foundMatch = searchPattern.test(searchIn);
                        } else {
                            foundMatch = searchIn.indexOf(searchQuery) !== -1;
                        }
                        
                        if (foundMatch) {
                            matchFound = true;
                            matchedFields.push({
                                field: key,
                                value: valueStr,
                                preview: getMatchPreview(valueStr, searchTerm, caseSensitive)
                            });
                        }
                    }
                    
                    if (matchFound) {
                        // Store both the row index AND a copy of the actual item data
                        // This ensures we can match it correctly even if table is sorted/filtered
                        var itemCopy = {};
                        for (var copyKey in item) {
                            if (item.hasOwnProperty(copyKey)) {
                                itemCopy[copyKey] = item[copyKey];
                            }
                        }
                        
                        allResults.push({
                            dataType: dataType,
                            rowIndex: j,
                            item: itemCopy,
                            matches: matchedFields
                        });
                    }
                }
            }
            
            var searchTime = Date.now() - searchStartTime;
            
            // Display results
            if (allResults.length === 0) {
                statusDiv.innerHTML = '<span style="color: var(--text-muted);">No results found for "' + searchTerm + '" (' + searchTime + 'ms)</span>';
                resultsDiv.innerHTML = '<div style="padding: 30px; text-align: center; color: var(--text-muted);">No matches found. Try different search terms or adjust your filters.</div>';
                return;
            }
            
            statusDiv.innerHTML = '<span style="color: var(--accent-green);"><strong>' + allResults.length + '</strong> results found for "' + searchTerm + '" (' + searchTime + 'ms)</span>';
            
            // Limit displayed results for performance
            var displayLimit = 500;
            var displayResults = allResults.slice(0, displayLimit);
            
            var resultsHtml = '';
            
            if (allResults.length > displayLimit) {
                resultsHtml += '<div style="background: var(--accent-yellow); color: #000; padding: 10px; border-radius: 4px; margin-bottom: 15px;">';
                resultsHtml += 'Showing first ' + displayLimit + ' of ' + allResults.length + ' results. Refine your search for better results.';
                resultsHtml += '</div>';
            }
            
            resultsHtml += '<div style="display: flex; flex-direction: column; gap: 10px;">';
            
            for (var i = 0; i < displayResults.length; i++) {
                var result = displayResults[i];
                var typeLabel = result.dataType.charAt(0).toUpperCase() + result.dataType.slice(1);
                var typeColor = getTypeColor(result.dataType);
                
                resultsHtml += '<div style="background: var(--bg-tertiary); padding: 15px; border-radius: 6px; border-left: 4px solid ' + typeColor + ';">';
                resultsHtml += '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">';
                resultsHtml += '<div style="display: flex; gap: 10px; align-items: center;">';
                resultsHtml += '<span style="background: ' + typeColor + '; color: white; padding: 4px 12px; border-radius: 4px; font-size: 12px; font-weight: bold;">' + typeLabel + '</span>';
                resultsHtml += '<span style="color: var(--text-muted); font-size: 13px;">Row ' + (result.rowIndex + 1) + '</span>';
                resultsHtml += '</div>';
                var tableRefParam = result.item.TableRef ? ",'" + result.item.TableRef + "'" : ",'null'";
                resultsHtml += '<button onclick="jumpToResult(\'' + result.dataType + '\', ' + result.rowIndex + tableRefParam + ')" style="background: var(--accent-blue); color: white; border: none; padding: 6px 15px; border-radius: 4px; cursor: pointer; font-size: 13px;">View in Tab</button>';
                resultsHtml += '</div>';
                
                // Show matched fields
                resultsHtml += '<div style="margin-top: 10px;">';
                for (var m = 0; m < result.matches.length && m < 3; m++) {
                    var match = result.matches[m];
                    resultsHtml += '<div style="margin-bottom: 8px;">';
                    resultsHtml += '<div style="color: var(--accent-blue); font-size: 12px; font-weight: bold; margin-bottom: 3px;">' + match.field + '</div>';
                    resultsHtml += '<div style="color: var(--text-primary); font-size: 13px; font-family: Consolas, monospace; background: var(--bg-primary); padding: 8px; border-radius: 4px; overflow: hidden; text-overflow: ellipsis;">' + match.preview + '</div>';
                    resultsHtml += '</div>';
                }
                if (result.matches.length > 3) {
                    resultsHtml += '<div style="color: var(--text-muted); font-size: 12px; font-style: italic;">+ ' + (result.matches.length - 3) + ' more field(s) matched</div>';
                }
                resultsHtml += '</div>';
                
                resultsHtml += '</div>';
            }
            
            resultsHtml += '</div>';
            resultsDiv.innerHTML = resultsHtml;
        }
        
        function getMatchPreview(text, searchTerm, caseSensitive) {
            var maxLen = 200;
            var searchIn = caseSensitive ? text : text.toLowerCase();
            var searchFor = caseSensitive ? searchTerm : searchTerm.toLowerCase();
            var index = searchIn.indexOf(searchFor);
            
            if (index === -1) return text.substring(0, maxLen);
            
            var start = Math.max(0, index - 50);
            var end = Math.min(text.length, index + searchTerm.length + 150);
            
            var preview = (start > 0 ? '...' : '') + text.substring(start, end) + (end < text.length ? '...' : '');
            
            // Highlight the match
            var highlightStart = (start > 0 ? 3 : 0) + (index - start);
            var highlightEnd = highlightStart + searchTerm.length;
            
            var highlighted = preview.substring(0, highlightStart) + 
                             '<span style="background: var(--accent-yellow); color: #000; font-weight: bold; padding: 2px 4px; border-radius: 2px;">' + 
                             preview.substring(highlightStart, highlightEnd) + 
                             '</span>' + 
                             preview.substring(highlightEnd);
            
            return highlighted;
        }
        
        function getTypeColor(dataType) {
            var colors = {
                'persistence': '#e74c3c',
                'files': '#3498db',
                'registry': '#9b59b6',
                'browser': '#1abc9c',
                'logs': '#f39c12',
                'services': '#2ecc71',
                'tasks': '#e67e22',
                'systeminfo': '#34495e'
            };
            return colors[dataType] || '#95a5a6';
        }

        function highlightTabButton(tabName) {
            // Remove active class from all buttons
            var buttons = document.querySelectorAll('.tab-button');
            for (var i = 0; i < buttons.length; i++) {
                buttons[i].classList.remove('active');
            }
            
            // Find and highlight the correct button
            for (var i = 0; i < buttons.length; i++) {
                var button = buttons[i];
                var buttonText = button.textContent.toLowerCase();
                
                // Match button by checking if it contains the tab name or starts with it
                if (buttonText.indexOf(tabName.toLowerCase()) !== -1 || 
                    button.getAttribute('onclick') === "showTab('" + tabName + "')") {
                    button.classList.add('active');
                    break;
                }
            }
        }
        
        function jumpToResult(dataType, rowIndex, tableRef) {
            if (tableRef === 'extensions-table') {
                showTab('browser');
                highlightTabButton('browser');
                
                setTimeout(function() {
                    var table = document.getElementById('extensions-table');
                    if (!table) return;
                    
                    var tbody = table.getElementsByTagName('tbody')[0];
                    if (!tbody) return;
                    
                    var rows = tbody.getElementsByTagName('tr');
                    
                    if (rows[rowIndex]) {
                        var targetRow = rows[rowIndex];
                        targetRow.style.background = 'var(--accent-yellow)';
                        targetRow.style.transition = 'background 2s';
                        targetRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        
                        setTimeout(function() {
                            targetRow.style.background = '';
                        }, 3000);
                    } else {
                        table.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }, 500);
                return;
            }
            
            // Handle system info specially - go to sysinfo tab and try to scroll to table
            if (dataType === 'systeminfo') {
                showTab('sysinfo');
                // Ensure tab button is highlighted
                highlightTabButton('sysinfo');
                
                // Wait for tab to render
                setTimeout(function() {
                    if (tableRef) {
                        var table = document.getElementById(tableRef);
                        if (table && table.rows && table.rows[rowIndex + 1]) {
                            var row = table.rows[rowIndex + 1]; // +1 for header
                            
                            // Highlight the row
                            row.style.background = 'var(--accent-yellow)';
                            row.style.transition = 'background 2s';
                            
                            // Scroll to row
                            row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            
                            // Remove highlight after 3 seconds
                            setTimeout(function() {
                                row.style.background = '';
                            }, 3000);
                        } else {
                            // Just scroll to the table
                            if (table) {
                                table.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            }
                        }
                    }
                }, 500);
                return;
            }
            
            // FIXED: Determine correct tab based on data category
            var targetTab = dataType;
            
            // CRITICAL: Check browser extensions FIRST before other checks
            // Browser extensions must map to browser tab, not sysinfo
            if (tableRef === 'extensions-table') {
                targetTab = 'browser';
            }
            // Map other system info tables to sysinfo tab
            else if (tableRef && (tableRef.indexOf('users-') === 0 || 
                                   tableRef.indexOf('process-') === 0 || 
                                   tableRef.indexOf('dns-') === 0 || 
                                   tableRef.indexOf('network-') === 0 ||
                                   tableRef.indexOf('software-') === 0 ||
                                   tableRef.indexOf('adapters-') === 0 ||
                                   tableRef.indexOf('drives-') === 0 ||
                                   tableRef.indexOf('usb-') === 0 ||
                                   tableRef.indexOf('shares-') === 0 ||
                                   tableRef.indexOf('optical-') === 0 ||
                                   tableRef.indexOf('runmru-') === 0 ||
                                   tableRef.indexOf('loggedin-') === 0 ||
                                   tableRef.indexOf('shadow-') === 0 ||
                                   tableRef.indexOf('amsi-') === 0 ||
                                   tableRef.indexOf('av-') === 0 ||
                                   tableRef.indexOf('minifilter-') === 0 ||
                                   tableRef === 'pshistory-table')) {
                targetTab = 'sysinfo';
            }
            
            // Switch to the appropriate tab
            showTab(targetTab);
            highlightTabButton(targetTab);
                
                // Wait for tab to load and ensure data is loaded
                setTimeout(function() {
                // Force data load if not already loaded
                if (!loadedData[dataType]) {
                    loadData(dataType);
                    
                    // Wait for data to render before trying to find row
                    setTimeout(function() {
                        scrollToAndHighlightRow(dataType, rowIndex);
                    }, 800);
                } else {
                    // Data already loaded, find the row immediately
                    scrollToAndHighlightRow(dataType, rowIndex);
                }
            }, 200);
        }
        
        function scrollToAndHighlightRow(dataType, rowIndex) {
            try {
                var table = document.getElementById(dataType + '-table');
                if (!table) {
                    console.error('Table not found: ' + dataType + '-table');
                    return;
                }
                
                var tbody = table.getElementsByTagName('tbody')[0];
                if (!tbody) {
                    console.error('Table body not found for: ' + dataType);
                    return;
                }
                
                // CRITICAL FIX: Account for filtered/sorted data
                // We need to find the row that matches our original data item
                // since table display order may differ from original data order
                var targetRow = null;
                
                // Get the original item from embedded data
                var originalData = embeddedData[dataType];
                if (dataType === 'logs' && currentLogProvider !== 'All') {
                    originalData = logsByProvider[currentLogProvider];
                }
                
                if (!originalData || rowIndex >= originalData.length) {
                    console.error('Invalid row index: ' + rowIndex + ' for dataset size: ' + (originalData ? originalData.length : 0));
                    return;
                }
                
                var targetItem = originalData[rowIndex];
                
                // Find matching row in current table display
                // Compare multiple fields to ensure correct match
                var rows = tbody.getElementsByTagName('tr');
                for (var i = 0; i < rows.length; i++) {
                    var row = rows[i];
                    var cells = row.getElementsByTagName('td');
                    
                    // Build comparison string from first few cells
                    var rowText = '';
                    for (var j = 0; j < Math.min(3, cells.length); j++) {
                        rowText += cells[j].textContent.trim() + '|';
                    }
                    
                    // Build comparison string from target item
                    var targetText = '';
                    var fieldCount = 0;
                    for (var key in targetItem) {
                        if (targetItem.hasOwnProperty(key) && fieldCount < 3) {
                            var val = targetItem[key];
                            if (val !== null && val !== undefined) {
                                targetText += String(val).trim() + '|';
                                fieldCount++;
                            }
                        }
                    }
                    
                    // Check for match
                    if (rowText === targetText) {
                        targetRow = row;
                        break;
                    }
                }
                
                // Fallback: if no match found, try using rowIndex directly
                if (!targetRow && rows[rowIndex]) {
                    console.warn('Using fallback row index for: ' + dataType);
                    targetRow = rows[rowIndex];
                }
                
                if (targetRow) {
                    // Highlight the row
                    targetRow.style.background = 'var(--accent-yellow)';
                    targetRow.style.transition = 'background 2s';
                    
                    // Scroll to row
                    targetRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // Remove highlight after 3 seconds
                    setTimeout(function() {
                        targetRow.style.background = '';
                    }, 3000);
                } else {
                    console.error('Could not find target row for index: ' + rowIndex);
                    alert('Could not locate the exact record in the table. It may be filtered or sorted differently.');
                }
            } catch (error) {
                console.error('Error in scrollToAndHighlightRow:', error);
            }
        }
        
        function clearGlobalSearch() {
            document.getElementById('global-search-input').value = '';
            document.getElementById('search-case-sensitive').checked = false;
            document.getElementById('search-whole-word').checked = false;
            document.getElementById('search-scope').value = 'all';
            document.getElementById('search-status').innerHTML = '';
            document.getElementById('search-results').innerHTML = '';
        }

        // Critical: Remove loader immediately and handle errors
        function removeLoader() {
            try {
                var loader = document.getElementById('page-loader');
                if (loader) {
                    console.log('Removing page loader');
                    loader.style.transition = 'opacity 0.3s ease';
                    loader.style.opacity = '0';
                    setTimeout(function() {
                        loader.style.display = 'none';
                        loader.remove();
                    }, 300);
                }
            } catch (error) {
                console.error('Error removing loader:', error);
                // Force remove even if there's an error
                var loader = document.getElementById('page-loader');
                if (loader) {
                    loader.style.display = 'none';
                }
            }
        }
        
        // Remove loader as soon as DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                console.log('DOMContentLoaded - removing loader');
                removeLoader();
            });
        } else {
            // DOM is already loaded
            console.log('DOM already loaded - removing loader immediately');
            removeLoader();
        }
        
        // Additional safeguards
        window.addEventListener('load', function() {
            console.log('Window loaded - ensuring loader is removed');
            removeLoader();
        });
        
        // Emergency fallback - force remove after 3 seconds
        setTimeout(function() {
            var loader = document.getElementById('page-loader');
            if (loader && loader.style.display !== 'none') {
                console.warn('Emergency: Force removing loader after 3 seconds');
                loader.style.display = 'none';
                if (loader.parentNode) {
                    loader.parentNode.removeChild(loader);
                }
            }
        }, 3000);

        // Global error handler to ensure loader is always removed
        window.addEventListener('error', function(e) {
            console.error('JavaScript error detected:', e.error);
            console.error('Error message:', e.message);
            console.error('Error at:', e.filename, 'line', e.lineno);
            
            // Ensure loader is removed even on error
            var loader = document.getElementById('page-loader');
            if (loader && loader.style.display !== 'none') {
                console.warn('Removing loader due to JavaScript error');
                loader.style.display = 'none';
                if (loader.parentNode) {
                    loader.parentNode.removeChild(loader);
                }
            }
            
            // Show error message to user
            var errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--bg-secondary); border: 2px solid var(--accent-red); padding: 20px; border-radius: 8px; z-index: 10000; max-width: 600px;';
            errorDiv.innerHTML = '<h3 style="color: var(--accent-red); margin-bottom: 10px;">JavaScript Error</h3>' +
                                '<p style="color: var(--text-primary);">An error occurred loading the report. The page may not function correctly.</p>' +
                                '<p style="color: var(--text-muted); font-size: 0.9em; margin-top: 10px;">Error: ' + e.message + '</p>' +
                                '<button onclick="this.parentElement.remove()" style="margin-top: 15px; padding: 8px 15px; background: var(--accent-blue); color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>';
            document.body.appendChild(errorDiv);
        });


        // Theme toggle functionality
        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            html.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            
            // Update button text
            const btn = document.getElementById('theme-toggle-btn');
            if (btn) {
                btn.textContent = newTheme === 'light' ? 'Dark Mode' : 'Light Mode';
            }
        }
        
        // Load saved theme on page load
        (function() {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme === 'light' ? 'light' : '');
            
            // Set initial button text
            window.addEventListener('load', function() {
                const btn = document.getElementById('theme-toggle-btn');
                if (btn) {
                    btn.textContent = savedTheme === 'light' ? 'Dark Mode' : 'Light Mode';
                }
            });
        })();
        
        // Simple loading message
        (function() {
            var loadProgress = document.getElementById('load-progress');
            if (loadProgress) {
                loadProgress.textContent = 'Initializing modules...';
            }
        })();
    </script>
<div class="footer">
        <div>
            <a href="https://github.com/blwhit/ThreatHunter" target="_blank">GitHub Repository</a>
            <span style="color: var(--text-muted); margin: 0 10px;">|</span>
            <a href="https://github.com/blwhit/ThreatHunter/wiki" target="_blank">Documentation</a>
            <span style="color: var(--text-muted); margin: 0 10px;">|</span>
            <a href="https://github.com/blwhit/ThreatHunter/issues" target="_blank">Report Issues</a>
        </div>
        <div class="footer-info">
            Created by ThreatHunter
        </div>
        <div class="footer-info" style="margin-top: 5px;">
            $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
        </div>
    </div>
</body>
</html>
"@

        try {
            $html | Out-File -FilePath $OutputPath -Encoding UTF8 -ErrorAction Stop
        }
        catch {
            Write-Warning "HTML report generation failed: $($_.Exception.Message)"
        }
    }
    # Initialize timing
    $script:StartTime = Get-Date
    
    # Validate parameters
    if ($Auto -and $Aggressive) {
        Write-Error "Cannot use both -Auto and -Aggressive modes simultaneously"
        return
    }
    
    # Set default mode if none specified
    if (-not $Auto -and -not $Aggressive) {
        $Auto = $true
    }
    # Validate Config parameter
    if ($Config -contains 'All' -and $Config.Count -gt 1) {
        Write-Warning "Config contains 'All' with other specific modules. 'All' takes precedence."
        $Config = @('All')
    }
    
    # Check for administrator privileges
    $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
    if (-not $isAdmin) {
        Write-Warning "Not running as Administrator. Some data collection will be limited."
    }

    # Handle LoadFromJson mode
    if (![string]::IsNullOrWhiteSpace($LoadFromJson)) {
        Write-Host "[+] LoadFromJson mode detected" -ForegroundColor Yellow
        
        # Expand and normalize the path
        try {
            # Expand environment variables
            $LoadFromJson = [System.Environment]::ExpandEnvironmentVariables($LoadFromJson)
            
            # Resolve to absolute path if relative
            if (-not [System.IO.Path]::IsPathRooted($LoadFromJson)) {
                $currentPath = Get-Location
                $LoadFromJson = Join-Path $currentPath.Path $LoadFromJson
            }
            
            # Normalize path
            $LoadFromJson = [System.IO.Path]::GetFullPath($LoadFromJson)
            
            Write-Host "[+] Resolved path: $LoadFromJson" -ForegroundColor Green
        }
        catch {
            Write-Error "Could not resolve LoadFromJson path: $($_.Exception.Message)"
            Write-Host "[!] Provided path: $LoadFromJson" -ForegroundColor Yellow
            Write-Host "[!] Current directory: $(Get-Location)" -ForegroundColor Yellow
            Write-Host "[!] Ensure the path exists and is accessible" -ForegroundColor Yellow
            return
        }
    
        # Validate path exists
        if (-not (Test-Path $LoadFromJson)) {
            Write-Error "LoadFromJson path does not exist: $LoadFromJson"
            Write-Host "[!] Tried to access: $LoadFromJson" -ForegroundColor Yellow
            Write-Host "[!] Current directory: $(Get-Location)" -ForegroundColor Yellow
            
            # Try to list parent directory to help user
            $parentPath = Split-Path -Parent $LoadFromJson
            if ($parentPath -and (Test-Path $parentPath)) {
                Write-Host "[!] Contents of parent directory ($parentPath):" -ForegroundColor Yellow
                Get-ChildItem -Path $parentPath -Directory | Select-Object -First 10 | ForEach-Object {
                    Write-Host "    - $($_.Name)" -ForegroundColor DarkGray
                }
            }
            return
        }
    
        # Check if it's a directory
        $jsonPath = $null
        if (Test-Path $LoadFromJson -PathType Container) {
            # It's a directory - look for JSON_Files subfolder first
            $jsonPath = Join-Path $LoadFromJson "JSON_Files"
            
            # If JSON_Files doesn't exist, check if we're already IN the JSON_Files folder
            if (-not (Test-Path $jsonPath)) {
                # Check if LoadFromJson itself contains the JSON files
                $testFile = Join-Path $LoadFromJson "persistence.json"
                if (Test-Path $testFile) {
                    Write-Host "[+] Detected JSON files in root folder (already in JSON_Files)" -ForegroundColor Green
                    $jsonPath = $LoadFromJson
                }
                else {
                    Write-Error "JSON_Files subfolder not found in: $LoadFromJson"
                    Write-Host "[!] Expected structure:" -ForegroundColor Yellow
                    Write-Host "    Option 1: $LoadFromJson\JSON_Files\persistence.json" -ForegroundColor Yellow
                    Write-Host "    Option 2: $LoadFromJson\persistence.json" -ForegroundColor Yellow
                    Write-Host "[!] Contents of $LoadFromJson :" -ForegroundColor Yellow
                    Get-ChildItem -Path $LoadFromJson | Select-Object -First 10 | ForEach-Object {
                        Write-Host "    - $($_.Name)" -ForegroundColor DarkGray
                    }
                    return
                }
            }
            else {
                Write-Host "[+] Found JSON_Files subfolder" -ForegroundColor Green
            }
        }
        else {
            Write-Error "LoadFromJson must point to a directory (either main output folder or JSON_Files folder)"
            Write-Host "[!] Provided path appears to be a file, not a directory" -ForegroundColor Yellow
            Write-Host "[!] Path: $LoadFromJson" -ForegroundColor Yellow
            return
        }
    
        Write-Host "[+] Loading JSON files from: $jsonPath" -ForegroundColor Green
    
        # Load JSON files
        $forensicData = @{
            SystemInfo  = $null
            Persistence = @()
            Files       = @{ All = @(); Recycled = @(); ADS = @() }
            Registry    = @()
            Browser     = @()
            Logs        = @()
            Services    = @()
            Tasks       = @()
        }
    
        try {
            # Load each JSON file if it exists
            $jsonFiles = @{
                'persistence.json' = 'Persistence'
                'logs.json'        = 'Logs'
                'browser.json'     = 'Browser'
                'services.json'    = 'Services'
                'tasks.json'       = 'Tasks'
                'files.json'       = 'Files'
                'registry.json'    = 'Registry'
                'systeminfo.json'  = 'SystemInfo'
            }
        
            foreach ($file in $jsonFiles.Keys) {
                $filePath = Join-Path $jsonPath $file
                if (Test-Path $filePath) {
                    $dataType = $jsonFiles[$file]
                    Write-Host "  [-] Loading $file..." -ForegroundColor DarkGray
                
                    try {
                        $jsonContent = Get-Content -Path $filePath -Raw -ErrorAction Stop
                        $loadedData = $jsonContent | ConvertFrom-Json -ErrorAction Stop
                    
                        if ($dataType -eq 'Files') {
                            $forensicData.Files.All = $loadedData
                        }
                        else {
                            $forensicData[$dataType] = $loadedData
                        }
                    
                        # Display appropriate count
                        $recordCount = 0
                        if ($loadedData -is [array]) {
                            $recordCount = $loadedData.Count
                        }
                        elseif ($null -ne $loadedData) {
                            $recordCount = 1
                        }
                        
                        Write-Host "  [+] Loaded $recordCount records from $file" -ForegroundColor Green
                    }
                    catch {
                        Write-Warning "Error loading $file : $($_.Exception.Message)"
                        Write-Host "  [!] Continuing without $dataType data" -ForegroundColor Yellow
                    }
                }
                else {
                    Write-Host "  [!] $file not found - skipping" -ForegroundColor Yellow
                }
            }
        
            # Set output directory - either use provided or create new one based on loaded data location
            if ([string]::IsNullOrWhiteSpace($OutputDir)) {
                $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
                $OutputDir = Join-Path ([System.IO.Path]::GetDirectoryName($LoadFromJson)) "ForensicReport_$timestamp"
            }
        
            # Expand to full path
            if (-not [System.IO.Path]::IsPathRooted($OutputDir)) {
                $OutputDir = $ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath($OutputDir)
            }
            $OutputDir = [System.IO.Path]::GetFullPath($OutputDir)
        
            # Create output directory
            if (-not (Test-Path $OutputDir)) {
                New-Item -Path $OutputDir -ItemType Directory -Force | Out-Null
                Write-Host "[+] Created output directory: $OutputDir" -ForegroundColor Green
            }
        
            # Set date range from loaded data or defaults
            if (-not $StartDate) {
                Write-Host "[!] No StartDate specified - using default (1970-01-01)" -ForegroundColor Yellow
                $parsedStartDate = [datetime]::new(1970, 1, 1)
            }
            else {
                try {
                    $parsedStartDate = ConvertTo-DateTime -InputValue $StartDate
                    Write-Host "[+] Using StartDate: $parsedStartDate" -ForegroundColor Green
                }
                catch {
                    Write-Error "Invalid StartDate format: $StartDate"
                    Write-Host "[!] StartDate must be a valid date or relative format (e.g., '7D', '24H')" -ForegroundColor Yellow
                    return
                }
            }
            
            try {
                $parsedEndDate = ConvertTo-DateTime -InputValue $EndDate
                Write-Host "[+] Using EndDate: $parsedEndDate" -ForegroundColor Green
            }
            catch {
                Write-Error "Invalid EndDate format: $EndDate"
                Write-Host "[!] EndDate must be a valid date or relative format (e.g., 'Now')" -ForegroundColor Yellow
                return
            }
            
            # Validate date range
            if ($parsedStartDate -gt $parsedEndDate) {
                Write-Error "StartDate ($parsedStartDate) cannot be after EndDate ($parsedEndDate)"
                return
            }
        
            # Generate HTML report from loaded data
            Write-Host "[+] Generating HTML report from loaded data..." -ForegroundColor Yellow
        
            $csvDir = Join-Path $OutputDir "ForensicData_CSV"
            New-Item -Path $csvDir -ItemType Directory -Force -ErrorAction SilentlyContinue | Out-Null
        
            $htmlPath = Join-Path $OutputDir "ForensicReport.html"
            Generate-HTMLReport -ForensicData $forensicData -OutputPath $htmlPath -CSVDir $csvDir `
                -StartDate $parsedStartDate -EndDate $parsedEndDate -Mode "LoadFromJson" `
                -MaxChars $MaxChars -MaxRows $MaxRows -AllFields:$AllFields
        
            Write-Host ""
            Write-Host "[!] HTML REPORT GENERATED FROM JSON DATA" -ForegroundColor Red -BackgroundColor Black
            Write-Host "[+] Output Directory: $OutputDir" -ForegroundColor Green
            Write-Host "[+] Forensic Report: $htmlPath" -ForegroundColor Green
            Write-Host ""
        
            return
        }
        catch {
            Write-Error "Failed to load JSON data: $($_.Exception.Message)"
            return
        }
    }

    # Setup output directory and expand to full path
    if ([string]::IsNullOrWhiteSpace($OutputDir)) {
        $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
        $OutputDir = "C:\ForensicDump_$($env:COMPUTERNAME)_$timestamp"
    }
    
    # Setup output directory and expand to full path
    if ([string]::IsNullOrWhiteSpace($OutputDir)) {
        $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
        $OutputDir = "C:\ForensicDump_$($env:COMPUTERNAME)_$timestamp"
    }
    else {
        # Validate OutputDir is not just whitespace or invalid characters
        if ([string]::IsNullOrWhiteSpace($OutputDir.Trim())) {
            Write-Error "OutputDir parameter cannot be empty or whitespace"
            return
        }
        
        # Expand relative paths and environment variables to absolute path
        try {
            # First resolve environment variables
            $OutputDir = [System.Environment]::ExpandEnvironmentVariables($OutputDir)
            
            # Then resolve to absolute path
            if (-not [System.IO.Path]::IsPathRooted($OutputDir)) {
                $OutputDir = $ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath($OutputDir)
            }
            
            # Normalize path (remove ..\, ./, etc.)
            $OutputDir = [System.IO.Path]::GetFullPath($OutputDir)
        }
        catch {
            Write-Warning "Could not fully resolve path. Using as-is: $OutputDir"
        }
    }
    
    try {
        if (-not (Test-Path $OutputDir)) {
            New-Item -Path $OutputDir -ItemType Directory -Force | Out-Null
            Write-Host "[+] Created output directory: $OutputDir" -ForegroundColor Green
        }
    }
    catch {
        Write-Error "Failed to create output directory: $($_.Exception.Message)"
        return
    }
    
    # Handle ExportLogs
    if ($ExportLogs) {
        Write-Progress -Activity "Hunt-ForensicDump" -Status "Exporting EVTX logs..." -PercentComplete 5
        Write-Host "[+] Exporting all EVTX logs..." -ForegroundColor Yellow
        
        try {
            $logsDir = Join-Path $OutputDir "EVTX_Export"
            New-Item -Path $logsDir -ItemType Directory -Force | Out-Null
            
            Hunt-Logs -Export $logsDir -Quiet
            
            Write-Host "[+] EVTX logs exported to: $logsDir" -ForegroundColor Green
        }
        catch {
            Write-Warning "Failed to export EVTX logs: $($_.Exception.Message)"
        }
    }
    
    # Handle "All Time" scenario
    if (-not $StartDate -or $StartDate -eq "AllTime" -or $StartDate -eq "All") {
        $StartDate = [datetime]::new(1970, 1, 1)
        Write-Host "[+] No StartDate specified or 'All Time' requested - scanning all available data" -ForegroundColor Yellow
    }

    # Convert dates to datetime objects
    try {
        $parsedStartDate = ConvertTo-DateTime -InputValue $StartDate
        $parsedEndDate = ConvertTo-DateTime -InputValue $EndDate
        
        # Validate date range
        if ($parsedStartDate -gt $parsedEndDate) {
            Write-Error "StartDate ($parsedStartDate) cannot be after EndDate ($parsedEndDate)"
            return
        }
    }
    catch {
        Write-Error "Invalid date format: $($_.Exception.Message)"
        return
    }
    
    # Validate MaxRows upper limit to prevent browser crashes
    if ($MaxRows -gt 50000) {
        Write-Warning "MaxRows set to $MaxRows which may cause browser performance issues. Consider using a lower value."
        Write-Warning "Proceeding with MaxRows = $MaxRows (use Settings tab in HTML report to adjust)"
    }
    
    # Validate MaxChars
    if ($MaxChars -lt 10) {
        Write-Warning "MaxChars must be at least 10. Setting to 10."
        $MaxChars = 10
    }
    
    # Validate LoadToolPath usage
    if (![string]::IsNullOrWhiteSpace($LoadToolPath) -and -not $LoadBrowserTool) {
        Write-Error "LoadToolPath specified but LoadBrowserTool switch not set. Use -LoadBrowserTool to enable LoadTool mode."
        return
    }
    
    # Validate and expand LoadToolPath if provided
    if ($LoadBrowserTool -and ![string]::IsNullOrWhiteSpace($LoadToolPath)) {
        try {
            # Expand environment variables
            $LoadToolPath = [System.Environment]::ExpandEnvironmentVariables($LoadToolPath)
            
            # Resolve to absolute path if relative
            if (-not [System.IO.Path]::IsPathRooted($LoadToolPath)) {
                $currentPath = Get-Location
                $LoadToolPath = Join-Path $currentPath.Path $LoadToolPath
            }
            
            # Normalize path
            $LoadToolPath = [System.IO.Path]::GetFullPath($LoadToolPath)
            
            # Validate file exists
            if (-not (Test-Path $LoadToolPath)) {
                Write-Error "LoadToolPath specified but file not found: $LoadToolPath"
                Write-Host "[!] Resolved path: $LoadToolPath" -ForegroundColor Yellow
                Write-Host "[!] Current directory: $(Get-Location)" -ForegroundColor Yellow
                return
            }
            
            Write-Host "[+] LoadToolPath resolved to: $LoadToolPath" -ForegroundColor Green
        }
        catch {
            Write-Error "Failed to resolve LoadToolPath: $($_.Exception.Message)"
            return
        }
    }
    
    Write-Host ""
    Write-Host "[!] FORENSIC DUMP INITIATED" -ForegroundColor Red -BackgroundColor Black
    Write-Host "[+] Output Directory: $OutputDir" -ForegroundColor Green
    Write-Host "[+] Mode: $(if ($Aggressive) { 'Aggressive' } else { 'Auto' })" -ForegroundColor Green
    Write-Host "[+] Date Range: $parsedStartDate to $parsedEndDate" -ForegroundColor Green
    Write-Host ""
    
    $progressTimes = @{}
    
    # Create subdirectories
    $csvDir = Join-Path $OutputDir "ForensicData_CSV"
    New-Item -Path $csvDir -ItemType Directory -Force | Out-Null

    $jsonDir = Join-Path $OutputDir "JSON_Files"
    New-Item -Path $jsonDir -ItemType Directory -Force | Out-Null
    
    # Initialize data collection results
    $forensicData = @{
        SystemInfo  = $null
        Persistence = $null
        Files       = $null
        Registry    = $null
        Browser     = $null
        Logs        = $null
        Services    = $null
        Tasks       = $null
    }
    
    # Determine which modules to run based on Config
    $runAll = $Config -contains 'All'
    $runPersistence = $runAll -or ($Config -contains 'Persistence')
    $runFiles = $runAll -or ($Config -contains 'Files')
    $runRegistry = $runAll -or ($Config -contains 'Registry')
    $runBrowser = $runAll -or ($Config -contains 'Browser')
    $runLogs = $runAll -or ($Config -contains 'Logs')
    $runServices = $runAll -or ($Config -contains 'Services')
    $runTasks = $runAll -or ($Config -contains 'Tasks')

    Write-Host "[+] Active modules: $(if ($runAll) { 'All' } else { ($Config -join ', ') })" -ForegroundColor Green
    
    # Collect System Information (always runs)
    Update-ProgressWithEstimate -Activity "Forensic Dump" -StepTimes ([ref]$progressTimes) -Status "Collecting system information..." -PercentComplete 5
    Write-Host "[+] Collecting system information..." -ForegroundColor Yellow
    $forensicData.SystemInfo = Get-SystemInformation -OutputDir $csvDir
    
    # Collect Persistence Data
    if ($runPersistence) {
        Update-ProgressWithEstimate -Activity "Forensic Dump" -StepTimes ([ref]$progressTimes) -Status "Analyzing persistence mechanisms..." -PercentComplete 15
        Write-Host "[+] Analyzing persistence mechanisms..." -ForegroundColor Yellow
        try {
            # Note: Flags are preserved as-is from Hunt-Persistence output
            # No default flags are added - only original flags are displayed
            $persistenceParams = @{
                All       = $true
                PassThru  = $true
                Quiet     = $true
                OutputCSV = Join-Path $csvDir "Persistence.csv"
            }
            
            $persistenceResults = Hunt-Persistence @persistenceParams
            
            # Use Flag field as-is from Hunt-Persistence output
            # No normalization or default values - preserve original flags only
            if ($persistenceResults -and $persistenceResults.Count -gt 0) {
                $flaggedCount = 0
                $noFlagCount = 0
                
                foreach ($item in $persistenceResults) {
                    $flagProp = $item.PSObject.Properties['Flag']
                    
                    if ($null -ne $flagProp -and ![string]::IsNullOrWhiteSpace($flagProp.Value)) {
                        $flaggedCount++
                    }
                    else {
                        $noFlagCount++
                    }
                }
                
                if ($flaggedCount -gt 0) {
                    Write-Host "  [-] $flaggedCount persistence items have flags from Hunt-Persistence" -ForegroundColor DarkGray
                }
                if ($noFlagCount -gt 0) {
                    Write-Host "  [-] $noFlagCount persistence items have no flags (will display empty)" -ForegroundColor DarkGray
                }
            }
            
            $forensicData.Persistence = $persistenceResults
        }
        catch {
            Write-Warning "Persistence collection failed: $($_.Exception.Message)"
            $forensicData.Persistence = @()
        }
    }
    else {
        Write-Host "[SKIP] Persistence analysis (not in Config)" -ForegroundColor DarkGray
        $forensicData.Persistence = @()
    }
    
    # Collect File System Data
    if ($runFiles) {
        Update-ProgressWithEstimate -Activity "Forensic Dump" -StepTimes ([ref]$progressTimes) -Status "Scanning file system..." -PercentComplete 25
        Write-Host "[+] Scanning file system..." -ForegroundColor Yellow
        try {
            $fileParams = @{
                StartDate = $parsedStartDate
                EndDate   = $parsedEndDate
                PassThru  = $true
                Quiet     = $true
                OutputCSV = Join-Path $csvDir "Files_All.csv"
                Path      = "C:\"
            }
    
            if ($Aggressive) {
                $fileParams['IncludeSystemFolders'] = $true
            }
            
            Write-Host "  [-] Performing main file system scan..." -ForegroundColor DarkGray
            
            try {
                $allFiles = Hunt-Files @fileParams
            }
            catch {
                Write-Host "  [!] File system scan encountered errors: $($_.Exception.Message)" -ForegroundColor Yellow
                Write-Verbose "File scan error details: $($_.Exception.ToString())"
                $allFiles = @()
            }
    
            Write-Host "  [-] Filtering recycled files from cache..." -ForegroundColor DarkGray
            $recycledFiles = @($allFiles | Where-Object { $null -ne $_ -and $_.PSObject.Properties['IsRecycleBin'] -and $_.IsRecycleBin -eq $true })

            Write-Host "  [-] Filtering files with alternate data streams from cache..." -ForegroundColor DarkGray
            $adsFiles = @($allFiles | Where-Object { $null -ne $_ -and $_.PSObject.Properties['AlternateStreamCount'] -and $_.AlternateStreamCount -gt 0 })
    
            if ($recycledFiles -and $recycledFiles.Count -gt 0) {
                $recycledFiles | Export-Csv -Path (Join-Path $csvDir "Files_Recycled.csv") -NoTypeInformation -ErrorAction SilentlyContinue
            }
            if ($adsFiles -and $adsFiles.Count -gt 0) {
                $adsFiles | Export-Csv -Path (Join-Path $csvDir "Files_ADS.csv") -NoTypeInformation -ErrorAction SilentlyContinue
            }
    
            $forensicData.Files = @{
                All      = $allFiles
                Recycled = $recycledFiles
                ADS      = $adsFiles
            }
        }
        catch {
            Write-Warning "File system scan failed: $($_.Exception.Message)"
            $forensicData.Files = @{ All = @(); Recycled = @(); ADS = @() }
        }
    }
    else {
        Write-Host "[SKIP] File system scan (not in Config)" -ForegroundColor DarkGray
        $forensicData.Files = @{ All = @(); Recycled = @(); ADS = @() }
    }
    
    # Collect Registry Data
    if ($runRegistry) {
        Update-ProgressWithEstimate -Activity "Forensic Dump" -StepTimes ([ref]$progressTimes) -Status "Analyzing registry..." -PercentComplete 35
        Write-Host "[+] Analyzing registry..." -ForegroundColor Yellow
        try {
            $forensicData.Registry = Invoke-RegistryForensics -OutputDir $csvDir
            
            if ($null -eq $forensicData.Registry) {
                $forensicData.Registry = @()
                Write-Host "  [!] No registry data returned" -ForegroundColor Yellow
            }
            else {
                Write-Host "  [+] Collected $($forensicData.Registry.Count) registry entries" -ForegroundColor Green
            }
        }
        catch {
            Write-Host "  [!] Registry analysis error: $($_.Exception.Message)" -ForegroundColor Red
            $forensicData.Registry = @()
        }
    }
    else {
        Write-Host "[SKIP] Registry analysis (not in Config)" -ForegroundColor DarkGray
        $forensicData.Registry = @()
    }
    
    # Collect Browser Data
    if ($runBrowser) {
        Update-ProgressWithEstimate -Activity "Forensic Dump" -StepTimes ([ref]$progressTimes) -Status "Extracting browser history..." -PercentComplete 45
        Write-Host "[+] Extracting browser history..." -ForegroundColor Yellow
    
        # Recommend LoadTool if not using it
        if (-not $LoadBrowserTool) {
            Write-Host "  [i] TIP: Use -LoadBrowserTool for complete and accurate browser history extraction" -ForegroundColor Cyan
        }
        try {
            $browserParams = @{
                PassThru  = $true
                Quiet     = $true
                OutputCSV = Join-Path $csvDir "Browser.csv"
            }
            
            # Handle LoadTool mode based on LoadBrowserTool switch and LoadToolPath
            if ($LoadBrowserTool) {
                $browserParams['LoadTool'] = $true
                $browserParams['SkipConfirmation'] = $true 
                
                if (![string]::IsNullOrWhiteSpace($LoadToolPath)) {
                    # Local path provided
                    Write-Host "  [-] Using LoadTool mode with path: $LoadToolPath" -ForegroundColor DarkGray
                    $browserParams['LoadToolPath'] = $LoadToolPath
                }
                else {
                    # No path provided - will download
                    Write-Host "  [-] Using LoadTool mode (via NirSoft internet download)..." -ForegroundColor DarkGray
                }
            }
            elseif ($Aggressive) {
                $browserParams['All'] = $true
            }
            else {
                $browserParams['Auto'] = $true
            }
            
            $browserResults = Hunt-Browser @browserParams -Verbose:$false 6>$null

            
            # Clear progress bars with error handling
            $progressActivities = @(
                "Hunt-Browser Analysis",
                "Hunt-Browser",
                "Browser History Extraction",
                "Initializing",
                "Processing",
                "Extracting Browser History",
                "Loading Tool",
                "Download",
                "Analyzing"
            )
            
            try {
                foreach ($activity in $progressActivities) {
                    Write-Progress -Activity $activity -Completed -ErrorAction SilentlyContinue
                }
                
                # Force UI refresh
                Start-Sleep -Milliseconds 50
                foreach ($activity in $progressActivities) {
                    Write-Progress -Activity $activity -Completed -ErrorAction SilentlyContinue
                }
            }
            catch {
                Write-Verbose "Could not clear all progress bars: $($_.Exception.Message)"
            }
            
            # Force UI refresh with multiple cycles
            Start-Sleep -Milliseconds 50
            foreach ($activity in $progressActivities) {
                Write-Progress -Activity $activity -Completed -ErrorAction SilentlyContinue
            }
            Start-Sleep -Milliseconds 50
            
            # Assign results with proper type handling
            if ($null -eq $browserResults) {
                $forensicData.Browser = @()
                Write-Host "  [!] No browser data returned" -ForegroundColor Yellow
            }
            else {
                try {
                    # Normalize to array regardless of input type
                    if ($browserResults -is [array] -or $browserResults -is [System.Collections.Generic.List[PSObject]]) {
                        $forensicData.Browser = $browserResults
                        Write-Host "  [+] Collected $($browserResults.Count) browser entries" -ForegroundColor Green
                    }
                    else {
                        # Single object - wrap in array
                        $forensicData.Browser = @($browserResults)
                        Write-Host "  [+] Collected 1 browser entry" -ForegroundColor Green
                    }
                }
                catch {
                    Write-Warning "Error processing browser results: $($_.Exception.Message)"
                    $forensicData.Browser = @()
                }
            }
        }
        catch {
            Write-Host "  [!] Browser history extraction error: $($_.Exception.Message)" -ForegroundColor Red
            Write-Host "  [!] Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Red
            $forensicData.Browser = @()
        }
    }
    else {
        Write-Host "[SKIP] Browser history extraction (not in Config)" -ForegroundColor DarkGray
        $forensicData.Browser = @()
    }
    # Collect Event Logs
    if ($runLogs) {
        Update-ProgressWithEstimate -Activity "Forensic Dump" -StepTimes ([ref]$progressTimes) -Status "Analyzing event logs..." -PercentComplete 55
        Write-Host "[+] Analyzing event logs..." -ForegroundColor Yellow
        try {
            $logParams = @{
                StartDate = $parsedStartDate
                EndDate   = $parsedEndDate
                SortOrder = "NewestFirst"
                PassThru  = $true
                Quiet     = $true
                OutputCSV = Join-Path $csvDir "EventLogs.csv"
            }
    
            if ($Aggressive) {
                # Aggressive mode: search all logs without filters
                Write-Host "  [-] Running in Aggressive mode (all logs)..." -ForegroundColor DarkGray
            }
            else {
                # Auto mode: core logs + custom logs + specific Microsoft logs
                Write-Host "  [-] Running in Auto mode (core + custom logs)..." -ForegroundColor DarkGray
                
                $coreLogNames = @(
                    "PowerShell",
                    "Microsoft-Windows-PowerShell/Operational",
                    "System",
                    "Security",
                    "Application"
                )
                
                # Add specific Microsoft Windows logs
                $specificMicrosoftLogs = @(
                    "Microsoft-Windows-SMBClient/Connectivity",
                    "Microsoft-Windows-SMBClient/Operational",
                    "Microsoft-Windows-SMBClient/Security",
                    "Microsoft-Windows-SMBDirect/Admin",
                    "Microsoft-Windows-SMBServer/Connectivity",
                    "Microsoft-Windows-SMBServer/Operational",
                    "Microsoft-Windows-SMBServer/Security",
                    "Microsoft-Windows-SMBWitnessClient/Admin",
                    "Microsoft-Windows-SMBWitnessClient/Informational",
                    "Microsoft-Windows-SmartScreen/Debug",
                    "Microsoft-Windows-TaskScheduler/Maintenance",
                    "Microsoft-Windows-TaskScheduler/Operational",
                    "Microsoft-Windows-TerminalServices-LocalSessionManager/Admin",
                    "Microsoft-Windows-TerminalServices-LocalSessionManager/Operational",
                    "Microsoft-Windows-Windows Defender/Operational",
                    "Microsoft-Windows-Windows Defender/WHC",
                    "Microsoft-Windows-WMI-Activity/Operational",
                    "Microsoft-Windows-Security-Kerberos/Operational",
                    "Microsoft-Windows-RemoteApp and Desktop Connections/Admin",
                    "Microsoft-Windows-RemoteApp and Desktop Connections/Operational",
                    "Microsoft-Windows-PowerShell-DesiredStateConfiguration-FileDownloadManager/Operational",
                    "Microsoft-Windows-RemoteDesktopServices-RdpCoreTS/Admin",
                    "Microsoft-Windows-RemoteDesktopServices-RdpCoreTS/Operational",
                    "Microsoft-Windows-TerminalServices-RemoteConnectionManager/Admin",
                    "Microsoft-Windows-TerminalServices-RemoteConnectionManager/Operational"
                )
                
                # Get custom (non-Microsoft) logs from Applications and Services Logs
                $customLogs = @()
                try {
                    Write-Host "  [-] Enumerating custom log providers..." -ForegroundColor DarkGray
                    $allLogs = Get-WinEvent -ListLog * -ErrorAction SilentlyContinue
                    if ($allLogs) {
                        # Get all logs in Applications and Services Logs that are NOT Microsoft or built-in Windows logs
                        # This captures custom application log providers regardless of their nested folder structure
                        $customLogs = $allLogs | Where-Object { 
                            # Check if it's in Applications and Services Logs
                            $_.LogName -like "Applications and Services Logs/*" -and 
                            # Exclude Microsoft logs
                            $_.LogName -notlike "*Microsoft*" -and 
                            $_.LogName -notlike "*Windows*" -and
                            # Exclude known built-in logs
                            $_.LogName -notlike "*Hardware Events*" -and
                            $_.LogName -notlike "*Internet Explorer*" -and
                            $_.LogName -notlike "*Key Management Service*" -and
                            # Only include logs with records
                            $_.RecordCount -gt 0 -and
                            # Make sure the log is enabled and accessible
                            $_.IsEnabled -eq $true
                        } | Select-Object -ExpandProperty LogName
                        
                        if ($customLogs -and $customLogs.Count -gt 0) {
                            Write-Host "  [-] Found $($customLogs.Count) custom log providers (non-Microsoft/non-built-in)" -ForegroundColor DarkGray
                            # Optionally log first few custom providers for verification
                            if ($customLogs.Count -le 5) {
                                $customLogs | ForEach-Object { Write-Host "      - $_" -ForegroundColor DarkGray }
                            }
                            else {
                                $customLogs | Select-Object -First 3 | ForEach-Object { Write-Host "      - $_" -ForegroundColor DarkGray }
                                Write-Host "      - ... and $($customLogs.Count - 3) more" -ForegroundColor DarkGray
                            }
                        }
                    }
                }
                catch {
                    Write-Host "  [!] Warning: Could not enumerate custom logs - $($_.Exception.Message)" -ForegroundColor Yellow
                    Write-Verbose "Custom log enumeration error: $($_.Exception.Message)"
                }
                
                # Combine all log names
                $logParams['LogNames'] = $coreLogNames + $specificMicrosoftLogs + $customLogs | Select-Object -Unique
                
                Write-Host "  [-] Monitoring $($logParams['LogNames'].Count) log providers" -ForegroundColor DarkGray
            }
            
            $forensicData.Logs = Hunt-Logs @logParams

            if ($null -eq $forensicData.Logs) {
                $forensicData.Logs = @()
                Write-Host "  [!] No logs returned from Hunt-Logs" -ForegroundColor Yellow
            }
            else {
                Write-Host "  [+] Collected $($forensicData.Logs.Count) log entries" -ForegroundColor Green
            }
        }
        catch {
            Write-Host "  [!] Event log analysis error: $($_.Exception.Message)" -ForegroundColor Red
            $forensicData.Logs = @()
        }
    }
    else {
        Write-Host "[SKIP] Event log analysis (not in Config)" -ForegroundColor DarkGray
        $forensicData.Logs = @()
    }
    
    # Collect Services
    if ($runServices) {
        Update-ProgressWithEstimate -Activity "Forensic Dump" -StepTimes ([ref]$progressTimes) -Status "Enumerating services..." -PercentComplete 70
        Write-Host "[+] Enumerating services..." -ForegroundColor Yellow
        try {
            $serviceParams = @{
                PassThru  = $true
                Quiet     = $true
                OutputCSV = Join-Path $csvDir "Services.csv"
            }
            
            $forensicData.Services = Hunt-Services @serviceParams
        }
        catch {
            Write-Warning "Service enumeration failed: $($_.Exception.Message)"
            $forensicData.Services = @()
        }
    }
    else {
        Write-Host "[SKIP] Service enumeration (not in Config)" -ForegroundColor DarkGray
        $forensicData.Services = @()
    }
    
    # Collect Scheduled Tasks
    if ($runTasks) {
        Update-ProgressWithEstimate -Activity "Forensic Dump" -StepTimes ([ref]$progressTimes) -Status "Analyzing scheduled tasks..." -PercentComplete 80
        Write-Host "[+] Analyzing scheduled tasks..." -ForegroundColor Yellow
        try {
            $taskParams = @{
                PassThru        = $true
                Quiet           = $true
                OutputCSV       = Join-Path $csvDir "ScheduledTasks.csv"
                IncludeDisabled = $true
            }
            
            $taskResults = Hunt-Tasks @taskParams
            
            # Remove TriggerType field and clean up TriggerTypes field
            if ($taskResults -and $taskResults.Count -gt 0) {
                foreach ($task in $taskResults) {
                    # Remove TriggerType field completely if it exists
                    if ($task.PSObject.Properties['TriggerType']) {
                        $task.PSObject.Properties.Remove('TriggerType')
                    }
                    
                    # Clean up TriggerTypes field (note the 's' at the end)
                    if ($task.PSObject.Properties['TriggerTypes']) {
                        $triggerValue = $task.TriggerTypes
                        
                        # Handle null or empty
                        if ($null -eq $triggerValue -or [string]::IsNullOrWhiteSpace($triggerValue.ToString())) {
                            $task.TriggerTypes = $null
                            continue
                        }
                        
                        # Convert to string and clean
                        $triggerStr = $triggerValue.ToString().Trim()
                        
                        # Check if it's just commas and spaces
                        if ($triggerStr -match '^[\s,]+$') {
                            $task.TriggerTypes = $null
                            continue
                        }
                        
                        # Split by comma and clean each part
                        $parts = $triggerStr -split ',' | Where-Object { 
                            ![string]::IsNullOrWhiteSpace($_) 
                        } | ForEach-Object { $_.Trim() } | Select-Object -Unique
                        
                        # Remove duplicates and rejoin
                        if ($parts -and $parts.Count -gt 0) {
                            $task.TriggerTypes = ($parts -join ', ')
                        }
                        else {
                            $task.TriggerTypes = $null
                        }
                    }
                }
            }
            
            $forensicData.Tasks = $taskResults
        }
        catch {
            Write-Warning "Scheduled task analysis failed: $($_.Exception.Message)"
            $forensicData.Tasks = @()
        }
    }
    else {
        Write-Host "[SKIP] Scheduled task analysis (not in Config)" -ForegroundColor DarkGray
        $forensicData.Tasks = @()
    }

    # Export JSON data for HTML report
    Update-ProgressWithEstimate -Activity "Forensic Dump" -StepTimes ([ref]$progressTimes) -Status "Exporting JSON data..." -PercentComplete 85
    Write-Host "[+] Exporting JSON data for interactive report..." -ForegroundColor Yellow
    try {
        Export-ForensicJSON -OutputDir $OutputDir -ForensicData $forensicData
    }
    catch {
        Write-Warning "JSON export failed: $($_.Exception.Message)"
        Write-Host "  [!] HTML report may have limited functionality without JSON data" -ForegroundColor Yellow
        # Continue execution - CSV files are still available
    }
    
    # Generate HTML Report
    Update-ProgressWithEstimate -Activity "Forensic Dump" -StepTimes ([ref]$progressTimes) -Status "Generating HTML report..." -PercentComplete 90
    Write-Host "[+] Generating interactive HTML report..." -ForegroundColor Yellow

    # ADDED: Warn about large datasets
    $totalRecords = $stats.Persistence + $stats.Files + $stats.Registry + $stats.Browser + $stats.Logs + $stats.Services + $stats.Tasks
    if ($totalRecords -gt 100000) {
        Write-Warning "Large dataset detected ($totalRecords total records). HTML report may be very large."
        Write-Warning "Generating report - this may take several minutes..."
    }
    
    try {
        $htmlPath = Join-Path $OutputDir "ForensicReport.html"

        $htmlMaxChars = $MaxChars
        $htmlMaxRows = $MaxRows
        $htmlAllFields = $AllFields

        Generate-HTMLReport -ForensicData $forensicData -OutputPath $htmlPath -CSVDir $csvDir `
            -StartDate $parsedStartDate -EndDate $parsedEndDate -Mode $(if ($Aggressive) { "Aggressive" } else { "Auto" }) `
            -MaxChars $htmlMaxChars -MaxRows $htmlMaxRows -AllFields:$htmlAllFields
    }
    catch {
        Write-Warning "HTML report generation failed: $($_.Exception.Message)"
    }
    
    Write-Progress -Activity "Forensic Dump" -Completed
    
    # Display completion summary
    $endTime = Get-Date
    $duration = $endTime - $script:StartTime
    
    # Update HTML report with actual runtime
    try {
        $htmlPath = Join-Path $OutputDir "ForensicReport.html"
        if (Test-Path $htmlPath) {
            $htmlContent = Get-Content -Path $htmlPath -Raw
            $runtimeText = "$($duration.Hours)h $($duration.Minutes)m $($duration.Seconds)s"
            $htmlContent = $htmlContent -replace '<span class="export-info-value" id="runtime-display">Calculating\.\.\.</span>', "<span class='export-info-value' id='runtime-display'>$runtimeText</span>"
            $htmlContent | Set-Content -Path $htmlPath -Encoding UTF8
        }
    }
    catch {
        Write-Verbose "Could not update runtime in HTML report"
    }
    
    Write-Host ""
    Write-Host "[!] FORENSIC DUMP COMPLETE" -ForegroundColor Red -BackgroundColor Black
    Write-Host "[+] Total Runtime: $($duration.Hours)h $($duration.Minutes)m $($duration.Seconds)s" -ForegroundColor Yellow
    Write-Host "[+] Output Directory: $OutputDir" -ForegroundColor Green
    Write-Host "[+] Forensic Report: $(Join-Path $OutputDir 'ForensicReport.html')" -ForegroundColor Green
    Write-Host "[+] Raw Data Exports: $(Join-Path $OutputDir 'ForensicData_CSV')" -ForegroundColor Green
    #Write-Host "[+] HTML Data: $(Join-Path $OutputDir 'JSON_Files')" -ForegroundColor Green
    
    if ($ExportLogs) {
        Write-Host "[+] EVTX Export: $(Join-Path $OutputDir 'EVTX_Export')" -ForegroundColor Green
    }
    
    Write-Host ""
}


Function Hunt-Persistence {
    [CmdletBinding()]
    <#
.SYNOPSIS
Hunts for Windows persistence mechanisms across registry, services, tasks, and file system locations.

.DESCRIPTION
Hunt-Persistence performs comprehensive detection of Windows persistence techniques including registry run keys, 
scheduled tasks, services, WMI subscriptions, and dozens of other persistence vectors. Supports multiple 
detection modes from high-fidelity auto mode to comprehensive aggressive scanning.

.PARAMETER Technique
Specifies which persistence techniques to search. Default is 'All' to check all techniques.
Valid values include specific techniques like 'RegistryRunKeys', 'ScheduledTasks', 'Services', etc.

.PARAMETER Search
Array of custom strings to add to suspicious indicator checks.

.PARAMETER Exclude
Hashtable for excluding results. Key=string to match, Value=field name to match against.

.PARAMETER OutputCSV
Path for CSV export. Can be file path or directory (auto-generates filename with timestamp).

.PARAMETER Auto
High-fidelity mode focusing on clearly suspicious items (default behavior).

.PARAMETER Aggressive
Broader detection including unsigned binaries and non-standard configurations.

.PARAMETER Insane
Most comprehensive detection when used with -Aggressive. Includes user directory executables.

.PARAMETER All
Returns all discovered persistence mechanisms regardless of suspicion level.

.PARAMETER Quiet
Suppresses console output. Must be used with -OutputCSV or -PassThru.

.PARAMETER More
Displays additional technical details in console output.

.PARAMETER LoadHives
Attempts to mount unloaded user registry hives (requires Administrator).

.PARAMETER PassThru
Returns PowerShell objects for programmatic use.

.EXAMPLE
Hunt-Persistence
Basic scan using auto mode with console output.

.EXAMPLE
Hunt-Persistence -Aggressive -OutputCSV "C:\Reports\persistence.csv" -Quiet
Aggressive scan with CSV export and no console output.

.EXAMPLE
$results = Hunt-Persistence -Auto -PassThru -Quiet
Capture results as PowerShell objects for further analysis.

.EXAMPLE
Hunt-Persistence -Search "ScheduledTasks" -More
Focus only on scheduled tasks with detailed output.

.EXAMPLE
Hunt-Persistence -All -LoadHives -Search @("badware.exe", "malicious.dll")
Comprehensive scan including unloaded user hives and custom indicators.

.NOTES
Requires PowerShell 5.0 or higher. Some techniques require Administrator privileges for full detection.
Use -Aggressive carefully in production as it may generate false positives.

.LINK
https://attack.mitre.org/tactics/TA0003/
#>
    Param(
        [ValidateSet(
            'All', 'RegistryRunKeys', 'ImageFileExecutionOptions', 'NLDPDllOverridePath', 'AeDebug',
            'WerFaultHangs', 'CmdAutoRun', 'ExplorerLoad', 'WinlogonUserinit', 'WinlogonShell',
            'TerminalProfileStartOnUserLogin', 'AppCertDlls', 'ServiceDlls', 'GPExtensionDlls',
            'WinlogonMPNotify', 'CHMHelperDll', 'HHCtrlHijacking', 'StartupPrograms', 'UserInitMprScript',
            'AutodialDLL', 'LsaExtensions', 'ServerLevelPluginDll', 'LsaPasswordFilter',
            'LsaAuthenticationPackages', 'LsaSecurityPackages', 'WinlogonNotificationPackages',
            'ExplorerTools', 'DotNetDebugger', 'ErrorHandlerCmd', 'WMIEventsSubscrition',
            'AppPaths', 'TerminalServicesInitialProgram', 'AccessibilityTools',
            'AMSIProviders', 'PowershellProfiles', 'SilentExitMonitor', 'TelemetryController',
            'RDPWDSStartupPrograms', 'ScheduledTasks', 'BitsJobsNotify', 'Screensaver',
            'PowerAutomate', 'OfficeAddinsAndTemplates', 'Services', 'ExplorerContextMenu',
            'ServiceControlManagerSD', 'OfficeAiHijacking', 'DotNetStartupHooks',
            'SubornerAttack', 'DSRMBackdoor', 'BootVerificationProgram', 'AppInitDLLs', 'BootExecute',
            'NetshHelperDLL', 'SetupExecute', 'PlatformExecute'
        )]
        $Technique = 'All',
    
        [String[]]
        $Search = @(),

        [Hashtable]
        $Exclude = @{},
    
        [String]
        $OutputCSV = $null,

        [Switch]
        $Auto,

        [Switch] 
        $Aggressive,

        [Switch] 
        $Insane,

        [Switch]
        $All,

        [Switch]
        $Quiet,

        [Switch]
        $More,

        [Switch]
        $LoadHives,
    
        [Switch]
        $PassThru
    )

    # Add parameter validation and mode setting
    $modeCount = @($Auto, $Aggressive, $All, $Insane).Where({ $_ }).Count
    if ($modeCount -gt 1) {
        Write-Error "Cannot specify multiple modes. Choose only one: -Auto, -Aggressive, or -All"
        return
    }
    # Set default mode to Auto if none specified
    $Mode = if ($Aggressive -or $Insane) { 'Aggressive' } 
    elseif ($All) { 'All' }
    else { 'Auto' }

    # Improved parameter validation with correct null comparisons
    if ($Quiet -and ([string]::IsNullOrEmpty($OutputCSV)) -and -not $PassThru) {
        Write-Error "The -Quiet parameter can only be used when -OutputCSV or -PassThru is also specified."
        if ($PassThru) { return @() }
        return
    }
    # Check for administrator privileges
    $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")

    if (-not $isAdmin) {
        Write-Warning "Not running as Administrator, insufficient privileges may cause detection issues..."
    }
    else {
        Write-Verbose "Running as Administrator..."
    }

    # OutputCSV parameter validation and path processing
    if ($OutputCSV) {
        try {
            # If it's a directory, create filename
            if (Test-Path $OutputCSV -PathType Container -ErrorAction SilentlyContinue) {
                $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
                $OutputCSV = Join-Path $OutputCSV "Persistence-Report_$timestamp.csv"
            }
            elseif ([System.IO.Path]::GetExtension($OutputCSV) -eq '') {
                # If no extension provided, add .csv
                $OutputCSV = $OutputCSV + '.csv'
            }
        
            # Ensure directory exists
            $outputDir = Split-Path $OutputCSV -Parent
            if ($outputDir -and -not (Test-Path $outputDir -ErrorAction SilentlyContinue)) {
                New-Item -Path $outputDir -ItemType Directory -Force -ErrorAction Stop | Out-Null
            }
        
            # Test write permissions
            $testFile = $OutputCSV + '.tmp'
            'test' | Out-File -FilePath $testFile -ErrorAction Stop
            Remove-Item $testFile -Force -ErrorAction SilentlyContinue
        }
        catch {
            Write-Error "Invalid OutputCSV path or insufficient permissions: $OutputCSV"
            if ($PassThru) { return @() }
            return
        }
    }

    # Process Search parameter - add custom strings to suspicious IOCs
    if ($Search -and $Search.Count -gt 0) {
        Write-Verbose "Adding $($Search.Count) custom strings to suspicious IOCs list..."
    
        # Initialize array if not already initialized
        if (-not $script:SuspiciousStringIOCs) {
            $script:SuspiciousStringIOCs = @()
        }
    
        foreach ($customIOC in $Search) {
            if (![string]::IsNullOrWhiteSpace($customIOC)) {
                $trimmedIOC = $customIOC.Trim()
                # Avoid duplicates
                if ($script:SuspiciousStringIOCs -notcontains $trimmedIOC) {
                    $script:SuspiciousStringIOCs += $trimmedIOC
                }
            }
        }
        Write-Verbose "Total suspicious IOCs after custom additions: $($script:SuspiciousStringIOCs.Count)"
        Write-Verbose "[+] Added $($Search.Count) custom search string(s) to detection logic"
    }

    # Debug: Show what we're searching for
    if ($Search -and $Search.Count -gt 0) {
        Write-Verbose "=== SEARCH DEBUG ==="
        Write-Verbose "Search terms provided: $($Search -join ', ')"
        Write-Verbose "Current SuspiciousStringIOCs array contains: $($script:SuspiciousStringIOCs -join ', ')"
        Write-Verbose "===================="
    }
    # Debug: Verify we're continuing to main execution
    Write-Verbose "=== EXECUTION CHECK ==="
    Write-Verbose "Mode: $Mode"
    Write-Verbose "Technique: $Technique"
    Write-Verbose "About to enter main execution block..."
    Write-Verbose "========================"
    

    # Initialize variables
    $script:globalPersistenceObjectArray = [System.Collections.Generic.List[PSCustomObject]]::new()
    $ErrorActionPreference = 'SilentlyContinue'
    $hostname = ([Net.Dns]::GetHostByName($env:computerName)).HostName
    $psProperties = @('PSChildName', 'PSDrive', 'PSParentPath', 'PSPath', 'PSProvider')
    
    $systemAndUsersHives = [Collections.ArrayList]::new()

    function New-PersistenceObject {
        param(
            [String]$Hostname = $null,
            [String]$Technique = $null, 
            [String]$Classification = $null, 
            [String]$Path = $null, 
            [String]$ExecutePath = $null, 
            [String]$Value = $null, 
            [String]$SHA256 = $null, 
            [String]$AccessGained = $null,
            [String]$Note = $null,
            [String]$Reference = $null,
            [String]$Status = $null  
        )

        # Get executable path for additional analysis
        $trueFilePath = Get-FileFromCommandLine $Value

        # Initialize LNK-specific properties
        $lnkTargetPath = $null
        $lnkTargetHash = $null

        # Check if this is an LNK file and resolve target information
        if ($trueFilePath -and [System.IO.Path]::GetExtension($trueFilePath) -eq '.lnk') {
            $lnkTargetPath = Get-LnkTarget $trueFilePath
            if ($lnkTargetPath) {
                $lnkTargetHash = Get-FileHashSafe $lnkTargetPath
            }
        }

        # Create base persistence object
        $PersistenceObject = [PSCustomObject]@{
            'Hostname'        = $Hostname
            'Technique'       = $Technique
            'Classification'  = $Classification
            'Path'            = $Path
            'Execute Path'    = $trueFilePath
            'Value'           = $Value
            'SHA256'          = if ($SHA256) { $SHA256 } else { Get-FileHashSafe $trueFilePath }
            'Rights'          = $AccessGained
            'Note'            = $Note
            'Reference'       = $Reference
            'Signature'       = if ($lnkTargetPath) { Get-CombinedSignatureInfo $lnkTargetPath } else { Get-CombinedSignatureInfo $trueFilePath }
            'IsBuiltinBinary' = Get-IfBuiltinBinary $trueFilePath
            'IsLolbin'        = Get-IfLolBin $trueFilePath
            'Flag'            = ""
            'Status'          = $Status
        }

        # Add LNK-specific properties if this is an LNK file
        if ($lnkTargetPath -or $lnkTargetHash) {
            $PersistenceObject | Add-Member -NotePropertyName 'LnkTargetPath' -NotePropertyValue $lnkTargetPath
            $PersistenceObject | Add-Member -NotePropertyName 'LnkTargetHash' -NotePropertyValue $lnkTargetHash
        }
        return $PersistenceObject
    }

    # Moved 'Get-FileFromCommandLine' function to script helpers

    function Get-LnkTarget {
        param([String]$LnkPath)
    
        if (-not $LnkPath -or -not (Test-Path $LnkPath -ErrorAction SilentlyContinue)) {
            return $null
        }
    
        if ([System.IO.Path]::GetExtension($LnkPath) -ne '.lnk') {
            return $null
        }
    
        $shell = $null
        $shortcut = $null
        $targetPath = $null
    
        try {
            $shell = New-Object -ComObject WScript.Shell
            $shortcut = $shell.CreateShortcut($LnkPath)
            $targetPath = $shortcut.TargetPath
        
            # Expand environment variables in target path
            if (![string]::IsNullOrWhiteSpace($targetPath)) {
                $targetPath = [System.Environment]::ExpandEnvironmentVariables($targetPath)
                # Verify the target exists
                if (Test-Path $targetPath -ErrorAction SilentlyContinue) {
                    return $targetPath
                }
            }
        
            return $null
        }
        catch {
            Write-Verbose "Error resolving LNK target for '$LnkPath': $($_.Exception.Message)"
            return $null
        }
        finally {
            # Clean up COM objects in finally block to ensure cleanup even on error
            if ($null -ne $shortcut) {
                try {
                    [System.Runtime.Interopservices.Marshal]::ReleaseComObject($shortcut) | Out-Null
                }
                catch {
                    Write-Verbose "Error releasing shortcut COM object: $($_.Exception.Message)"
                }
            }
        
            if ($null -ne $shell) {
                try {
                    [System.Runtime.Interopservices.Marshal]::ReleaseComObject($shell) | Out-Null
                }
                catch {
                    Write-Verbose "Error releasing shell COM object: $($_.Exception.Message)"
                }
            }
        
            # Force garbage collection to ensure COM objects are released
            [System.GC]::Collect()
            [System.GC]::WaitForPendingFinalizers()
        }
    }

    function Get-FileHashSafe {
        param([String]$FilePath)
        if ($null -eq $FilePath -or -not (Test-Path $FilePath -ErrorAction SilentlyContinue)) { 
            return $null 
        }
        try {
            return (Get-FileHash $FilePath -Algorithm SHA256 -ErrorAction Stop).Hash
        }
        catch [System.UnauthorizedAccessException] {
            Write-Verbose "Access denied to file: $FilePath"
            return "ERROR - Access Denied"
        }
        catch [System.IO.IOException] {
            Write-Verbose "File in use or IO error: $FilePath"
            return "ERROR - File In Use"
        }
        catch {
            Write-Verbose "Error accessing file $FilePath : $($_.Exception.Message)"
            return "Error: $($_.Exception.Message)"
        }
    }

    function Get-IfBuiltinBinary {
        param([String]$executable)
        if ($null -eq $executable) { 
            return $false 
        }
    
        if (-not (Test-Path $executable -ErrorAction SilentlyContinue)) {
            Write-Verbose "File not found for OS binary check: $executable"
            return $false
        }
    
        try {
            $authenticode = Get-AuthenticodeSignature $executable -ErrorAction Stop
            return $authenticode.IsOsBinary
        }
        catch [System.UnauthorizedAccessException] {
            Write-Verbose "Access denied checking OS binary status: $executable"
            return $false
        }
        catch [System.IO.IOException] {
            Write-Verbose "File in use checking OS binary status: $executable"
            return $false
        }
        catch { 
            return $false
        }
    }
    function Get-CombinedSignatureInfo {
        param([String]$FilePath)

        if (-not $FilePath) { 
            return "[NO_PATH]"
        }

        # Use Get-Item instead of Test-Path for better reliability with system files
        try {
            $fileExists = Get-Item -LiteralPath $FilePath -ErrorAction Stop
        }
        catch [System.UnauthorizedAccessException] {
            return "[ACCESS_DENIED]"
        }
        catch [System.IO.FileNotFoundException], [System.Management.Automation.ItemNotFoundException] {
            return "[FILE_NOT_FOUND]"
        }
        catch {
            return "[FILE_NOT_FOUND]"
        }

        try {
            $authenticode = Get-AuthenticodeSignature $FilePath -ErrorAction Stop
            $status = $authenticode.Status
    
            if ($status -eq "Valid") {
                if ($authenticode.SignerCertificate) {
                    $cert = $authenticode.SignerCertificate
                    $subject = $cert.Subject
                    $issuer = $cert.Issuer
                    $thumbprint = $cert.Thumbprint
                    $notAfter = $cert.NotAfter
            
                    # Extract Common Name from subject
                    $subjectCN = if ($subject -match 'CN=([^,]+)') { $matches[1].Trim('"') } else { "Unknown" }
            
                    # Extract Common Name from issuer  
                    $issuerCN = if ($issuer -match 'CN=([^,]+)') { $matches[1].Trim('"') } else { "Unknown CA" }
            
                    # Check if certificate is expired
                    $currentDate = Get-Date
                    $isExpired = $currentDate -gt $notAfter
            
                    # Check if it's self-signed
                    $isSelfSigned = $subject -eq $issuer
            
                    # Determine the status tag
                    $statusTag = if ($isExpired) { 
                        "[VALID_EXPIRED]" 
                    }
                    elseif ($isSelfSigned) { 
                        "[VALID_SELF_SIGNED]" 
                    }
                    else { 
                        "[VALID]" 
                    }
            
                    # Format the date as MM-DD-YYYY
                    $formattedDate = $notAfter.ToString('MM-dd-yyyy')
            
                    return "$statusTag Subject: $subjectCN, Issuer: $issuerCN, Thumbprint: $thumbprint, Expires: $formattedDate"
                }
                else {
                    return "[VALID] No Certificate Details Available"
                }
            }
            elseif ($status -eq "NotSigned") {
                return "[NOT_SIGNED]"
            }
            elseif ($status -eq "HashMismatch") {
                return "[INVALID] Hash Mismatch - File Modified After Signing"
            }
            elseif ($status -eq "NotTrusted") {
                if ($authenticode.SignerCertificate) {
                    $cert = $authenticode.SignerCertificate
                    $subject = $cert.Subject
                    $thumbprint = $cert.Thumbprint
            
                    # Extract Common Name from subject
                    $subjectCN = if ($subject -match 'CN=([^,]+)') { $matches[1].Trim('"') } else { "Unknown" }
            
                    return "[NOT_TRUSTED] Subject: $subjectCN, Thumbprint: $thumbprint, Reason: Certificate not trusted by system"
                }
                else {
                    return "[NOT_TRUSTED] No Certificate Details Available"
                }
            }
            elseif ($status -eq "UnknownError") {
                return "[UNKNOWN_ERROR] Unable to verify signature"
            }
            else {
                # Handle any other statuses
                return "[$($status.ToString().ToUpper())] Signature verification failed"
            }
        }
        catch [System.UnauthorizedAccessException] {
            return "[ACCESS_DENIED]"
        }
        catch [System.IO.IOException] {
            return "[FILE_IN_USE]"
        }
        catch {
            return "[ERROR] Exception: $($_.Exception.Message)"
        }
    }
    function Get-IfLolBin {
        param([String]$executable)
        if (-not $executable) { return $false }
    
        [String[]]$lolbins = @(
            "APPINSTALLER.EXE", "ASPNET_COMPILER.EXE", "AT.EXE", "ATBROKER.EXE", "BASH.EXE", 
            "BITSADMIN.EXE", "CERTOC.EXE", "CERTREQ.EXE", "CERTUTIL.EXE", "CMD.EXE", "CMDKEY.EXE", 
            "CMDL32.EXE", "CMSTP.EXE", "CONFIGSECURITYPOLICY.EXE", "CONHOST.EXE", "CONTROL.EXE", 
            "CSC.EXE", "CSCRIPT.EXE", "DATASVCUTIL.EXE", "DESKTOPIMGDOWNLDR.EXE", "DFSVC.EXE", 
            "DIANTZ.EXE", "DISKSHADOW.EXE", "DNSCMD.EXE", "ESENTUTL.EXE", "EVENTVWR.EXE", 
            "EXPAND.EXE", "EXPLORER.EXE", "EXTEXPORT.EXE", "EXTRAC32.EXE", "FINDSTR.EXE", 
            "FINGER.EXE", "FLTMC.EXE", "FORFILES.EXE", "FTP.EXE", "GFXDOWNLOADWRAPPER.EXE", 
            "GPSCRIPT.EXE", "HH.EXE", "IMEWDBLD.EXE", "IE4UINIT.EXE", "IEEXEC.EXE", "ILASM.EXE", 
            "INFDEFAULTINSTALL.EXE", "INSTALLUTIL.EXE", "JSC.EXE", "MAKECAB.EXE", "MAVINJECT.EXE", 
            "MICROSOFT.WORKFLOW.COMPILER.EXE", "MMC.EXE", "MPCMDRUN.EXE", "MSBUILD.EXE", 
            "MSCONFIG.EXE", "MSDT.EXE", "MSHTA.EXE", "MSIEXEC.EXE", "NETSH.EXE", "ODBCCONF.EXE", 
            "OFFLINESCANNERSHELL.EXE", "ONEDRIVESTANDALONEUPDATER.EXE", "PCALUA.EXE", "PCWRUN.EXE", 
            "PKTMON.EXE", "PNPUTIL.EXE", "PRESENTATIONHOST.EXE", "PRINT.EXE", "PRINTBRM.EXE", 
            "PSR.EXE", "RASAUTOU.EXE", "RDRLEAKDIAG.EXE", "REG.EXE", "REGASM.EXE", "REGEDIT.EXE", 
            "REGINI.EXE", "REGISTER-CIMPROVIDER.EXE", "REGSVCS.EXE", "REGSVR32.EXE", "REPLACE.EXE", 
            "RPCPING.EXE", "RUNDLL32.EXE", "RUNONCE.EXE", "RUNSCRIPTHELPER.EXE", "SC.EXE", 
            "SCHTASKS.EXE", "SCRIPTRUNNER.EXE", "SETTINGSYNCHOST.EXE", "STORDIAG.EXE", 
            "SYNCAPPVPUBLISHINGSERVER.EXE", "TTDINJECT.EXE", "TTTRACER.EXE", "VBC.EXE", 
            "VERCLSID.EXE", "WAB.EXE", "WLRMDR.EXE", "WMIC.EXE", "WORKFOLDERS.EXE", "WSCRIPT.EXE", 
            "WSRESET.EXE", "WUAUCLT.EXE", "XWIZARD.EXE", "POWERSHELL.EXE", "WINWORD.EXE", 
            "EXCEL.EXE", "POWERPNT.EXE"
        )
    
        $exe = Split-Path -path $executable -Leaf
        return $lolbins -contains $exe.ToUpper()
    }


    function Test-ShouldIncludeEntry {
        param(
            [Parameter(Mandatory = $true)]
            $PersistenceObject,
    
            [Parameter(Mandatory = $true)]
            [ValidateSet("Auto", "All", "Aggressive")]
            [string]$Mode
        )

        # Initialize flags array to collect reasons for inclusion
        $flags = @()

        # Extract values for analysis - only check specific fields
        $valueToCheck = $PersistenceObject.Value
        $executePathToCheck = $PersistenceObject.'Execute Path'
        $pathToCheck = $PersistenceObject.Path
        $signatureToCheck = $PersistenceObject.Signature
        $techniqueToCheck = $PersistenceObject.Technique

        # NEW: Track if custom search string matched - this bypasses technique filtering
        $customSearchMatched = $false

        # Helper function to check if signature is valid (treats Valid and Valid_Expired as same)
        function Test-ValidSignature {
            param([string]$Signature)
            if (-not $Signature) { return $false }

            #special exception to treat file not found as valid, to temporarily continue forward and ignore.
            if ($Mode -eq "Auto" -and $Signature -eq "[FILE_NOT_FOUND]") { return $true }

            #special exception to treat expired Microsoft signature as valid
            if ($Mode -eq "Auto" -and $Signature -eq "[VALID_EXPIRED]*Issuer: Microsoft*") { return $true }

            # Check for both VALID and VALID_EXPIRED patterns
            return ($Signature -match '\[VALID[^\]]*\]')
        }


        # Helper function to check if signature is from Microsoft
        function Test-MicrosoftSignature {
            param([string]$Signature)
            if (-not $Signature) { return $false }
            return (Test-ValidSignature $Signature) -and ($Signature -like "*Microsoft*")
        }

        # Helper function to check if file is in Windows system directories
        function Test-WindowsSystemPath {
            param([string]$Path)
            if (-not $Path) { return $false }
            $expandedPath = [System.Environment]::ExpandEnvironmentVariables($Path)
            return $expandedPath -like "C:\Windows*"
        }

        # Helper function for App Paths name matching check
        function Test-AppPathsNameMatch {
            param([string]$Path, [string]$Target, [string]$Signature)
            if (-not $Path -or -not $Target) { return $true }
    
            # Extract executable name from registry path (remove \(Default))
            if ($Path -match '\\([^\\]+)\.exe\\') {
                $pathExeName = $matches[1]
            }
            elseif ($Path -match '\\([^\\]+)\\') {
                $pathExeName = $matches[1]
            }
            else { 
                return $true 
            }
    
            # Extract executable name from target (without extension)
            $targetExeName = [System.IO.Path]::GetFileNameWithoutExtension((Split-Path $Target -Leaf))
    
            # Exact match - always good
            if ($pathExeName -eq $targetExeName) { return $true }
    
            # For Microsoft signed binaries, be more lenient
            if (Test-MicrosoftSignature $Signature) {
                $knownRedirections = @{
                    'iediag'    = @('iediagcmd')
                    'mplayer2'  = @('wmplayer', 'mplayer')
                    'wmplayer2' = @('wmplayer')
                    'iexplore'  = @('iexplore')
                }
        
                $pathLower = $pathExeName.ToLower()
                $targetLower = $targetExeName.ToLower()
        
                if ($knownRedirections.ContainsKey($pathLower)) {
                    foreach ($validTarget in $knownRedirections[$pathLower]) {
                        if ($targetLower -eq $validTarget) {
                            return $true
                        }
                    }
                }
            }
    
            # Otherwise, it's a mismatch
            return $false
        }

        # === UNIVERSAL DETECTION LOGIC (ALL MODES) ===

        # 1. Check for suspicious string IOCs in Value and Execute Path
        foreach ($fieldValue in @($valueToCheck, $executePathToCheck, $pathToCheck)) {
            if ($fieldValue) {
                foreach ($ioc in $script:SuspiciousStringIOCs) {
                    if ($fieldValue -like "*$ioc*") {
                        $flags += "SUS_STRING: '$ioc'"
                        $customSearchMatched = $true  # Mark that custom search matched
                        Write-Verbose "MATCH FOUND: IOC '$ioc' matched in field: $fieldValue"
                    }
                }
                if ($customSearchMatched) { break }  # Exit outer loop if matched
            }
        }

        # 2. Check for aggressive string IOCs (Aggressive mode only)
        if ($Mode -eq 'Aggressive' -and $valueToCheck) {
            foreach ($ioc in $script:AggressiveStringIOCs) {
                if ($valueToCheck -like "*$ioc*") {
                    $flags += "SUS_STRING: '$ioc'"
                }
            }
        }

        # 2.5 Check for insane string IOCs (Insane mode only)
        if ($Mode -eq 'Aggressive' -and $valueToCheck -and $Insane) {
            foreach ($ioc in $script:InsaneStringIOCs) {
                if ($valueToCheck -like "*$ioc*") {
                    $flags += "SUS_STRING: '$ioc'"
                }
            }
        }


        # 3. Check for base64 content in Value
        if ($valueToCheck) {
            $base64Result = Test-EncodedContent -InputString $valueToCheck
            if ($base64Result -and $base64Result -ne $false) {
                $flags += "$base64Result"
            }
        }

        # 4. Check for network indicators in Value
        if ($valueToCheck) {
            $networkIndicator = Test-NetworkIndicators -InputString $valueToCheck
            if ($networkIndicator) {
                $flags += "NTWRK_STRING: '$networkIndicator'"
            }
        }

        # 5. Check for suspicious file extensions (Aggressive mode only)
        if ($Mode -eq 'Aggressive') {
            foreach ($fieldValue in @($valueToCheck, $executePathToCheck)) {
                if ($fieldValue) {
                    # Extract the actual file extension from the path
                    # Handle cases where there might be arguments after the executable
                    $filePath = $fieldValue
                    
                    # If there are spaces, take the first part (the actual file path)
                    if ($filePath -match '^"?([^"]+\.exe|[^"]+\.dll|[^"]+\.sys|[^\s"]+)"?\s') {
                        $filePath = $matches[1]
                    }
                    elseif ($filePath -match '^([^\s]+)') {
                        $filePath = $matches[1]
                    }
                    
                    # Get the actual file extension
                    try {
                        $actualExtension = [System.IO.Path]::GetExtension($filePath).ToLower()
                        
                        if (![string]::IsNullOrWhiteSpace($actualExtension)) {
                            # Check if this extension is in our suspicious list
                            foreach ($ext in $script:suspiciousFileExt) {
                                $extLower = $ext.ToLower()
                                
                                # Special handling for .js to exclude .json
                                if ($extLower -eq '.js') {
                                    if ($actualExtension -eq '.js') {
                                        $flags += "SUS_EXT: '$ext'"
                                        break
                                    }
                                }
                                elseif ($actualExtension -eq $extLower) {
                                    $flags += "SUS_EXT: '$ext'"
                                    break
                                }
                            }
                        }
                    }
                    catch {
                        Write-Verbose "Error extracting extension from: $fieldValue"
                    }
                }
            }
        }

        # 6. Check for suspicious paths (Aggressive mode only)
        if ($Mode -eq 'Aggressive') {
            foreach ($fieldValue in @($valueToCheck, $executePathToCheck)) {
                if ($fieldValue) {
                    foreach ($path in $script:suspiciousPaths) {
                        if ($fieldValue -like "*$path*") {
                            $flags += "SUS_PATH: '$path'"
                        }
                    }
                }
            }
        }

        # 7. Check for execution binaries in suspicious locations
        foreach ($fieldValue in @($valueToCheck, $executePathToCheck)) {
            if ($fieldValue) {
                foreach ($binary in $script:executionBinaries) {
                    if ($fieldValue -match "(?i)([A-Z]:\\(Users|AppData|Temp)\\.*?\\$binary\b)") {
                        $flags += "SUS_PATH_EXE: $binary"
                    }
                }
            }
        }

        # 8. Check for LNK target analysis
        if ($PersistenceObject.PSObject.Properties['LnkTargetPath'] -and $PersistenceObject.LnkTargetPath) {
            $lnkTarget = $PersistenceObject.LnkTargetPath
    
            # Check LNK target against suspicious strings
            foreach ($ioc in $script:SuspiciousStringIOCs) {
                if ($lnkTarget -like "*$ioc*") {
                    $flags += "LNK_SUS_STRING: '$ioc'"
                }
            }
    
            # Check LNK target for suspicious paths
            foreach ($path in $script:suspiciousPaths) {
                if ($lnkTarget -like "*$path*") {
                    $flags += "LNK_SUS_PATH: '$path'"
                }
            }
        }

        # === TECHNIQUE-SPECIFIC FILTERING LOGIC ===

        $isInWindowsPath = Test-WindowsSystemPath $executePathToCheck
        $isBuiltinBinary = $PersistenceObject.IsBuiltinBinary
        $hasValidSignature = Test-ValidSignature $signatureToCheck
        $hasMicrosoftSignature = Test-MicrosoftSignature $signatureToCheck

        switch ($techniqueToCheck) {
            'Image File Execution Options' {
                # Return ALL entries all the time
                $flags += "IFEO_ENTRY"
            }
    
            'Natural Language Development Platform DLL Override' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "NLDP"
                }
            }
    
            'AEDebug Custom Debugger' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasValidSignature) {
                        $flags += "NOT_SIGNED"
                    }
                    # Check for suspicious paths in auto mode
                    foreach ($path in $script:suspiciousPaths) {
                        if (($valueToCheck -like "*$path*") -or ($pathToCheck -like "*$path*")) {
                            $flags += "SUS_PATH: '$path'"
                            break
                        }
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    if (-not $hasValidSignature) {
                        $flags += "NOT_SIGNED"
                    }
                    if (-not $isInWindowsPath) {
                        $flags += "NON_WINDOWS_PATH"
                    }
                }
            }
    
            'Windows Error Reporting Debugger' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "WER"
                }
            }
    
            'Command Processor AutoRun' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "CMDAUTORUN"
                }
            }
    
            'Explorer Load Property' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "EXPLORER_LOAD"
                }
            }
    
            { $_ -like "*Winlogon Userinit*" } {
                # Flag everything all the time
                $flags += "WINLOGON_USERINIT"
            }
    
            { $_ -like "*Winlogon Shell*" } {
                # Flag everything all the time
                $flags += "WINLOGON_SHELL"
            }
    
            'Windows Terminal startOnUserLogin' {
                # Flag everything all the time
                $flags += "TERMINAL_STARTUP"
            }
    
            'AppCertDlls' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "APPCERTDLL"
                }
            }
            
            'App Paths Hijacking' {
                if ($Mode -eq 'Auto') {
                    # Only flag if names don't match - don't flag just for being unsigned
                    if (-not (Test-AppPathsNameMatch $pathToCheck $valueToCheck $signatureToCheck)) {
                        $flags += "NAME_MISMATCH"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    # Name mismatch check
                    if (-not (Test-AppPathsNameMatch $pathToCheck $valueToCheck $signatureToCheck)) {
                        $flags += "NAME_MISMATCH"
                    }

                    # Check for command line arguments (Value != Path means arguments present)
                    if ($valueToCheck -ne $executePathToCheck -and $valueToCheck -like "* *") {
                        $flags += "HAS_ARGUMENTS"
                    }
                    
                    # Note: Signature checks handled by common additional checks section below
                }
            }
            
            'ServiceDll Hijacking' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasValidSignature -and -not $isBuiltinBinary) {
                        $flags += "UNSIGNED_NON_BUILTIN"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    if (-not $hasValidSignature) {
                        $flags += "NOT_SIGNED"
                    }
                }
            }
    
            'Group Policy Extension DLL' {
                if ($Mode -eq 'Aggressive') {
                    if (-not $hasValidSignature) {
                        $flags += "NOT_SIGNED"
                    }
                }
            }
    
            'Winlogon MPNotify Executable' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasValidSignature) {
                        $flags += "NOT_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "MPNOTIFY"
                }
            }
    
            'CHM Helper DLL' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasValidSignature) {
                        $flags += "NOT_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    if (-not $hasValidSignature -or -not $isBuiltinBinary -or -not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_BUILTIN"
                    }
                }
            }
    
            'hhctrl.ocx Hijacking' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasValidSignature) {
                        $flags += "NOT_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    if (-not $hasValidSignature -or -not $isBuiltinBinary -or -not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_BUILTIN"
                    }
                }
            }
    
            'Startup Folder' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasValidSignature) {
                        $flags += "NOT_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "STARTUP"
                }
            }
    
            'User Init Mpr Logon Script' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasValidSignature) {
                        $flags += "NOT_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "MPLOGON"
                }
            }
    
            'AutodialDLL Winsock Injection' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasValidSignature) {
                        $flags += "NOT_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "AUTODIAL"
                }
            }
    
            'LSA Extensions DLL' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "LSA_EXT"
                }
            }
    
            'ServerLevelPluginDll DNS Hijacking' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "DNS_PLUGIN"
                }
            }
    
            'LSA Password Filter DLL' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "LSA_PWFILTER"
                }
            }
    
            'LSA Authentication Package DLL' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "LSA_AUTH"
                }
            }
    
            'LSA Security Package DLL' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "LSA_SEC"
                }
            }
    
            'Winlogon Notification Package' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "WINLOGON_NOTIFY"
                }
            }
    
            { $_ -like "*DbgManagedDebugger*" } {
                if ($Mode -eq 'Auto') {
                    if (-not $hasValidSignature) {
                        $flags += "NOT_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "DOTNET_DEBUG"
                }
            }
    
            'ErrorHandler.cmd Hijacking' {
                # Flag everything all the time
                $flags += "ERROR_HANDLER"
            }
    
            { $_ -like "*WMI*Event*" } {
                if ($Mode -eq 'Auto') {
                    if (-not $hasValidSignature) {
                        $flags += "NOT_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "WMI"
                }
            }
    
            'Windows Service' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasValidSignature) {
                        $flags += "NOT_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    if (-not $hasValidSignature) {
                        $flags += "NOT_SIGNED"
                    }
                }
            }
    
            'Power Automate' {
                if ($Mode -eq 'Aggressive') {
                    $flags += "POWER_AUTOMATE"
                }
            }
    
            'Terminal Services InitialProgram' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "TS_INITIAL"
                }
            }
    
            'Accessibility Tools Backdoor' {
                # Always return everything (already has filtering built-in)
                $flags += "ACCESS_TOOLS"
            }
    
            'Custom AMSI Provider' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasValidSignature) {
                        $flags += "NOT_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "AMSI"
                }
            }
    
            'PowerShell Profile' {
                # Return all entries always
                $flags += "PS_PROFILE"
            }
    
            'Silent Process Exit Monitor' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "SILENT_EXIT"
                }
            }
    
            'Telemetry Controller Command' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "TELEMETRY"
                }
            }
    
            'RDP WDS Startup Programs' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "RDP_WDS"
                }
            }
    
            'BITS Job NotifyCmdLine' {
                # Return everything
                $flags += "BITS_JOB"
            }
    
            'Screensaver Program' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasValidSignature) {
                        $flags += "NOT_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "SCREENSAVER"
                }
            }
    
            'Office Application Startup' {
                if ($Mode -eq 'Aggressive') {
                    $flags += "OFFICE_STARTUP"
                }
            }
    
            'Explorer Tools Hijacking' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "EXPLORER_TOOLS"
                }
            }
    
            'Explorer Context Menu Hijacking' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "CONTEXT_MENU"
                }
            }
    
            'Service Control Manager Security Descriptor' {
                # Return all results
                $flags += "SCM_SD_MODIFIED"
            }
    
            'Microsoft Office AI.exe Hijacking' {
                if ($Mode -eq 'Aggressive') {
                    $flags += "OFFICE_AI_HIJACK"
                }
            }
    
            '.NET Startup Hooks DLL' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "DOTNET_HOOKS"
                }
            }
    
            'Suborner Attack' {
                if ($Mode -eq 'Aggressive') {
                    $flags += "SUBORNER_ATTACK"
                }
            }
    
            'DSRM Backdoor' {
                if ($Mode -eq 'Aggressive') {
                    $flags += "DSRM_BACKDOOR"
                }
            }
    
            'Boot Verification Program Hijacking' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "BOOT_VERIFY"
                }
            }
    
            { $_ -like "*AppInit*" } {
                # Return all entries always
                $flags += "APPINIT_DLL"
            }
    
            { $_ -like "*BootExecute*" } {
                # Return everything always
                $flags += "BOOT_EXECUTE"
            }
    
            'Netsh Helper DLL' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasValidSignature) {
                        $flags += "NOT_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    if (-not $hasValidSignature -or -not $isBuiltinBinary -or -not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_BUILTIN"
                    }
                }
            }
    
            { $_ -like "*SetupExecute*" } {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "SETUP_EXECUTE"
                }
            }
    
            { $_ -like "*PlatformExecute*" } {
                if ($Mode -eq 'Auto') {
                    if (-not $hasMicrosoftSignature) {
                        $flags += "NOT_MS_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    $flags += "PLATFORM_EXECUTE"
                }
            }
    
            'Scheduled Task' {
                if ($Mode -eq 'Auto') {
                    if (-not $hasValidSignature) {
                        $flags += "NOT_SIGNED"
                    }
                }
                elseif ($Mode -eq 'Aggressive') {
                    if (-not $hasValidSignature) {
                        $flags += "NOT_SIGNED"
                    }
                }
            }
        }

        # === MODE-SPECIFIC DECISION LOGIC ===
        
        # Common additional checks for All and Aggressive modes
        $additionalFlags = @()
        
        if ($Mode -eq 'All' -or $Mode -eq 'Aggressive') {
            # Flag unsigned executables (skip App Paths in non-Insane mode)
            if ($executePathToCheck -and -not $hasValidSignature) {
                if ($PersistenceObject.Technique -notlike "App Paths Hijacking" -or $Insane) {
                    $additionalFlags += "NOT_SIGNED"
                }
            }
            
            # Flag non-Microsoft signed executables in Insane mode
            if ($Insane -and $executePathToCheck -and $hasValidSignature -and -not $hasMicrosoftSignature) {
                # Only add if it's signed but NOT by Microsoft
                $additionalFlags += "NOT_MS_SIGNED"
            }
            
            # Insane mode additional checks (for both All and Aggressive)
            if ($Insane) {
                # Flag executables in user directories
                if ($executePathToCheck -like "*\Users\*" -and $executePathToCheck -notlike "*\Program Files*") {
                    $additionalFlags += "USER_DIR_EXECUTABLE"
                }
                
                # Flag command line execution patterns
                if ($valueToCheck -like "*powershell*" -or $valueToCheck -like "*cmd.exe*") {
                    $additionalFlags += "CMDLINE_EXECUTION"
                }
            }
            
            # Add additional flags to main flags array
            if ($additionalFlags.Count -gt 0) {
                $flags += $additionalFlags
            }
        }
        
        # Set flags on the object once (for all modes)
        $PersistenceObject.Flag = ($flags | Sort-Object -Unique) -join '; '
        
        # Mode-specific return logic
        if ($Mode -eq 'All') {
            # ALL MODE - Return everything with all flags populated
            return $true
        }
        elseif ($Mode -eq 'Auto') {
            # AUTO MODE - High-fidelity, only return clearly suspicious items
            if ($customSearchMatched) {
                return $true
            }
            return $flags.Count -gt 0
        }
        elseif ($Mode -eq 'Aggressive') {
            # AGGRESSIVE MODE - Return items with any flags
            return $flags.Count -gt 0
        }
        
        # Fallback (should never reach here)
        return $false
    }

    function Test-EncodedContent {
        param(
            [Parameter(Mandatory = $true)]
            [string]$InputString
        )
    
        if ([string]::IsNullOrWhiteSpace($InputString)) {
            return $false
        }
    
        # Check for PowerShell encoded command patterns first
        if ($InputString -match '-EncodedCommand\s+([A-Za-z0-9+/]{20,}={0,2})') {
            $base64String = $matches[1]
            $trailing = $base64String.Substring([Math]::Max(0, $base64String.Length - 10))
            return "PS_ENC_CMD -> '$trailing'"
        }
    
        if ($InputString -match '-enc\s+([A-Za-z0-9+/]{20,}={0,2})') {
            $base64String = $matches[1]
            $trailing = $base64String.Substring([Math]::Max(0, $base64String.Length - 10))
            return "PS_ENC -> '$trailing'"
        }
    
        if ($InputString -match '-e\s+([A-Za-z0-9+/]{20,}={0,2})') {
            $base64String = $matches[1]
            $trailing = $base64String.Substring([Math]::Max(0, $base64String.Length - 10))
            return "PS_ENC_SHORT -> '$trailing'"
        }
    
        # Check for hex encoding patterns
        if ($InputString -match '([0-9A-Fa-f]{40,})') {
            $hexString = $matches[1]
            if ($hexString.Length % 2 -eq 0) {
                return "HEX_STRING -> '$($hexString.Substring([Math]::Max(0, $hexString.Length - 10)))'"
            }
        }
    
        # Look for Base64 strings - with better filtering
        if ($InputString -match '([A-Za-z0-9+/]{20,}={0,2})') {
            $possibleB64 = $matches[1]
        
            # Skip if it looks like part of a Windows path or executable name
            if ($InputString -match '\\[^\\]*' + [regex]::Escape($possibleB64) + '[^\\]*\.(exe|dll|sys|bat|cmd|ps1)' -or
                $InputString -match 'C:\\' -or
                $InputString -match 'Program Files' -or
                $InputString -match 'WindowsApps' -or
                $InputString -match 'System32' -or
                $possibleB64 -match '^[a-zA-Z]+$') {
                # Skip if it's just letters (likely part of filename)
                return $false
            }
        
            # Fix Base64 padding if needed
            $paddingNeeded = 4 - ($possibleB64.Length % 4)
            if ($paddingNeeded -ne 4) {
                $possibleB64 += "=" * $paddingNeeded
            }
        
            try {
                $decoded = [System.Convert]::FromBase64String($possibleB64)
                if ($decoded.Length -ge 4) {
                    $trailing = $matches[1].Substring([Math]::Max(0, $matches[1].Length - 10))
                    return "B64_STRING -> '$trailing'"
                }
            }
            catch {
                # If padding fix didn't work, try without the detected string being valid Base64
                # Just flag it as suspicious based on pattern
                if ($matches[1].Length -ge 20) {
                    $trailing = $matches[1].Substring([Math]::Max(0, $matches[1].Length - 10))
                    return "SUSPECTED_B64 -> '$trailing'"
                }
            }
        }
    
        return $false
    }


    # Supporting function: Test for network indicators (domains/IPs) - FIXED
    function Test-NetworkIndicators {
        param(
            [Parameter(Mandatory = $true)]
            [string]$InputString
        )
    
        if ([string]::IsNullOrWhiteSpace($InputString)) { return $null }
    
        $cleanString = $InputString.Trim()
        # Split input by spaces to handle multiple items in one string
        $words = $cleanString -split '\s+'
    
        # First pass - look for IP addresses (higher priority)
        foreach ($word in $words) {
            if ([string]::IsNullOrWhiteSpace($word)) { continue }
        
            $cleanWord = $word.Trim('"', "'", '(', ')', '[', ']')
        
            # IPv4 detection - CHECK FIRST
            if ($cleanWord -match '^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$') {
                return $cleanWord
            }
        
            # IPv6 detection
            if ($cleanWord -match '^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$|^(?:[0-9a-fA-F]{1,4}:)*::(?:[0-9a-fA-F]{1,4}:)*[0-9a-fA-F]{1,4}$') {
                return $cleanWord
            }
        }
    
        # Second pass - look for domains and URLs
        foreach ($word in $words) {
            if ([string]::IsNullOrWhiteSpace($word)) { continue }
        
            $cleanWord = $word.Trim('"', "'", '(', ')', '[', ']')
        
            # Skip obvious files with extensions - exclude .json but flag .js
            if ($cleanWord -match '\.(exe|dll|sys|msi|bat|cmd|ps1|vbs|reg|inf|cab|zip|rar|7z|tar|gz|pdf|docx?|xlsx?|pptx?|txt|log|cfg|conf|xml|json|ini|jpe?g|png|gif|bmp|ico|svg|mp[34]|avi|mov|wmv|py|html|htm|css|php|asp|aspx|lnk|scr|com|cpl|hta|wsf)$') {
                continue
            }
            # Separate check for .js to exclude .json
            if ($cleanWord -match '\.js$' -and $cleanWord -notmatch '\.json$') {
                # This is a .js file, don't skip it
            }
            elseif ($cleanWord -match '\.js') {
                # This might be .json or other, skip it
                continue
            }
        
            # Skip filesystem paths - IMPROVED: Better path detection
            if ($cleanWord -match '^[A-Za-z]:\\|^\\\\|[\\/]') {
                continue
            }
        
            # Skip relative paths and filenames containing backslashes or forward slashes
            if ($cleanWord -match '[\\/]') {
                continue
            }
        
            # Domain detection - IMPROVED: Better validation
            if ($cleanWord -match '^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)*[a-zA-Z]{2,}$') {
                $domain = $cleanWord
                $parts = $domain.Split('.')
            
                # Basic validation
                if ($parts.Count -lt 2 -or $domain.Length -lt 4) { continue }
            
                # Skip if it's all numbers (likely an IP we missed)
                if ($domain -match '^\d+\.\d+') { continue }
            
                # Skip Windows app ID patterns
                if ($parts.Count -eq 2 -and $parts[0] -match '^[A-Z][a-zA-Z]{3,}$' -and $parts[1] -match '^[A-Z][a-zA-Z0-9]{3,}$') { continue }
            
                # ADDED: Skip false positives
                $potentialNetworkFP = @(
                    '^OneNote\.'
                )
            
                $isWindowsApp = $false
                foreach ($pattern in $potentialNetworkFP) {
                    if ($domain -match $pattern) {
                        $isWindowsApp = $true
                        break
                    }
                }
                if ($isWindowsApp) { continue }
            
                return $domain
            }
        
            # URL detection (with protocols)
            if ($cleanWord -match '^(?:https?|ftp|ftps)://[^\s<>"\\]{2,}$') {
                return $cleanWord
            }
        }
    
        return $null
    }

    function Test-ExcludeEntry {
        param($entry)
        foreach ($excludeValue in $Exclude.Keys) {
            $fieldName = $Exclude[$excludeValue]
            if ($entry.PSObject.Properties[$fieldName] -and 
                ($entry.$fieldName -like "*$excludeValue*" -or $entry.$fieldName -eq $excludeValue)) {
                return $true
            }
        }
        return $false
    }

    function Write-ColoredPersistenceResult {
        param($PersistenceObject)
    
        Write-Host ""
        Write-Host "----------------------------------------" -ForegroundColor Gray
        Write-Host "Technique        : " -NoNewline -ForegroundColor Yellow
        Write-Host $PersistenceObject.Technique -ForegroundColor Cyan
    
        if ($More) {
            Write-Host "Classification   : " -NoNewline -ForegroundColor Yellow  
            Write-Host $PersistenceObject.Classification -ForegroundColor DarkGray
        }
    
        Write-Host "Source           : " -NoNewline -ForegroundColor Yellow
        Write-Host $PersistenceObject.Path -ForegroundColor DarkYellow
    
        # Only display Value if it's different from Execute Path
        if ($PersistenceObject.Value -ne $PersistenceObject.'Execute Path') {
            Write-Host "Value            : " -NoNewline -ForegroundColor Yellow
            Write-Host $PersistenceObject.Value -ForegroundColor White
            Write-Host "Path             : " -NoNewline -ForegroundColor Yellow
            Write-Host $PersistenceObject.'Execute Path' -ForegroundColor Red
        }
        else {
            Write-Host "Value            : " -NoNewline -ForegroundColor Yellow
            Write-Host $PersistenceObject.'Execute Path' -ForegroundColor Red
        }

        if (![string]::IsNullOrWhiteSpace($PersistenceObject.Status)) {
            Write-Host "Status           : " -NoNewline -ForegroundColor Yellow
            
            # Color code based on status
            $statusColor = switch -Wildcard ($PersistenceObject.Status) {
                "*Running*" { "Green" }
                "*Stopped*" { "Red" }
                "*Disabled*" { "DarkGray" }
                "*Ready*" { "Green" }
                default { "White" }
            }
            Write-Host $PersistenceObject.Status -ForegroundColor $statusColor
        }
            
        if (![string]::IsNullOrWhiteSpace($PersistenceObject.SHA256)) {
            Write-Host "SHA256           : " -NoNewline -ForegroundColor Yellow
            Write-Host $PersistenceObject.SHA256 -ForegroundColor DarkGray
        }
    
        # Display LNK-specific information if available
        if ($PersistenceObject.PSObject.Properties['LnkTargetPath'] -and 
            ![string]::IsNullOrWhiteSpace($PersistenceObject.LnkTargetPath)) {
            Write-Host "LNK Target       : " -NoNewline -ForegroundColor Yellow
            Write-Host $PersistenceObject.LnkTargetPath -ForegroundColor Red
        }
    
        if ($PersistenceObject.PSObject.Properties['LnkTargetHash'] -and 
            ![string]::IsNullOrWhiteSpace($PersistenceObject.LnkTargetHash)) {
            Write-Host "Target Hash      : " -NoNewline -ForegroundColor Yellow
            Write-Host $PersistenceObject.LnkTargetHash -ForegroundColor DarkGray
        }

        Write-Host "Signature        : " -NoNewline -ForegroundColor Yellow
    
        # Modify signature display based on -More switch
        $signatureToDisplay = $PersistenceObject.Signature
    
        # If -More is NOT used, remove thumbprint from valid signatures
        if (-not $More -and $signatureToDisplay -like "*[VALID]*" -and $signatureToDisplay -like "*Thumbprint:*") {
            # Remove the thumbprint portion from the signature
            $signatureToDisplay = $signatureToDisplay -replace ', Thumbprint: [A-F0-9]+', ''
        }
    
        # Color code based on signature status
        if ($signatureToDisplay -like "*[VALID]*") {
            Write-Host $signatureToDisplay -ForegroundColor White
        }
        elseif ($signatureToDisplay -eq "[NOT_SIGNED]") {
            Write-Host $signatureToDisplay -ForegroundColor White
        }
        elseif ($signatureToDisplay -like "*ERROR*") {
            Write-Host $signatureToDisplay -ForegroundColor White
        }
        else {
            Write-Host $signatureToDisplay -ForegroundColor White
        }

        if (![string]::IsNullOrWhiteSpace($PersistenceObject.Flag)) {
            $flagValue = $PersistenceObject.Flag
            if ($flagValue.Length -gt 100) {
                $flagValue = $flagValue.Substring(0, 100) + "..."
            }
            Write-Host "Flag             : " -NoNewline -ForegroundColor Yellow
            Write-Host $flagValue -ForegroundColor DarkRed
        }

        if ($More) {
            Write-Host "Rights           : " -NoNewline -ForegroundColor Yellow
            Write-Host $PersistenceObject.Rights -ForegroundColor DarkGray
            Write-Host "Hostname         : " -NoNewline -ForegroundColor Yellow
            Write-Host $PersistenceObject.Hostname -ForegroundColor DarkGray
        }

        if ($More) {
            Write-Host "IsBuiltinBinary  : " -NoNewline -ForegroundColor Yellow
            Write-Host $PersistenceObject.IsBuiltinBinary -ForegroundColor DarkGray
            Write-Host "IsLolbin         : " -NoNewline -ForegroundColor Yellow
            Write-Host $PersistenceObject.IsLolbin -ForegroundColor DarkGray
        
            if (![string]::IsNullOrWhiteSpace($PersistenceObject.Note)) {
                Write-Host "Note             : " -NoNewline -ForegroundColor Yellow
                Write-Host $PersistenceObject.Note -ForegroundColor DarkGray
            }
        
            if (![string]::IsNullOrWhiteSpace($PersistenceObject.Reference)) {
                Write-Host "Reference        : " -NoNewline -ForegroundColor Yellow
                Write-Host $PersistenceObject.Reference -ForegroundColor Blue
            }
        }
    }

    # Get Registry Hives using shared helper
    $systemAndUsersHives = Get-RegistryHivesForAnalysis -LoadUnloadedHives:$LoadHives -Quiet:$Quiet


    # PERSISTENCE FUNCTIONS
    # ----------------------

    function Get-RunKeys {
        Write-Verbose "$hostname - Getting Registry Run properties..."
    
        # Define all Run key locations to check
        $runKeyLocations = @(
            # Standard Run keys
            @{
                Path = "SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
                Name = "Registry Run Key"
                Note = "Executables in properties of the Run key are executed when the user logs in or when the machine boots up."
            },
            @{
                Path = "SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"
                Name = "Registry RunOnce Key" 
                Note = "Executables in properties of the RunOnce key are run once when the user logs in or machine boots up, then deleted."
            },
            # RunServices (Windows 9x legacy, but still functional)
            @{
                Path = "SOFTWARE\Microsoft\Windows\CurrentVersion\RunServices"
                Name = "Registry RunServices Key"
                Note = "Legacy Windows 9x services run key - still functional on modern Windows."
            },
            @{
                Path = "SOFTWARE\Microsoft\Windows\CurrentVersion\RunServicesOnce"
                Name = "Registry RunServicesOnce Key"
                Note = "Legacy Windows 9x services run once key - still functional on modern Windows."
            },
            # Policies Run keys (often overlooked)
            @{
                Path = "SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run"
                Name = "Registry Policies Run Key"
                Note = "Run key under Policies - executed during user logon, harder to detect."
            },
            # RunOnceEx (used by Windows Update and installers)
            @{
                Path = "SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx"
                Name = "Registry RunOnceEx Key"
                Note = "Extended RunOnce key used by installers and Windows Update - supports dependencies and ordering."
            },
            # RunEx (used by Windows Update and installers)
            @{
                Path = "SOFTWARE\Microsoft\Windows\CurrentVersion\RunEx"
                Name = "Registry RunEx Key"
                Note = "Extended Run key used by installers and Windows Update - supports dependencies and ordering."
            },
            # WOW64 Run keys (32-bit applications on 64-bit systems)
            @{
                Path = "SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run"
                Name = "Registry WOW64 Run Key"
                Note = "32-bit application Run key on 64-bit systems - executed during user logon."
            },
            @{
                Path = "SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\RunOnce"
                Name = "Registry WOW64 RunOnce Key"
                Note = "32-bit application RunOnce key on 64-bit systems - executed once during user logon."
            },
            # Terminal Services Run keys
            @{
                Path = "SOFTWARE\Microsoft\Windows NT\CurrentVersion\Terminal Server\Install\Software\Microsoft\Windows\CurrentVersion\Run"
                Name = "Registry Terminal Server Run Key"
                Note = "Terminal Server specific Run key - executed during Terminal Server user logon."
            },
            @{
                Path = "SOFTWARE\Microsoft\Windows NT\CurrentVersion\Terminal Server\Install\Software\Microsoft\Windows\CurrentVersion\RunOnce"
                Name = "Registry Terminal Server RunOnce Key"
                Note = "Terminal Server specific RunOnce key - executed once during Terminal Server user logon."
            },
            @{
                Path          = "SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\System"
                Name          = "Winlogon System"
                Note          = "System processes executed during logon - typically blank or lsass.exe."
                IsValueDirect = $true
            }
        )
    
        foreach ($location in $runKeyLocations) {
            foreach ($hive in $systemAndUsersHives) {
                # Skip user hives for system-only keys
                if ($location.SystemOnly -and -not (($hive -like "*HKEY_LOCAL_MACHINE*") -or ($hive -like "*HKEY_USERS\S-1-5-18*") -or ($hive -like "*HKEY_USERS\S-1-5-19*") -or ($hive -like "*HKEY_USERS\S-1-5-20*"))) {
                    continue
                }
            
                $fullPath = "$hive\$($location.Path)"
            
                if ($location.IsValueDirect) {
                    # Handle direct registry values (like Userinit, Shell)
                    $regValue = Get-ItemProperty -Path (Split-Path $fullPath) -Name (Split-Path $fullPath -Leaf) -ErrorAction SilentlyContinue
                    if ($regValue) {
                        $valueName = Split-Path $fullPath -Leaf
                        $actualValue = $regValue.$valueName
                    
                        if ($actualValue -and $actualValue -ne "") {
                            $currentHive = Convert-Path -Path $hive
                            $access = if (($currentHive -eq 'HKEY_LOCAL_MACHINE') -or ($currentHive -eq 'HKEY_USERS\S-1-5-18') -or ($currentHive -eq 'HKEY_USERS\S-1-5-19') -or ($currentHive -eq 'HKEY_USERS\S-1-5-20')) { 'System' } else { 'User' }
                        
                            $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique $location.Name -Classification 'MITRE ATT&CK T1547.001' -Path $fullPath -Value $actualValue -AccessGained $access -Note $location.Note -Reference 'https://attack.mitre.org/techniques/T1547/001/'
                        
                            if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                                $script:globalPersistenceObjectArray.Add($PersistenceObject)
                            }
                        }
                    }
                }
                else {
                    # Handle registry keys with multiple properties
                    $runProps = Get-ItemProperty -Path $fullPath -ErrorAction SilentlyContinue
                    if ($runProps) {
                        foreach ($prop in (Get-Member -MemberType NoteProperty -InputObject $runProps)) {
                            if ($psProperties.Contains($prop.Name)) { continue }
                        
                            $propPath = Convert-Path -Path $runProps.PSPath -ErrorAction SilentlyContinue
                            if ($propPath) {
                                $propPath += '\' + $prop.Name
                            }
                            $currentHive = Convert-Path -Path $hive
                            $access = if (($currentHive -eq 'HKEY_LOCAL_MACHINE') -or ($currentHive -eq 'HKEY_USERS\S-1-5-18') -or ($currentHive -eq 'HKEY_USERS\S-1-5-19') -or ($currentHive -eq 'HKEY_USERS\S-1-5-20')) { 'System' } else { 'User' }
                        
                            $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique $location.Name -Classification 'MITRE ATT&CK T1547.001' -Path $propPath -Value $runProps.($prop.Name) -AccessGained $access -Note $location.Note -Reference 'https://attack.mitre.org/techniques/T1547/001/'
                        
                            if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                                $script:globalPersistenceObjectArray.Add($PersistenceObject)
                            }
                        }
                    }
                }
            }
        }
    }

    function Get-ImageFileExecutionOptions {
        Write-Verbose "$hostname - Getting Image File Execution Options..."
        foreach ($hive in $systemAndUsersHives) {
            $ifeOpts = Get-ChildItem -Path "$hive\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options" -ErrorAction SilentlyContinue
            if ($ifeOpts) {
                foreach ($key in $ifeOpts) {
                    $debugger = Get-ItemProperty -Path Registry::$key -Name Debugger -ErrorAction SilentlyContinue
                    if ($debugger -and $debugger.Debugger) {
                        $propPath = Convert-Path -Path $debugger.PSPath
                        $propPath += '\Debugger'
                    
                        $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Image File Execution Options' -Classification 'MITRE ATT&CK T1546.012' -Path $propPath -Value $debugger.Debugger -AccessGained 'System/User' -Note 'Executables in the Debugger property are run instead of the target program. Access level depends on context of debugged process.' -Reference 'https://attack.mitre.org/techniques/T1546/012/'
                    
                        if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                            $script:globalPersistenceObjectArray.Add($PersistenceObject)
                        }
                    }
                }
            }
        }
    }

    function Get-NLDPDllOverridePath {
        Write-Verbose "$hostname - Getting Natural Language Development Platform DLL path override properties..."
        foreach ($hive in $systemAndUsersHives) {
            $NLDPLanguages = Get-ChildItem -Path "$hive\SYSTEM\CurrentControlSet\Control\ContentIndex\Language" -ErrorAction SilentlyContinue
            if ($NLDPLanguages) {
                foreach ($key in $NLDPLanguages) {
                    $DllOverridePath = Get-ItemProperty -Path Registry::$key -Name *DLLPathOverride -ErrorAction SilentlyContinue
                    if ($DllOverridePath) {
                        $properties = Get-ItemProperty -Path Registry::$key -ErrorAction SilentlyContinue | Select-Object -Property *DLLPathOverride, PS*
                        if ($properties) {
                            foreach ($prop in (Get-Member -MemberType NoteProperty -InputObject $properties)) {
                                if ($psProperties.Contains($prop.Name)) { continue }
                                if (-not $prop.Name.EndsWith('DLLPathOverride')) { continue }
                            
                                $propPath = Convert-Path -Path $properties.PSPath -ErrorAction SilentlyContinue
                                if ($propPath) {
                                    $propPath += '\' + $prop.Name
                                    $currentHive = Convert-Path -Path $hive -ErrorAction SilentlyContinue
                                    $access = if (($currentHive -eq 'HKEY_LOCAL_MACHINE') -or ($currentHive -eq 'HKEY_USERS\S-1-5-18') -or ($currentHive -eq 'HKEY_USERS\S-1-5-19') -or ($currentHive -eq 'HKEY_USERS\S-1-5-20')) { 'System' } else { 'User' }
                                
                                    $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Natural Language Development Platform DLL Override' -Classification 'Hexacorn Technique N.98' -Path $propPath -Value $properties.($prop.Name) -AccessGained $access -Note 'DLLs listed in DLLPathOverride properties are loaded by SearchIndexer.exe for language processing.' -Reference 'https://www.hexacorn.com/blog/2018/12/30/beyond-good-ol-run-key-part-98/'
                                
                                    if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                                        $script:globalPersistenceObjectArray.Add($PersistenceObject)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    function Get-AeDebug {
        Write-Verbose "$hostname - Getting AeDebug properties..."
        foreach ($hive in $systemAndUsersHives) {
            $aeDebugger = Get-ItemProperty -Path "$hive\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug" -Name Debugger -ErrorAction SilentlyContinue
            if ($aeDebugger -and $aeDebugger.Debugger) {
                $propPath = Convert-Path -Path $aeDebugger.PSPath
                $propPath += '\Debugger'
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'AEDebug Custom Debugger' -Classification 'Hexacorn Technique N.4' -Path $propPath -Value $aeDebugger.Debugger -AccessGained 'System/User' -Note "The executable in the Debugger property is run when a process crashes. Access depends on context of debugged process. Visual Studio debugger may be legitimate." -Reference 'https://www.hexacorn.com/blog/2013/09/19/beyond-good-ol-run-key-part-4/'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }

            $aeDebugger = Get-ItemProperty -Path "$hive\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\AeDebug" -Name Debugger -ErrorAction SilentlyContinue
            if ($aeDebugger -and $aeDebugger.Debugger) {
                $propPath = Convert-Path -Path $aeDebugger.PSPath
                $propPath += '\Debugger'
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Wow6432Node AEDebug Custom Debugger' -Classification 'Hexacorn Technique N.4' -Path $propPath -Value $aeDebugger.Debugger -AccessGained 'System/User' -Note "The executable in the Debugger property is run when a 32-bit process crashes on 64-bit system. Access depends on context of debugged process." -Reference 'https://www.hexacorn.com/blog/2013/09/19/beyond-good-ol-run-key-part-4/'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
    }

    function Get-WerFaultHangs {
        Write-Verbose "$hostname - Getting WerFault Hangs registry key properties..."
        foreach ($hive in $systemAndUsersHives) {
            $werfaultDebugger = Get-ItemProperty -Path "$hive\SOFTWARE\Microsoft\Windows\Windows Error Reporting\Hangs" -Name Debugger -ErrorAction SilentlyContinue
            if ($werfaultDebugger -and $werfaultDebugger.Debugger) {
                $propPath = Convert-Path -Path $werfaultDebugger.PSPath
                $propPath += '\Debugger'
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Windows Error Reporting Debugger' -Classification 'Hexacorn Technique N.116' -Path $propPath -Value $werfaultDebugger.Debugger -AccessGained 'System' -Note 'The executable in the Debugger property is spawned by WerFault.exe when a process crashes.' -Reference 'https://www.hexacorn.com/blog/2019/09/20/beyond-good-ol-run-key-part-116/'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }

            $werfaultReflectDebugger = Get-ItemProperty -Path "$hive\SOFTWARE\Microsoft\Windows\Windows Error Reporting\Hangs" -Name ReflectDebugger -ErrorAction SilentlyContinue
            if ($werfaultReflectDebugger -and $werfaultReflectDebugger.ReflectDebugger) {
                $propPath = Convert-Path -Path $werfaultReflectDebugger.PSPath
                $propPath += '\ReflectDebugger'
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Windows Error Reporting ReflectDebugger' -Classification 'Hexacorn Technique N.85' -Path $propPath -Value $werfaultReflectDebugger.ReflectDebugger -AccessGained 'System' -Note 'The executable in the ReflectDebugger property is spawned by WerFault.exe when called with the -pr argument.' -Reference 'https://www.hexacorn.com/blog/2018/08/31/beyond-good-ol-run-key-part-85/'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
    }

    function Get-CmdAutoRun {
        Write-Verbose "$hostname - Getting Command Processor's AutoRun property..."
        foreach ($hive in $systemAndUsersHives) {
            $autorunProperty = Get-ItemProperty -Path "$hive\Software\Microsoft\Command Processor" -Name AutoRun -ErrorAction SilentlyContinue
            if ($autorunProperty -and $autorunProperty.AutoRun) {
                $propPath = Convert-Path -Path $hive -ErrorAction SilentlyContinue
                if ($propPath) {
                    $propPath += "\Software\Microsoft\Command Processor\AutoRun"
                
                    $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Command Processor AutoRun' -Classification 'Uncatalogued Technique N.1' -Path $propPath -Value $autorunProperty.AutoRun -AccessGained 'User' -Note 'The executable in the AutoRun property is run when cmd.exe is spawned without the /D argument.' -Reference 'https://persistence-info.github.io/Data/cmdautorun.html'
                
                    if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                        $script:globalPersistenceObjectArray.Add($PersistenceObject)
                    }
                }
            }
        }
    }

    function Get-ExplorerLoad {
        Write-Verbose "$hostname - Getting Explorer's Load property..."
        foreach ($hive in $systemAndUsersHives) {
            $loadKey = Get-ItemProperty -Path "$hive\Software\Microsoft\Windows NT\CurrentVersion\Windows" -Name Load -ErrorAction SilentlyContinue
            if ($loadKey -and $loadKey.Load) {
                $propPath = Convert-Path -Path $loadKey.PSPath
                $propPath += '\Load'
                $currentHive = Convert-Path -Path $hive
                $access = if (($currentHive -eq 'HKEY_LOCAL_MACHINE') -or ($currentHive -eq 'HKEY_USERS\S-1-5-18') -or ($currentHive -eq 'HKEY_USERS\S-1-5-19') -or ($currentHive -eq 'HKEY_USERS\S-1-5-20')) { 'System' } else { 'User' }
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Explorer Load Property' -Classification 'Uncatalogued Technique N.2' -Path $propPath -Value $loadKey.Load -AccessGained $access -Note 'The executable in the Load property is run by explorer.exe at login time.' -Reference 'https://persistence-info.github.io/Data/windowsload.html'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
    }

    function Get-WinlogonUserinit {
        Write-Verbose "$hostname - Getting Winlogon's Userinit property..."
        foreach ($hive in $systemAndUsersHives) {
            $userinit = Get-ItemProperty -Path "$hive\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name Userinit -ErrorAction SilentlyContinue
            if ($userinit -and $userinit.Userinit) {
                $propPath = Convert-Path -Path $userinit.PSPath
                $propPath += '\Userinit'
            
                # Only flag if not the default value
                if ($userinit.Userinit -ne 'C:\Windows\system32\userinit.exe,') {
                    $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Winlogon Userinit Property' -Classification 'MITRE ATT&CK T1547.004' -Path $propPath -Value $userinit.Userinit -AccessGained 'System' -Note "The executables in the Userinit property are run at login time. Normal value is 'C:\Windows\system32\userinit.exe,' without additional executables." -Reference 'https://attack.mitre.org/techniques/T1547/004/'
                
                    if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                        $script:globalPersistenceObjectArray.Add($PersistenceObject)
                    }
                }
            }
        }
    }

    function Get-WinlogonShell {
        Write-Verbose "$hostname - Getting Winlogon's Shell property..."
        foreach ($hive in $systemAndUsersHives) {
            $shell = Get-ItemProperty -Path "$hive\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name Shell -ErrorAction SilentlyContinue
            if ($shell -and $shell.Shell) {
                $propPath = Convert-Path -Path $shell.PSPath
                $propPath += '\Shell'
            
                # Only flag if not the default value
                if ($shell.Shell -ne 'explorer.exe') {
                    $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Winlogon Shell Property' -Classification 'MITRE ATT&CK T1547.004' -Path $propPath -Value $shell.Shell -AccessGained 'User' -Note "The executables in the Shell property are run as the default shell. Normal value is 'explorer.exe' without additional executables." -Reference 'https://attack.mitre.org/techniques/T1547/004/'
                
                    if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                        $script:globalPersistenceObjectArray.Add($PersistenceObject)
                    }
                }
            }
        }
    }

    function Get-TerminalProfileStartOnUserLogin {
        Write-Verbose "$hostname - Checking Windows Terminal startOnUserLogin settings..."
        $userDirectories = Get-ChildItem -Path 'C:\Users\' -ErrorAction SilentlyContinue
        foreach ($directory in $userDirectories) {
            $terminalDirectories = Get-ChildItem -Path "$($directory.FullName)\Appdata\Local\Packages\Microsoft.WindowsTerminal_*" -ErrorAction SilentlyContinue
            foreach ($terminalDirectory in $terminalDirectories) {
                $settingsPath = "$($terminalDirectory.FullName)\LocalState\settings.json"
                if (-not (Test-Path $settingsPath -ErrorAction SilentlyContinue)) { continue }
            
                try {
                    $settingsFile = Get-Content -Raw -Path $settingsPath -ErrorAction Stop | ConvertFrom-Json -ErrorAction Stop
                    if ($settingsFile.startOnUserLogin -ne $true -and $settingsFile.startOnUserLogin -ne 'true') { continue }
                
                    $defaultProfileGuid = $settingsFile.defaultProfile
                    $found = $false 
                
                    # Handle both new and old profile structure
                    $profiles = if ($settingsFile.profiles.list) { $settingsFile.profiles.list } else { $settingsFile.profiles }
                
                    foreach ($profile in $profiles) {
                        if ($profile.guid -eq $defaultProfileGuid) {
                            $executable = if ($profile.commandline) { $profile.commandline } else { $profile.name }
                        
                            $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Windows Terminal startOnUserLogin' -Classification 'Uncatalogued Technique N.3' -Path $settingsPath -Value $executable -AccessGained 'User' -Note "The executable specified in a Terminal profile with startOnUserLogin=true runs every time the user logs in." -Reference 'https://twitter.com/nas_bench/status/1550836225652686848'
                        
                            if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                                $script:globalPersistenceObjectArray.Add($PersistenceObject)
                            }
                            $found = $true
                            break
                        }
                    }
                }
                catch {
                    # Skip invalid JSON files or access errors
                    Write-Verbose "Could not parse Terminal settings file: $settingsPath"
                    continue
                }
            }
        }
    }
    function Get-AppCertDlls {
        Write-Verbose "$hostname - Getting AppCertDlls properties..."
        foreach ($hive in $systemAndUsersHives) {
            $appCertDllsProps = Get-ItemProperty -Path "$hive\SYSTEM\CurrentControlSet\Control\Session Manager\AppCertDlls" -ErrorAction SilentlyContinue
            if ($appCertDllsProps) {
                foreach ($prop in (Get-Member -MemberType NoteProperty -InputObject $appCertDllsProps)) {
                    if ($psProperties.Contains($prop.Name)) { continue }
                
                    $propPath = Convert-Path -Path $appCertDllsProps.PSPath
                    $propPath += '\' + $prop.Name
                
                    $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'AppCertDlls' -Classification 'MITRE ATT&CK T1546.009' -Path $propPath -Value $appCertDllsProps.($prop.Name) -AccessGained 'System' -Note 'DLLs in AppCertDlls registry key are loaded by every process that loads Win32 API at process creation.' -Reference 'https://attack.mitre.org/techniques/T1546/009/'
                
                    if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                        $script:globalPersistenceObjectArray.Add($PersistenceObject)
                    }
                }
            }
        }
    }

    function Get-AppPaths {
        Write-Verbose "$hostname - Getting App Paths inside the registry..."
        foreach ($hive in $systemAndUsersHives) {
            $appPathsKeys = Get-ChildItem -Path "$hive\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths" -ErrorAction SilentlyContinue
            foreach ($key in $appPathsKeys) {
                $appPath = Get-ItemProperty -Path Registry::$key -Name '(Default)' -ErrorAction SilentlyContinue
                if ($appPath -and $appPath.'(Default)') {
                    $keyName = $key.PSChildName
                    $targetPath = $appPath.'(Default)'
                
                    # Expand environment variables
                    $expandedPath = [System.Environment]::ExpandEnvironmentVariables($targetPath)
                
                    # Create persistence object for mode-based filtering
                    $propPath = Convert-Path -Path $key.PSPath -ErrorAction SilentlyContinue
                    if ($propPath) {
                        $propPath += '\(Default)'
                    
                        # Build note with context about the redirection
                        $keyBaseName = [System.IO.Path]::GetFileNameWithoutExtension($keyName)
                        $actualExeName = if (Test-Path $expandedPath -ErrorAction SilentlyContinue) {
                            [System.IO.Path]::GetFileNameWithoutExtension($expandedPath)
                        }
                        else {
                            "File not found"
                        }
                    
                        $note = "App Path '$keyBaseName' redirects to '$actualExeName'. This mechanism can be used to hijack application launches."
                    
                        $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'App Paths Hijacking' -Classification 'Hexacorn Technique N.3' -Path $propPath -Value $targetPath -AccessGained 'System/User' -Note $note -Reference 'https://www.hexacorn.com/blog/2013/01/19/beyond-good-ol-run-key-part-3/'
                    
                        if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                            $script:globalPersistenceObjectArray.Add($PersistenceObject)
                        }
                    }
                }
            }
        }
    }

    function Get-ServiceDlls {
        Write-Verbose "$hostname - Getting Service DLLs inside the registry..."
        foreach ($hive in $systemAndUsersHives) {
            $keys = Get-ChildItem -Path "$hive\SYSTEM\CurrentControlSet\Services\" -ErrorAction SilentlyContinue
            foreach ($key in $keys) {
                $ImagePath = (Get-ItemProperty -Path ($key.pspath) -ErrorAction SilentlyContinue).ImagePath
                if ($ImagePath -and $ImagePath.ToLower().Contains('\svchost.exe')) {
                    $ServiceDll = $null
                    $propPath = $null
                
                    # Check Parameters subkey first, then main key
                    if (Test-Path -Path ($key.pspath + '\Parameters') -ErrorAction SilentlyContinue) {
                        $ServiceDll = (Get-ItemProperty -Path ($key.pspath + '\Parameters') -ErrorAction SilentlyContinue).ServiceDll
                        if ($ServiceDll) {
                            $propPath = (Convert-Path -Path "$($key.pspath)" -ErrorAction SilentlyContinue) + '\Parameters\ServiceDll'
                        }
                    }
                    else {
                        $ServiceDll = (Get-ItemProperty -Path ($key.pspath) -ErrorAction SilentlyContinue).ServiceDll
                        if ($ServiceDll) {
                            $propPath = (Convert-Path -Path "$($key.pspath)" -ErrorAction SilentlyContinue) + '\ServiceDll'
                        }
                    }
                
                    if ($ServiceDll -and $propPath) {
                        $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'ServiceDll Hijacking' -Classification 'MITRE ATT&CK T1543.003' -Path $propPath -Value $ServiceDll -AccessGained 'System' -Note "ServiceDll property specifies DLL loaded by svchost.exe for this service. Malicious DLLs can be loaded by modifying this entry." -Reference 'https://attack.mitre.org/techniques/T1543/003/'
                    
                        if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                            $script:globalPersistenceObjectArray.Add($PersistenceObject)
                        }
                    }
                }
            }
        }
    }

    function Get-GPExtensionDlls {
        Write-Verbose "$hostname - Getting Group Policy Extension DLLs inside the registry..."
        foreach ($hive in $systemAndUsersHives) {
            $keys = Get-ChildItem -Path "$hive\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\GPExtensions" -ErrorAction SilentlyContinue
            foreach ($key in $keys) {
                $DllName = (Get-ItemProperty -Path ($key.pspath) -ErrorAction SilentlyContinue).DllName
                if ($DllName) {
                    $propPath = (Convert-Path -Path "$($key.pspath)" -ErrorAction SilentlyContinue) + '\DllName'
                    $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Group Policy Extension DLL' -Classification 'Uncatalogued Technique N.4' -Path $propPath -Value $DllName -AccessGained 'System' -Note 'DLLs in GPExtensions DllName property are loaded by Group Policy service (gpsvc) during policy processing.' -Reference 'https://persistence-info.github.io/Data/gpoextension.html'
                
                    if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                        $script:globalPersistenceObjectArray.Add($PersistenceObject)
                    }
                }
            }
        }
    }

    function Get-WinlogonMPNotify {
        Write-Verbose "$hostname - Getting Winlogon MPNotify property..."
        foreach ($hive in $systemAndUsersHives) {
            $mpnotify = Get-ItemProperty -Path "$hive\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name mpnotify -ErrorAction SilentlyContinue
            if ($mpnotify -and $mpnotify.mpnotify) {
                $propPath = (Convert-Path -Path $mpnotify.PSPath -ErrorAction SilentlyContinue) + '\mpnotify'
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Winlogon MPNotify Executable' -Classification 'Uncatalogued Technique N.5' -Path $propPath -Value $mpnotify.mpnotify -AccessGained 'System' -Note 'Executable specified in mpnotify property is run by Winlogon during user logon with 30-second timeout.' -Reference 'https://persistence-info.github.io/Data/mpnotify.html'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
    }

    function Get-CHMHelperDll {
        Write-Verbose "$hostname - Getting CHM Helper DLL inside the registry..."
        foreach ($hive in $systemAndUsersHives) {
            $dllLocation = Get-ItemProperty -Path "$hive\Software\Microsoft\HtmlHelp Author" -Name Location -ErrorAction SilentlyContinue
            if ($dllLocation -and $dllLocation.Location) {
                $propPath = (Convert-Path -Path "$($dllLocation.pspath)" -ErrorAction SilentlyContinue) + '\Location'
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'CHM Helper DLL' -Classification 'Hexacorn Technique N.76' -Path $propPath -Value $dllLocation.Location -AccessGained 'User' -Note 'DLLs in HtmlHelp Author Location property are loaded when CHM help files are parsed.' -Reference 'https://www.hexacorn.com/blog/2018/04/22/beyond-good-ol-run-key-part-76/'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
    }

    function Get-HHCtrlHijacking {
        Write-Verbose "$hostname - Getting the hhctrl.ocx library inside the registry..."
        $hive = (Get-Item Registry::HKEY_CLASSES_ROOT -ErrorAction SilentlyContinue).PSpath
        if ($hive) {
            $dllLocation = Get-ItemProperty -Path "$hive\CLSID\{52A2AAAE-085D-4187-97EA-8C30DB990436}\InprocServer32" -Name '(Default)' -ErrorAction SilentlyContinue
        
            if ($dllLocation -and $dllLocation.'(Default)') {
                $propPath = (Convert-Path -Path "$($dllLocation.pspath)" -ErrorAction SilentlyContinue) + '\(Default)'
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'hhctrl.ocx Hijacking' -Classification 'Hexacorn Technique N.77' -Path $propPath -Value $dllLocation.'(Default)' -AccessGained 'User' -Note 'hhctrl.ocx DLL is loaded when CHM help files are parsed or hh.exe starts. Registry entry can be modified to load malicious DLL.' -Reference 'https://www.hexacorn.com/blog/2018/04/23/beyond-good-ol-run-key-part-77/'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
            else {
                # Check fallback location
                $dllPath = "C:\Windows\System32\hhctrl.ocx"
                if (Test-Path $dllPath -ErrorAction SilentlyContinue) {
                    $isOSBinary = try { 
                        (Get-AuthenticodeSignature $dllPath -ErrorAction SilentlyContinue).IsOsBinary 
                    }
                    catch { 
                        $false 
                    }
                
                    if (-not $isOSBinary) {
                        $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'hhctrl.ocx Hijacking' -Classification 'Hexacorn Technique N.77' -Path $dllPath -Value "Fallback DLL not OS-signed" -AccessGained 'User' -Note 'Fallback hhctrl.ocx at System32 location is not an OS binary, indicating potential DLL replacement.' -Reference 'https://www.hexacorn.com/blog/2018/04/23/beyond-good-ol-run-key-part-77/'
                    
                        if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                            $script:globalPersistenceObjectArray.Add($PersistenceObject)
                        }
                    }
                }
            }
        }
    }
    function Get-StartupPrograms {
        Write-Verbose "$hostname - Checking users' Startup folder contents..."
        $userDirectories = Get-ChildItem -Path 'C:\Users\' -ErrorAction SilentlyContinue
        foreach ($directory in $userDirectories) {
            $startupPath = "$($directory.FullName)\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\"
            if (-not (Test-Path $startupPath -ErrorAction SilentlyContinue)) { continue }
        
            $startupFiles = Get-ChildItem -Path $startupPath -ErrorAction SilentlyContinue
            foreach ($file in $startupFiles) {
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Startup Folder' -Classification 'MITRE ATT&CK T1547.001' -Path $startupPath -Value $file.FullName -AccessGained 'User' -Note "Files in the Startup folder are executed when the user logs in." -Reference 'https://attack.mitre.org/techniques/T1547/001/'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
    }

    function Get-UserInitMprScript {
        Write-Verbose "$hostname - Getting UserInitMprLogonScript properties..."
        foreach ($hive in $systemAndUsersHives) {
            $mprlogonscript = Get-ItemProperty -Path "$hive\Environment" -Name UserInitMprLogonScript -ErrorAction SilentlyContinue
            if ($mprlogonscript -and $mprlogonscript.UserInitMprLogonScript) {
                $propPath = (Convert-Path -Path $mprlogonscript.PSPath -ErrorAction SilentlyContinue) + '\UserInitMprLogonScript'
                $currentHive = Convert-Path -Path $hive -ErrorAction SilentlyContinue
                $access = if (($currentHive -eq 'HKEY_LOCAL_MACHINE') -or ($currentHive -eq 'HKEY_USERS\S-1-5-18') -or ($currentHive -eq 'HKEY_USERS\S-1-5-19') -or ($currentHive -eq 'HKEY_USERS\S-1-5-20')) { 'System' } else { 'User' }
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'User Init Mpr Logon Script' -Classification 'MITRE ATT&CK T1037.001' -Path $propPath -Value $mprlogonscript.UserInitMprLogonScript -AccessGained $access -Note 'The executable specified in UserInitMprLogonScript property is run when the user logs on.' -Reference 'https://attack.mitre.org/techniques/T1037/001/'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
    }

    function Get-AutodialDLL {
        Write-Verbose "$hostname - Getting AutodialDLL property..."
        foreach ($hive in $systemAndUsersHives) {
            $autodialDll = Get-ItemProperty -Path "$hive\SYSTEM\CurrentControlSet\Services\WinSock2\Parameters" -Name AutodialDLL -ErrorAction SilentlyContinue
            if ($autodialDll -and $autodialDll.AutodialDLL) {
                $propPath = (Convert-Path -Path $autodialDll.PSPath -ErrorAction SilentlyContinue) + '\AutodialDLL'
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'AutodialDLL Winsock Injection' -Classification 'Hexacorn Technique N.24' -Path $propPath -Value $autodialDll.AutodialDLL -AccessGained 'System' -Note 'DLL specified in AutodialDLL property is loaded by Winsock library on internet connections.' -Reference 'https://www.hexacorn.com/blog/2015/01/13/beyond-good-ol-run-key-part-24/'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
    }

    function Get-LsaExtensions {
        Write-Verbose "$hostname - Getting LSA extensions..."
        foreach ($hive in $systemAndUsersHives) {
            $lsaExtensions = Get-ItemProperty -Path "$hive\SYSTEM\CurrentControlSet\Control\LsaExtensionConfig\LsaSrv" -Name Extensions -ErrorAction SilentlyContinue
            if ($lsaExtensions -and $lsaExtensions.Extensions) {
                $dlls = $lsaExtensions.Extensions -split '\s+' | Where-Object { $_ -ne '' }
                foreach ($dll in $dlls) {
                    $propPath = (Convert-Path -Path $lsaExtensions.PSPath -ErrorAction SilentlyContinue) + '\Extensions'
                
                    $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'LSA Extensions DLL' -Classification 'Uncatalogued Technique N.6' -Path $propPath -Value $dll -AccessGained 'System' -Note 'DLLs specified in LSA Extensions property are loaded by LSASS at machine boot.' -Reference 'https://persistence-info.github.io/Data/lsaaextension.html'
                
                    if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                        $script:globalPersistenceObjectArray.Add($PersistenceObject)
                    }
                }
            }
        }
    }

    function Get-ServerLevelPluginDll {
        Write-Verbose "$hostname - Getting ServerLevelPluginDll property..."
        foreach ($hive in $systemAndUsersHives) {
            $pluginDll = Get-ItemProperty -Path "$hive\SYSTEM\CurrentControlSet\Services\DNS\Parameters" -Name ServerLevelPluginDll -ErrorAction SilentlyContinue
            if ($pluginDll -and $pluginDll.ServerLevelPluginDll) {
                $propPath = (Convert-Path -Path $pluginDll.PSPath -ErrorAction SilentlyContinue) + '\ServerLevelPluginDll'
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'ServerLevelPluginDll DNS Hijacking' -Classification 'Uncatalogued Technique N.7' -Path $propPath -Value $pluginDll.ServerLevelPluginDll -AccessGained 'System' -Note 'DLL specified in ServerLevelPluginDll property is loaded by DNS service on systems with DNS Server role.' -Reference 'https://persistence-info.github.io/Data/serverlevelplugindll.html'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
    }

    function Get-LsaPasswordFilter {
        Write-Verbose "$hostname - Getting LSA password filters..."
        foreach ($hive in $systemAndUsersHives) {
            $passwordFilters = Get-ItemProperty -Path "$hive\SYSTEM\CurrentControlSet\Control\Lsa" -Name 'Notification Packages' -ErrorAction SilentlyContinue
            if ($passwordFilters -and $passwordFilters.'Notification Packages') {
                $dlls = $passwordFilters.'Notification Packages' -split '\s+' | Where-Object { $_ -ne '' }
                foreach ($dll in $dlls) {
                    $dllPath = if ($dll -like "*.dll") { "C:\Windows\System32\$dll" } else { "C:\Windows\System32\$dll.dll" }
                    $propPath = (Convert-Path -Path $passwordFilters.PSPath -ErrorAction SilentlyContinue) + '\Notification Packages'
                
                    $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'LSA Password Filter DLL' -Classification 'MITRE ATT&CK T1556.002' -Path $propPath -Value $dllPath -AccessGained 'System' -Note 'DLLs specified in Notification Packages are loaded by LSASS and can intercept password changes.' -Reference 'https://attack.mitre.org/techniques/T1556/002/'
                
                    if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                        $script:globalPersistenceObjectArray.Add($PersistenceObject)
                    }
                }
            }
        }
    }

    function Get-LsaAuthenticationPackages {
        Write-Verbose "$hostname - Getting LSA authentication packages..."
        foreach ($hive in $systemAndUsersHives) {
            $authPackages = Get-ItemProperty -Path "$hive\SYSTEM\CurrentControlSet\Control\Lsa" -Name 'Authentication Packages' -ErrorAction SilentlyContinue
            if ($authPackages -and $authPackages.'Authentication Packages') {
                # Registry multi-string value is already an array - don't split on spaces
                $packages = $authPackages.'Authentication Packages'
                
                # Ensure it's treated as an array even if single value
                if ($packages -isnot [Array]) {
                    $packages = @($packages)
                }
                
                foreach ($package in $packages) {
                    if ([string]::IsNullOrWhiteSpace($package)) { continue }
                    
                    $package = $package.Trim()
                    
                    # Check if package is already a full path
                    if ($package -match '^[A-Za-z]:\\' -or $package -match '^\\\\') {
                        $dllPath = $package
                    }
                    else {
                        # Assume it's just a DLL name without path or extension
                        if ($package -notmatch '\.dll$') {
                            $dllPath = "C:\Windows\System32\$package.dll"
                        }
                        else {
                            $dllPath = "C:\Windows\System32\$package"
                        }
                    }
                    
                    $propPath = (Convert-Path -Path $authPackages.PSPath -ErrorAction SilentlyContinue) + '\Authentication Packages'
                
                    $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'LSA Authentication Package DLL' -Classification 'MITRE ATT&CK T1547.002' -Path $propPath -Value $dllPath -AccessGained 'System' -Note 'DLLs specified in Authentication Packages are loaded by LSASS at machine boot for custom authentication.' -Reference 'https://attack.mitre.org/techniques/T1547/002/'
                
                    if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                        $script:globalPersistenceObjectArray.Add($PersistenceObject)
                    }
                }
            }
        }
    }

    function Get-LsaSecurityPackages {
        Write-Verbose "$hostname - Getting LSA security packages..."
        foreach ($hive in $systemAndUsersHives) {
            $secPackages = Get-ItemProperty -Path "$hive\SYSTEM\CurrentControlSet\Control\Lsa" -Name 'Security Packages' -ErrorAction SilentlyContinue
            if ($secPackages -and $secPackages.'Security Packages') {
                $packageString = $secPackages.'Security Packages' -replace '"', ''
                $dlls = $packageString -split '\s+' | Where-Object { $_ -ne '' }
                foreach ($dll in $dlls) {
                    $dllPath = if (([System.IO.Path]::IsPathRooted([System.Environment]::ExpandEnvironmentVariables($dll))) -eq $false) {
                        "C:\Windows\System32\$dll.dll"
                    }
                    else { 
                        $dll 
                    }
                
                    $propPath = (Convert-Path -Path $secPackages.PSPath -ErrorAction SilentlyContinue) + '\Security Packages'
                
                    $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'LSA Security Package DLL' -Classification 'MITRE ATT&CK T1547.005' -Path $propPath -Value $dllPath -AccessGained 'System' -Note 'DLLs specified in Security Packages are loaded by LSASS at machine boot for security protocols.' -Reference 'https://attack.mitre.org/techniques/T1547/005/'
                
                    if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                        $script:globalPersistenceObjectArray.Add($PersistenceObject)
                    }
                }
            }
        }
    }

    function Get-WinlogonNotificationPackages {
        Write-Verbose "$hostname - Getting Winlogon Notification packages..."
        foreach ($hive in $systemAndUsersHives) {
            $notificationPackages = Get-ItemProperty -Path "$hive\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify" -ErrorAction SilentlyContinue
            if ($notificationPackages) {
                foreach ($prop in (Get-Member -MemberType NoteProperty -InputObject $notificationPackages)) {
                    if ($psProperties.Contains($prop.Name)) { continue }
                
                    $propPath = Convert-Path -Path $notificationPackages.PSPath -ErrorAction SilentlyContinue
                    $propPath += '\' + $prop.Name
                
                    $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Winlogon Notification Package' -Classification 'MITRE ATT&CK T1547.004' -Path $propPath -Value $notificationPackages.($prop.Name) -AccessGained 'System' -Note 'DLLs in Winlogon Notify properties are loaded by the system at boot for logon notifications.' -Reference 'https://attack.mitre.org/techniques/T1547/004/'
                
                    if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                        $script:globalPersistenceObjectArray.Add($PersistenceObject)
                    }
                }
            }
        }
    }

    function Get-DotNetDebugger {
        Write-Verbose "$hostname - Getting .NET Debugger properties..."
        foreach ($hive in $systemAndUsersHives) {
            $dotNetDebugger = Get-ItemProperty -Path "$hive\SOFTWARE\Microsoft\.NETFramework" -Name DbgManagedDebugger -ErrorAction SilentlyContinue
            if ($dotNetDebugger -and $dotNetDebugger.DbgManagedDebugger) {
                $propPath = Convert-Path -Path $dotNetDebugger.PSPath -ErrorAction SilentlyContinue
                $propPath += '\DbgManagedDebugger'
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'DbgManagedDebugger Custom Debugger' -Classification 'Hexacorn Technique N.4' -Path $propPath -Value $dotNetDebugger.DbgManagedDebugger -AccessGained 'System/User' -Note "Executable in DbgManagedDebugger property runs when a .NET process crashes. Access depends on crashed process context." -Reference 'https://www.hexacorn.com/blog/2013/09/19/beyond-good-ol-run-key-part-4/'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }

            $dotNetDebugger = Get-ItemProperty -Path "$hive\SOFTWARE\Wow6432Node\Microsoft\.NETFramework" -Name DbgManagedDebugger -ErrorAction SilentlyContinue
            if ($dotNetDebugger -and $dotNetDebugger.DbgManagedDebugger) {
                $propPath = Convert-Path -Path $dotNetDebugger.PSPath -ErrorAction SilentlyContinue
                $propPath += '\DbgManagedDebugger'
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Wow6432Node DbgManagedDebugger Custom Debugger' -Classification 'Hexacorn Technique N.4' -Path $propPath -Value $dotNetDebugger.DbgManagedDebugger -AccessGained 'System/User' -Note "Executable in Wow6432Node DbgManagedDebugger property runs when a 32-bit .NET process crashes on 64-bit system." -Reference 'https://www.hexacorn.com/blog/2013/09/19/beyond-good-ol-run-key-part-4/'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
    }
    function Get-ErrorHandlerCmd {
        Write-Verbose "$hostname - Checking for ErrorHandler.cmd..."
        $errorHandlerCmd = Get-ChildItem -Path 'C:\WINDOWS\Setup\Scripts\ErrorHandler.cmd' -ErrorAction SilentlyContinue
        if ($errorHandlerCmd) {
            $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'ErrorHandler.cmd Hijacking' -Classification 'Hexacorn Technique N.135' -Path "C:\WINDOWS\Setup\Scripts\" -Value $errorHandlerCmd.FullName -AccessGained 'User' -Note "ErrorHandler.cmd is executed when Windows Setup tools fail. This file should not exist by default." -Reference 'https://www.hexacorn.com/blog/2022/01/16/beyond-good-ol-run-key-part-135/'
        
            if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                $script:globalPersistenceObjectArray.Add($PersistenceObject)
            }
        }
    }

    function Get-WMIEventsSubscrition {
        Write-Verbose "$hostname - Checking WMI Subscriptions..."
    
        try {
            $cmdEventConsumer = Get-WmiObject -Namespace root\Subscription -Class CommandLineEventConsumer -ErrorAction SilentlyContinue
            if ($cmdEventConsumer) {
                foreach ($cmdEntry in $cmdEventConsumer) {
                    $value = if ($cmdEntry.CommandLineTemplate) {
                        "CommandLineTemplate: $($cmdEntry.CommandLineTemplate)"
                    }
                    elseif ($cmdEntry.ExecutablePath) {
                        "ExecutablePath: $($cmdEntry.ExecutablePath)"
                    }
                    else {
                        "Name: $($cmdEntry.Name)"
                    }
                
                    $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'WMI Command Line Event Consumer' -Classification 'MITRE ATT&CK T1546.003' -Path $cmdEntry.__PATH -Value $value -AccessGained 'System' -Note "WMI Event subscriptions can execute commands when specific events occur." -Reference 'https://attack.mitre.org/techniques/T1546/003/'
                
                    if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                        $script:globalPersistenceObjectArray.Add($PersistenceObject)
                    }
                }
            }

            $scriptEventConsumer = Get-WmiObject -Namespace root\Subscription -Class ActiveScriptEventConsumer -ErrorAction SilentlyContinue
            if ($scriptEventConsumer) {
                foreach ($scriptEntry in $scriptEventConsumer) {
                    $value = if ($scriptEntry.ScriptText) {
                        "ScriptText: $($scriptEntry.ScriptText -replace '\s+', ' ')"
                    }
                    elseif ($scriptEntry.ScriptFileName) {
                        "ScriptFileName: $($scriptEntry.ScriptFileName)"
                    }
                    else {
                        "Name: $($scriptEntry.Name)"
                    }
                
                    $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'WMI Active Script Event Consumer' -Classification 'MITRE ATT&CK T1546.003' -Path $scriptEntry.__PATH -Value $value -AccessGained 'System' -Note "WMI Event subscriptions can execute scripts when specific events occur." -Reference 'https://attack.mitre.org/techniques/T1546/003/'
                
                    if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                        $script:globalPersistenceObjectArray.Add($PersistenceObject)
                    }
                }
            }
        }
        catch {
            Write-Verbose "$hostname - Error accessing WMI subscriptions: $($_.Exception.Message)"
        }
    }

    function Get-WindowsServices {
        Write-Verbose "$hostname - Checking Windows Services..."
        try {
            $services = Get-CimInstance -ClassName win32_service -ErrorAction SilentlyContinue | Select-Object Name, DisplayName, State, PathName, StartMode
            foreach ($service in $services) {
                # Skip if no pathname
                if (-not $service.PathName) { continue }
                
                # Create status string
                $statusString = "$($service.State)/$($service.StartMode)"
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Windows Service' -Classification 'MITRE ATT&CK T1543.003' -Path $service.Name -Value $service.PathName -AccessGained 'System' -Note "Windows services run automatically at boot and can be used for persistence. StartMode: $($service.StartMode)" -Reference 'https://attack.mitre.org/techniques/T1543/003/' -Status $statusString
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
        catch {
            Write-Verbose "$hostname - Error accessing Windows Services: $($_.Exception.Message)"
        }
    }
    function Get-PowerAutomate {
        Write-Verbose "$hostname - Checking Power Automate presence..."
        $PADFolder = "$env:ProgramData\Microsoft\Power Automate\Logs"
        if (Test-Path $PADFolder -ErrorAction SilentlyContinue) {
            $LastPALog = Get-ChildItem -Path $PADFolder -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1

            if ($LastPALog) {
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Power Automate' -Classification 'Uncatalogued Technique N.12' -Path $PADFolder -Value $LastPALog.FullName -AccessGained 'System/User' -Note "Power Automate RPA platform is present and active. While legitimate, it can be abused for malicious automation." -Reference 'https://github.com/mbrg/defcon30/tree/main/No_Code_Malware'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
    }

    function Get-TSInitialProgram {
        Write-Verbose "$hostname - Getting Terminal Services InitialProgram properties..."
        foreach ($hive in $systemAndUsersHives) {
            # Check Group Policy location
            $InitialProgram = Get-ItemProperty -Path "$hive\SOFTWARE\Policies\Microsoft\Windows NT\Terminal Services" -Name InitialProgram -ErrorAction SilentlyContinue
            if ($InitialProgram -and $InitialProgram.InitialProgram -and $InitialProgram.InitialProgram.Length -ne 0) {
                $propPath = Convert-Path -Path $InitialProgram.PSPath -ErrorAction SilentlyContinue
                $propPath += '\InitialProgram'
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Terminal Services InitialProgram' -Classification 'Uncatalogued Technique N.8' -Path $propPath -Value $InitialProgram.InitialProgram -AccessGained 'System/User' -Note "Executable in InitialProgram property runs when RDP connection is made." -Reference 'https://persistence-info.github.io/Data/tsinitialprogram.html'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }

            # Check WinStations location
            $InitialProgram = Get-ItemProperty -Path "$hive\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" -Name InitialProgram -ErrorAction SilentlyContinue
            if ($InitialProgram -and $InitialProgram.InitialProgram -and $InitialProgram.InitialProgram.Length -ne 0) {
                $propPath = Convert-Path -Path $InitialProgram.PSPath -ErrorAction SilentlyContinue
                $propPath += '\InitialProgram'
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Terminal Services InitialProgram' -Classification 'Uncatalogued Technique N.8' -Path $propPath -Value $InitialProgram.InitialProgram -AccessGained 'System/User' -Note "Executable in InitialProgram property runs when RDP connection is made to RDP-Tcp WinStation." -Reference 'https://persistence-info.github.io/Data/tsinitialprogram.html'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
    }

    function Get-AccessibilityTools {
        Write-Verbose "$hostname - Checking accessibility tools for backdoors..."
        $accessibilityTools = @(
            "$env:windir\System32\sethc.exe",
            "$env:windir\System32\osk.exe", 
            "$env:windir\System32\Narrator.exe",
            "$env:windir\System32\Magnify.exe",
            "$env:windir\System32\DisplaySwitch.exe",
            "$env:windir\System32\Utilman.exe",
            "$env:windir\System32\AtBroker.exe"
        )
    
        # Get reference hashes for comparison
        $referenceHashes = @{}
        $referenceFiles = @(
            "$env:windir\System32\cmd.exe",
            "$env:windir\System32\WindowsPowerShell\v1.0\powershell.exe",
            "$env:windir\explorer.exe",
            "$env:windir\System32\notepad.exe",
            "$env:windir\System32\rundll32.exe",
            "$env:windir\System32\mshta.exe",
            "$env:windir\System32\net.exe",
            "$env:windir\System32\regsvr32.exe"
        )
    
        try {
            foreach ($refFile in $referenceFiles) {
                if (Test-Path $refFile -ErrorAction SilentlyContinue) {
                    $hash = (Get-FileHash -LiteralPath $refFile -ErrorAction SilentlyContinue).Hash
                    if ($hash) { $referenceHashes[$refFile] = $hash }
                }
            }
        }
        catch {
            Write-Verbose "$hostname - Could not get reference hashes for accessibility tool comparison"
        }
    
        foreach ($tool in $accessibilityTools) {
            if (Test-Path $tool -ErrorAction SilentlyContinue) {
                try {
                    $toolHash = (Get-FileHash -LiteralPath $tool -ErrorAction SilentlyContinue).Hash
                    $isReplaced = $false
                    $replacedWith = ""
                    $shouldFlag = $false
                
                    # Check if tool has been replaced with common utilities
                    foreach ($refPath in $referenceHashes.Keys) {
                        if ($toolHash -eq $referenceHashes[$refPath]) {
                            $isReplaced = $true
                            $replacedWith = " (replaced with $(Split-Path $refPath -Leaf))"
                            $shouldFlag = $true  # Always flag if replaced
                            break
                        }
                    }
                
                    # Check digital signature
                    $signatureStatus = $null
                    $isMicrosoftSigned = $false
                    $isValidOrExpired = $false
                
                    try {
                        $signature = Get-AuthenticodeSignature -LiteralPath $tool -ErrorAction SilentlyContinue
                        $signatureStatus = $signature.Status
                    
                        # Check if it's Microsoft signed
                        if ($signature.SignerCertificate.Subject -like "*Microsoft*") {
                            $isMicrosoftSigned = $true
                        }
                    
                        # Check if signature is Valid or just expired but otherwise valid
                        if ($signature.Status -eq 'Valid' -or 
                            ($signature.Status -eq 'NotTrusted' -and $signature.SignerCertificate.Subject -like "*Microsoft*")) {
                            $isValidOrExpired = $true
                        }
                    
                    }
                    catch { 
                        $shouldFlag = $true
                        $replacedWith += " (signature check failed)"
                    }
                
                    # Decision logic for flagging
                    if (-not $isReplaced) {
                        # If not replaced, only flag if:
                        # 1. Not Microsoft signed, OR
                        # 2. Invalid signature (not Valid or expired Microsoft cert)
                        if (-not $isMicrosoftSigned -or -not $isValidOrExpired) {
                            $shouldFlag = $true
                            if (-not $isMicrosoftSigned) {
                                $replacedWith += " (not Microsoft signed)"
                            }
                            elseif (-not $isValidOrExpired) {
                                $replacedWith += " (invalid signature)"
                            }
                        }
                    }
                
                    # Only create persistence object if we should flag this entry
                    if ($shouldFlag) {
                        $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Accessibility Tools Backdoor' -Classification 'MITRE ATT&CK T1546.008' -Path $tool -Value "$tool$replacedWith" -AccessGained 'System' -Note "Accessibility tools can be executed from lock screen with SYSTEM privileges. Tool may have been replaced or modified." -Reference 'https://attack.mitre.org/techniques/T1546/008/'
                    
                        if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                            $script:globalPersistenceObjectArray.Add($PersistenceObject)
                        }
                    }
                    else {
                        # Log that we're skipping a legitimate Microsoft binary
                        Write-Verbose "$hostname - Skipping legitimate Microsoft accessibility tool: $tool"
                    }
                
                }
                catch {
                    Write-Verbose "$hostname - Error checking accessibility tool: $tool"
                }
            }
        }
    }

    function Get-AMSIProviders {
        Write-Verbose "$hostname - Getting AMSI providers..."
        $legitAMSIGUID = '{2781761E-28E0-4109-99FE-B9D127C57AFE}'
    
        # Check if AMSI Providers key exists
        if (-not (Test-Path "HKLM:\SOFTWARE\Microsoft\AMSI\Providers\" -ErrorAction SilentlyContinue)) {
            Write-Verbose "$hostname - AMSI Providers registry key not found"
            return
        }
    
        # Get all AMSI provider keys
        $amsiProviders = Get-ChildItem -Path "HKLM:\SOFTWARE\Microsoft\AMSI\Providers\" -ErrorAction SilentlyContinue
        if (-not $amsiProviders) {
            Write-Verbose "$hostname - No AMSI provider keys found"
            return
        }
    
        foreach ($key in $amsiProviders) {
            try {
                $keyGUID = $key.PSChildName
                if ($keyGUID -eq $legitAMSIGUID) { 
                    Write-Verbose "$hostname - Skipping legitimate AMSI provider: $keyGUID"
                    continue 
                }
            
                $clsidPath = "HKLM:\SOFTWARE\Classes\CLSID\$keyGUID\InprocServer32"
            
                # Check if CLSID key exists before trying to read from it
                if (-not (Test-Path $clsidPath -ErrorAction SilentlyContinue)) {
                    Write-Verbose "$hostname - CLSID path not found: $clsidPath"
                    continue
                }
            
                $dllLocation = Get-ItemProperty -Path $clsidPath -Name '(Default)' -ErrorAction SilentlyContinue
                if ($dllLocation -and $dllLocation.'(Default)') {
                    $path = $dllLocation.'(Default)'
                
                    # Construct full path if needed
                    if (-not ($path -like '*.dll')) { $path = $path + '.dll' }
                    if (-not ([System.IO.Path]::IsPathRooted($path))) {
                        $path = "C:\Windows\System32\$path"
                    }
                
                    # Expand environment variables after path construction
                    $path = [System.Environment]::ExpandEnvironmentVariables($path)
                
                    # Use consistent registry path format
                    $propPath = Convert-Path -Path $clsidPath -ErrorAction SilentlyContinue
                    if ($propPath) {
                        $propPath += "\(Default)"
                    }
                    else {
                        $propPath = "$clsidPath\(Default)"
                    }
                
                    $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Custom AMSI Provider' -Classification 'Uncatalogued Technique N.9' -Path $propPath -Value $path -AccessGained 'System/User' -Note 'Custom AMSI providers are loaded by .NET processes and can be used for persistence or evasion.' -Reference 'https://b4rtik.github.io/posts/antimalware-scan-interface-provider-for-persistence/'
                
                    if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                        $script:globalPersistenceObjectArray.Add($PersistenceObject)
                    }
                }
            }
            catch {
                Write-Verbose "$hostname - Error processing AMSI provider $($key.PSChildName): $($_.Exception.Message)"
                continue
            }
        }
    }

    function Get-PowershellProfiles {
        Write-Verbose "$hostname - Getting PowerShell profiles..."
    
        # Windows PowerShell 5.1 system profiles
        $profilePaths = @(
            'C:\Windows\System32\WindowsPowerShell\v1.0\Profile.ps1',
            'C:\Windows\System32\WindowsPowerShell\v1.0\Microsoft.PowerShell_profile.ps1'
        )
    
        # PowerShell Core system profiles (if installed)
        $psCorePaths = @(
            'C:\Program Files\PowerShell\7\Profile.ps1',
            'C:\Program Files\PowerShell\7\Microsoft.PowerShell_profile.ps1'
        )
    
        $allSystemPaths = $profilePaths + $psCorePaths
        $foundProfiles = 0
   
        # Check system profiles
        foreach ($profilePath in $allSystemPaths) {
            if (Test-Path $profilePath -ErrorAction SilentlyContinue) {
                $foundProfiles++
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'PowerShell Profile' -Classification 'MITRE ATT&CK T1546.013' -Path (Split-Path $profilePath) -Value $profilePath -AccessGained 'System' -Note "PowerShell profiles are loaded whenever PowerShell starts." -Reference 'https://attack.mitre.org/techniques/T1546/013/'
           
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
   
        # Check user profiles
        $userDirectories = Get-ChildItem -Path 'C:\Users\' -ErrorAction SilentlyContinue
        foreach ($directory in $userDirectories) {
            $userProfilePaths = @(
                "$($directory.FullName)\Documents\WindowsPowerShell\Profile.ps1",
                "$($directory.FullName)\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1",
                "$($directory.FullName)\Documents\PowerShell\Profile.ps1",
                "$($directory.FullName)\Documents\PowerShell\Microsoft.PowerShell_profile.ps1"
            )
       
            foreach ($profilePath in $userProfilePaths) {
                if (Test-Path $profilePath -ErrorAction SilentlyContinue) {
                    $foundProfiles++
                    $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'PowerShell Profile' -Classification 'MITRE ATT&CK T1546.013' -Path (Split-Path $profilePath) -Value $profilePath -AccessGained 'User' -Note "PowerShell profiles are loaded whenever PowerShell starts." -Reference 'https://attack.mitre.org/techniques/T1546/013/'
               
                    if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                        $script:globalPersistenceObjectArray.Add($PersistenceObject)
                    }
                }
            }
        }
    }



    function Get-SilentExitMonitor {
        Write-Verbose "$hostname - Getting Silent Process Exit monitors..."
        $exitMonitors = Get-ChildItem -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\" -ErrorAction SilentlyContinue
        foreach ($key in $exitMonitors) {
            $monitorProperty = Get-ItemProperty -Path $key.PSPath -Name MonitorProcess -ErrorAction SilentlyContinue
            if ($monitorProperty -and $monitorProperty.MonitorProcess) {
                $propPath = Convert-Path -Path $key.PSPath -ErrorAction SilentlyContinue
                $propPath += '\MonitorProcess'
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Silent Process Exit Monitor' -Classification 'MITRE ATT&CK T1546.012' -Path $propPath -Value $monitorProperty.MonitorProcess -AccessGained 'System/User' -Note 'Executables specified in MonitorProcess are run when the associated process is terminated.' -Reference 'https://attack.mitre.org/techniques/T1546/012/'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
    }

    function Get-TelemetryController {
        Write-Verbose "$hostname - Getting Telemetry controller..."
        $telemetryProperty = Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\TelemetryController" -Name Command -ErrorAction SilentlyContinue
        if ($telemetryProperty -and $telemetryProperty.Command) {
            $propPath = 'HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\TelemetryController\Command'
        
            $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Telemetry Controller Command' -Classification 'Uncatalogued Technique N.10' -Path $propPath -Value $telemetryProperty.Command -AccessGained 'System' -Note "Executable specified in TelemetryController Command is run by CompatTelRunner.exe." -Reference 'https://www.trustedsec.com/blog/abusing-windows-telemetry-for-persistence/'
        
            if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                $script:globalPersistenceObjectArray.Add($PersistenceObject)
            }
        }
    }

    function Get-RDPWDSStartupPrograms {
        Write-Verbose "$hostname - Getting RDP WDS startup programs..."
        $startupProperty = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd" -Name StartupPrograms -ErrorAction SilentlyContinue
        if ($startupProperty -and $startupProperty.StartupPrograms) {
            $executables = $startupProperty.StartupPrograms -split ','
            foreach ($exe in $executables) {
                $exe = $exe.Trim()
                if ($exe -eq 'rdpclip') { continue }
            
                $propPath = 'HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\StartupPrograms'
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'RDP WDS Startup Programs' -Classification 'Uncatalogued Technique N.11' -Path $propPath -Value $exe -AccessGained 'System' -Note "Executables in StartupPrograms are run when users log on through remote desktop." -Reference 'https://persistence-info.github.io/Data/rdpwdstartupprograms.html'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
    }

    function Get-BitsJobsNotifyCmdLine {
        Write-Verbose "$hostname - Getting BITS Jobs..."
        try {
            $jobs = Get-BitsTransfer -AllUsers -ErrorAction SilentlyContinue | Where-Object { $_.JobState -eq "Error" } | Where-Object { $_.NotifyCmdLine -and $_.NotifyCmdLine.Length -gt 0 }
            if ($jobs) {
                foreach ($job in $jobs) {
                    $propPath = $job.JobId
                    $access = if ($job.OwnerAccount -eq 'NT AUTHORITY\SYSTEM') { 'System' } else { 'User' }
                
                    $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'BITS Job NotifyCmdLine' -Classification 'MITRE ATT&CK T1197' -Path $propPath -Value $job.NotifyCmdLine -AccessGained $access -Note "BITS jobs with NotifyCmdLine execute commands when job fails or completes." -Reference 'https://attack.mitre.org/techniques/T1197/'
                
                    if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                        $script:globalPersistenceObjectArray.Add($PersistenceObject)
                    }
                }
            }
        }
        catch {
            Write-Verbose "$hostname - Error accessing BITS jobs: $($_.Exception.Message)"
        }
    }

    function Get-Screensaver {
        Write-Verbose "$hostname - Getting Screensaver programs..."
        foreach ($sid in $systemAndUsersHives) {
            $screenSaverProgram = Get-ItemProperty -Path "$sid\Control Panel\Desktop" -Name "SCRNSAVE.EXE" -ErrorAction SilentlyContinue
            if ($screenSaverProgram -and $screenSaverProgram."SCRNSAVE.EXE" -and $screenSaverProgram."SCRNSAVE.EXE" -ne "") {
                $propPath = Convert-Path -Path $screenSaverProgram.PSPath -ErrorAction SilentlyContinue
                $propPath += '\SCRNSAVE.EXE'

                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Screensaver Program' -Classification 'MITRE ATT&CK T1546.002' -Path $propPath -Value $screenSaverProgram."SCRNSAVE.EXE" -AccessGained 'User' -Note "Custom screensaver executables run when screensaver activates, providing user-level persistence." -Reference 'https://attack.mitre.org/techniques/T1546/002/'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
    }

    function Get-OfficeTemplates {
        Write-Verbose "$hostname - Checking Office application startup files..."
        $userDirectories = Get-ChildItem -Path 'C:\Users\' -ErrorAction SilentlyContinue
        foreach ($directory in $userDirectories) {
            $searchPaths = @{
                "$($directory.FullName)\AppData\Roaming\Microsoft\Word\STARTUP\"  = "Word"
                "$($directory.FullName)\AppData\Roaming\Microsoft\Excel\XLSTART\" = "Excel"  
                "$($directory.FullName)\AppData\Roaming\Microsoft\AddIns\"        = "Office AddIns"
            }
        
            # Check startup folders
            foreach ($searchPath in $searchPaths.Keys) {
                if (Test-Path $searchPath -ErrorAction SilentlyContinue) {
                    $files = Get-ChildItem -Path $searchPath -ErrorAction SilentlyContinue
                    foreach ($file in $files) {
                        $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Office Application Startup' -Classification 'MITRE ATT&CK T1137.001' -Path $searchPath -Value $file.FullName -AccessGained 'User' -Note "Files in $($searchPaths[$searchPath]) startup folder execute when Office application starts." -Reference 'https://attack.mitre.org/techniques/T1137/'
                    
                        if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                            $script:globalPersistenceObjectArray.Add($PersistenceObject)
                        }
                    }
                }
            }
        
            # Check for macro-enabled templates
            $templatesPath = "$($directory.FullName)\AppData\Roaming\Microsoft\Templates\"
            if (Test-Path $templatesPath -ErrorAction SilentlyContinue) {
                $macroTemplates = Get-ChildItem -Path $templatesPath -Filter "*.dotm" -ErrorAction SilentlyContinue
                foreach ($template in $macroTemplates) {
                    $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Office Application Startup' -Classification 'MITRE ATT&CK T1137.001' -Path $templatesPath -Value $template.FullName -AccessGained 'User' -Note "Macro-enabled Word templates execute when documents are opened." -Reference 'https://attack.mitre.org/techniques/T1137/'
                
                    if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                        $script:globalPersistenceObjectArray.Add($PersistenceObject)
                    }
                }
            }
        
            # Check for Outlook templates
            $outlookPath = "$($directory.FullName)\AppData\Roaming\Microsoft\Outlook\"
            if (Test-Path $outlookPath -ErrorAction SilentlyContinue) {
                $outlookTemplates = Get-ChildItem -Path $outlookPath -Filter "*.OTM" -ErrorAction SilentlyContinue
                foreach ($template in $outlookTemplates) {
                    $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Office Application Startup' -Classification 'MITRE ATT&CK T1137.001' -Path $outlookPath -Value $template.FullName -AccessGained 'User' -Note "Outlook macro templates execute when Outlook starts." -Reference 'https://attack.mitre.org/techniques/T1137/'
                
                    if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                        $script:globalPersistenceObjectArray.Add($PersistenceObject)
                    }
                }
            }
        }
    }

    function Get-ExplorerTools {
        Write-Verbose "$hostname - Getting Explorer Tools..."
        foreach ($hive in $systemAndUsersHives) {
            $explorerTools = Get-ChildItem -Path "$hive\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer" -ErrorAction SilentlyContinue
            foreach ($key in $explorerTools) {
                $defaultValue = (Get-ItemProperty -Path Registry::$key -Name '(Default)' -ErrorAction SilentlyContinue).'(Default)'
                if ($defaultValue) {
                    $propPath = Convert-Path -Path $key.PSPath -ErrorAction SilentlyContinue
                    $propPath += '\(Default)'
                    $currentHive = Convert-Path -Path $hive -ErrorAction SilentlyContinue
                    $access = if (($currentHive -eq 'HKEY_LOCAL_MACHINE') -or ($currentHive -eq 'HKEY_USERS\S-1-5-18') -or ($currentHive -eq 'HKEY_USERS\S-1-5-19') -or ($currentHive -eq 'HKEY_USERS\S-1-5-20')) { 'System' } else { 'User' }
                
                    $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Explorer Tools Hijacking' -Classification 'Hexacorn Technique N.55' -Path $propPath -Value $defaultValue -AccessGained $access -Note 'Executables in Explorer MyComputer subkeys run when corresponding events trigger.' -Reference 'https://www.hexacorn.com/blog/2017/01/18/beyond-good-ol-run-key-part-55/'
                
                    if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                        $script:globalPersistenceObjectArray.Add($PersistenceObject)
                    }
                }
            }
        }
    }

    function Get-ExplorerContextMenu {
        Write-Verbose "$hostname - Checking Explorer Context Menu..."
        $contextMenuPath = "Registry::HKEY_CLASSES_ROOT\AllFilesystemObjects\shellex\ContextMenuHandlers\{B7CDF620-DB73-44C0-8611-832B261A0107}"
        $dllProperty = Get-ItemProperty -Path $contextMenuPath -Name '(Default)' -ErrorAction SilentlyContinue
    
        if ($dllProperty -and $dllProperty.'(Default)') {
            $path = $dllProperty.'(Default)'
            if (([System.IO.Path]::IsPathRooted([System.Environment]::ExpandEnvironmentVariables($path))) -eq $false) {
                $path = "C:\Windows\System32\$path"
            }
        
            $propPath = 'HKEY_CLASSES_ROOT\AllFilesystemObjects\shellex\ContextMenuHandlers\{B7CDF620-DB73-44C0-8611-832B261A0107}\(Default)'
            $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Explorer Context Menu Hijacking' -Classification 'Uncatalogued Technique N.13' -Path $propPath -Value $path -AccessGained 'User' -Note 'DLL in context menu handler is loaded when user right-clicks in Explorer.' -Reference 'https://ristbs.github.io/2023/02/15/hijack-explorer-context-menu-for-persistence-and-fun.html'
        
            if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                $script:globalPersistenceObjectArray.Add($PersistenceObject)
            }
        }
    }

    function Get-ServiceControlManagerSecurityDescriptor {
        Write-Verbose "$hostname - Checking Service Control Manager security descriptor..."
        try {
            $currentSDDL = (sc.exe sdshow scmanager 2>$null) -join ''
            
            # Define the default DACL (Discretionary Access Control List) - this is what controls permissions
            # We only check DACL because that's what attackers modify for persistence
            # SACL (System Access Control List) varies legitimately and only controls auditing
            $defaultDACL = 'D:(A;;CC;;;AU)(A;;CCLCRPRC;;;IU)(A;;CCLCRPRC;;;SU)(A;;CCLCRPWPRC;;;SY)(A;;KA;;;BA)(A;;CC;;;AC)(A;;CC;;;S-1-15-3-1024-528118966-3876874398-709513571-1907873084-3598227634-3698730060-278077788-3990600205)'
            
            # Extract only the DACL portion from current SDDL (everything before 'S:')
            $currentDACL = ($currentSDDL -split 'S:')[0]
            
            # Check for specific high-risk permission grants
            $hasDangerousPermissions = $false
            $dangerousPatterns = @()
            
            # Critical: Everyone (WD) has full control (KA) - the primary persistence technique
            if ($currentDACL -match '\(A;;KA;;;WD\)') {
                $hasDangerousPermissions = $true
                $dangerousPatterns += "Everyone group has full control"
            }
            
            # Warning: Built-in Users (BU) or Authenticated Users (AU) have service creation rights
            if ($currentDACL -match '\(A;;[^;]*C[^;]*;;;(BU|AU)\)' -and $currentDACL -notmatch '\(A;;CC;;;AU\)') {
                $hasDangerousPermissions = $true
                $dangerousPatterns += "Broad user groups have service creation rights"
            }
            
            # Compare DACL to detect any permission changes
            if ($currentDACL -ne $defaultDACL) {
                $note = 'Modified SCM security descriptor can allow non-admin processes to create privileged services.'
                if ($dangerousPatterns.Count -gt 0) {
                    $note += " Detected: $($dangerousPatterns -join '; ')"
                }
                
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Service Control Manager Security Descriptor' -Classification 'Uncatalogued Technique N.14' -Path 'Service Control Manager' -Value $currentSDDL -AccessGained 'System' -Note $note -Reference 'https://pentestlab.blog/2023/03/20/persistence-service-control-manager/'
                
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
        catch {
            Write-Verbose "$hostname - Error accessing Service Control Manager: $($_.Exception.Message)"
        }
    }

    function Get-MicrosoftOfficeAIHijacking {
        Write-Verbose "$hostname - Checking for Office AI.exe hijacking..."
        $officePaths = @(
            [System.Environment]::ExpandEnvironmentVariables('%ProgramFiles%\Microsoft Office\root\'),
            [System.Environment]::ExpandEnvironmentVariables('%ProgramFiles(x86)%\Microsoft Office\root\')
        )
    
        foreach ($basePath in $officePaths) {
            if (Test-Path $basePath -ErrorAction SilentlyContinue) {
                $officeDirs = Get-ChildItem $basePath -ErrorAction SilentlyContinue
                foreach ($officeDir in $officeDirs) {
                    $aiPath = "$($officeDir.FullName)\ai.exe"
                    if (Test-Path $aiPath -ErrorAction SilentlyContinue) {
                        $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Microsoft Office AI.exe Hijacking' -Classification 'Uncatalogued Technique N.15' -Path $officeDir.FullName -Value $aiPath -AccessGained 'User' -Note 'AI.exe in Office directories is loaded by Office applications for persistence.' -Reference 'https://twitter.com/laughing_mantis/status/1645268114966470662'
                    
                        if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                            $script:globalPersistenceObjectArray.Add($PersistenceObject)
                        }
                    }
                }
            }
        }
    }

    function Get-DotNetStartupHooks {
        Write-Verbose "$hostname - Getting .NET Startup Hooks..."
    
        # Check user environment variables
        foreach ($hive in $systemAndUsersHives) {
            $envProperty = Get-ItemProperty -Path "$hive\Environment" -Name DOTNET_STARTUP_HOOKS -ErrorAction SilentlyContinue
            if ($envProperty -and $envProperty.DOTNET_STARTUP_HOOKS) {
                $hooks = $envProperty.DOTNET_STARTUP_HOOKS -split ';' | Where-Object { $_ -ne '' }
                foreach ($hook in $hooks) {
                    $propPath = Convert-Path -Path $hive -ErrorAction SilentlyContinue
                    $propPath += "\Environment\DOTNET_STARTUP_HOOKS"
                
                    $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique '.NET Startup Hooks DLL' -Classification 'MITRE ATT&CK T1574.002' -Path $propPath -Value $hook -AccessGained 'User/System' -Note '.NET DLLs in DOTNET_STARTUP_HOOKS are loaded into .NET processes at runtime.' -Reference 'https://persistence-info.github.io/Data/dotnetstartuphooks.html'
                
                    if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                        $script:globalPersistenceObjectArray.Add($PersistenceObject)
                    }
                }
            }
        }
    
        # Check system environment variables
        $systemEnvProperty = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment" -Name DOTNET_STARTUP_HOOKS -ErrorAction SilentlyContinue
        if ($systemEnvProperty -and $systemEnvProperty.DOTNET_STARTUP_HOOKS) {
            $hooks = $systemEnvProperty.DOTNET_STARTUP_HOOKS -split ';' | Where-Object { $_ -ne '' }
            foreach ($hook in $hooks) {
                $propPath = "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment\DOTNET_STARTUP_HOOKS"
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique '.NET Startup Hooks DLL' -Classification 'MITRE ATT&CK T1574.002' -Path $propPath -Value $hook -AccessGained 'System' -Note '.NET DLLs in system DOTNET_STARTUP_HOOKS are loaded into all .NET processes.' -Reference 'https://persistence-info.github.io/Data/dotnetstartuphooks.html'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
    }

    function Parse-NetUser {
        $outputStart = 0
        foreach ($item in $input) {
            if ($item -match '----') {
                $outputStart = 1
                continue
            }
            elseif ($outputStart -eq 0) {
                continue
            }
            if ($item -eq "") {
                continue
            }
            if ($item -match '.*\.$') {
                continue
            }

            $contentArray = @()
            foreach ($line in $item -split '\s{2,}') {
                if ($line -ne '') {
                    $contentArray += $line
                }
            }
 
            foreach ($content in $contentArray) {
                $content = $content -replace '"', ''
                if ($content.Length -ne 0) {
                    New-Object -TypeName PSObject -Property @{"Name" = $content.Trim() }
                }
            }
        }
    }


    function Get-SubornerAttack {
        Write-Verbose "$hostname - Checking for Suborner Attack (hidden users)..."
        try {
            $netUsers = net.exe users 2>$null | Parse-NetUser
            $poshUsers = Get-LocalUser -ErrorAction SilentlyContinue | Select-Object Name
        
            if ($netUsers -and $poshUsers) {
                $diffUsers = Compare-Object -ReferenceObject $poshUsers -DifferenceObject $netUsers -Property Name -ErrorAction SilentlyContinue
                foreach ($user in $diffUsers) {
                    if ($user.SideIndicator -eq '<=') {
                        # User exists in PowerShell but not in net user
                        $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Suborner Attack' -Classification 'Uncatalogued Technique N.16' -Path 'Hidden User Account' -Value $user.Name -AccessGained 'User/System' -Note 'Hidden user account not visible via net user command but detectable with Get-LocalUser. Often paired with RID hijacking for stealthy persistence.' -Reference 'https://r4wsec.com/notes/the_suborner_attack/'
                    
                        if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                            $script:globalPersistenceObjectArray.Add($PersistenceObject)
                        }
                    }
                }
            }
        }
        catch {
            Write-Verbose "$hostname - Error checking for hidden users: $($_.Exception.Message)"
        }
    }

    function Get-DSRMBackdoor {
        Write-Verbose "$hostname - Checking for DSRM backdoor..."
        $dsrmProperty = Get-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Lsa" -Name DsrmAdminLogonBehavior -ErrorAction SilentlyContinue
        if ($dsrmProperty -and $dsrmProperty.DsrmAdminLogonBehavior -EQ 2) {
            $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'DSRM Backdoor' -Classification 'MITRE ATT&CK T1003.003' -Path 'HKLM:\System\CurrentControlSet\Control\Lsa\DsrmAdminLogonBehavior' -Value $dsrmProperty.DsrmAdminLogonBehavior -AccessGained 'System' -Note "DSRM backdoor allows using DSRM password for normal logon when DsrmAdminLogonBehavior is set to 2." -Reference 'https://adsecurity.org/?p=1785'
        
            if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                $script:globalPersistenceObjectArray.Add($PersistenceObject)
            }
        }
    }

    function Get-BootVerificationProgram {
        Write-Verbose "$hostname - Checking Boot Verification Program..."
        $bootProperty = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\BootVerificationProgram" -Name ImagePath -ErrorAction SilentlyContinue
        if ($bootProperty -and $bootProperty.ImagePath) {
            $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Boot Verification Program Hijacking' -Classification 'Uncatalogued Technique N.19' -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\BootVerificationProgram\ImagePath' -Value $bootProperty.ImagePath -AccessGained 'System' -Note "Boot Verification Program runs at boot time in place of legitimate Bootvrfy.exe." -Reference 'https://persistence-info.github.io/Data/bootverificationprogram.html'
        
            if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                $script:globalPersistenceObjectArray.Add($PersistenceObject)
            }
        }
    }

    function Get-AppInitDLLs {
        Write-Verbose "$hostname - Getting AppInit DLLs..."
    
        # Check native AppInit_DLLs
        $appInitProperty = Get-ItemProperty -Path "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Windows" -Name AppInit_DLLs -ErrorAction SilentlyContinue
        if ($appInitProperty -and $appInitProperty.AppInit_DLLs) {
            $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'AppInit DLL Injection' -Classification 'MITRE ATT&CK T1546.010' -Path 'HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs' -Value $appInitProperty.AppInit_DLLs -AccessGained 'System/User' -Note "AppInit DLLs are loaded by user32.dll in every process that loads the Win32 subsystem." -Reference 'https://attack.mitre.org/techniques/T1546/010/'
        
            if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                $script:globalPersistenceObjectArray.Add($PersistenceObject)
            }
        }

        # Check Wow6432Node AppInit_DLLs  
        $appInitProperty = Get-ItemProperty -Path "HKLM:\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows" -Name AppInit_DLLs -ErrorAction SilentlyContinue
        if ($appInitProperty -and $appInitProperty.AppInit_DLLs) {
            $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'AppInit DLL Injection (WOW64)' -Classification 'MITRE ATT&CK T1546.010' -Path 'HKLM:\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs' -Value $appInitProperty.AppInit_DLLs -AccessGained 'System/User' -Note "AppInit DLLs in WOW64 node are loaded by 32-bit processes on 64-bit systems." -Reference 'https://attack.mitre.org/techniques/T1546/010/'
        
            if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                $script:globalPersistenceObjectArray.Add($PersistenceObject)
            }
        }
    }

    function Get-BootExecute {
        Write-Verbose "$hostname - Getting BootExecute executables..."
    
        # Process BootExecute
        $bootExecProperty = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" -Name 'BootExecute' -ErrorAction SilentlyContinue
        if ($bootExecProperty -and $bootExecProperty.BootExecute) {
            $entries = if ($bootExecProperty.BootExecute -is [string]) {
                @($bootExecProperty.BootExecute)
            }
            else {
                $bootExecProperty.BootExecute
            }
        
            foreach ($entry in $entries) {
                if ([string]::IsNullOrWhiteSpace($entry)) { continue }
            
                # Skip the standard legitimate entry
                if ($entry -eq "autocheck autochk *") { continue }
            
                # Extract the executable from the command line
                $executable = ($entry -split '\s+')[0]
            
                # Skip if it's just "autocheck" or "autochk" alone (legitimate components)
                if ($executable -eq "autocheck" -or $executable -eq "autochk") { continue }
            
                # Build full path if not already rooted
                $exePath = if (-not [System.IO.Path]::IsPathRooted([System.Environment]::ExpandEnvironmentVariables($executable))) {
                    "C:\Windows\System32\$executable"
                }
                else { 
                    $executable 
                }
            
                $propPath = (Convert-Path -Path $bootExecProperty.PSPath -ErrorAction SilentlyContinue) + '\BootExecute'
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'BootExecute Binary' -Classification 'MITRE ATT&CK T1547.001' -Path $propPath -Value $entry -ExecutePath $exePath -AccessGained 'System' -Note 'BootExecute programs run before any other process during system startup.' -Reference 'https://attack.mitre.org/techniques/T1547/001/'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }

        # Process BootExecuteNoPnpSync
        $bootExecNoPnpProperty = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" -Name 'BootExecuteNoPnpSync' -ErrorAction SilentlyContinue
        if ($bootExecNoPnpProperty -and $bootExecNoPnpProperty.BootExecuteNoPnpSync) {
            $entries = if ($bootExecNoPnpProperty.BootExecuteNoPnpSync -is [string]) {
                @($bootExecNoPnpProperty.BootExecuteNoPnpSync)
            }
            else {
                $bootExecNoPnpProperty.BootExecuteNoPnpSync
            }
        
            foreach ($entry in $entries) {
                if ([string]::IsNullOrWhiteSpace($entry)) { continue }
            
                # Extract the executable from the command line  
                $executable = ($entry -split '\s+')[0]
            
                # Build full path if not already rooted
                $exePath = if (-not [System.IO.Path]::IsPathRooted([System.Environment]::ExpandEnvironmentVariables($executable))) {
                    "C:\Windows\System32\$executable"
                }
                else { 
                    $executable 
                }
            
                $propPath = (Convert-Path -Path $bootExecNoPnpProperty.PSPath -ErrorAction SilentlyContinue) + '\BootExecuteNoPnpSync'
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'BootExecuteNoPnpSync Binary' -Classification 'MITRE ATT&CK T1547.001' -Path $propPath -Value $entry -ExecutePath $exePath -AccessGained 'System' -Note 'BootExecuteNoPnpSync programs run before other processes during startup without PnP synchronization.' -Reference 'https://attack.mitre.org/techniques/T1547/001/'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
    }

    function Get-NetshHelperDLL {
        Write-Verbose "$hostname - Getting Netsh Helper DLLs..."
        $netshKey = Get-Item 'HKLM:\SOFTWARE\Microsoft\NetSh' -ErrorAction SilentlyContinue
        if ($netshKey) {
            $props = $netshKey | Select-Object -ExpandProperty Property -ErrorAction SilentlyContinue
            foreach ($prop in $props) {
                if ($prop) {
                    $dllProperty = Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\NetSh' -Name $prop -ErrorAction SilentlyContinue
                    if ($dllProperty -and $dllProperty.$prop) {
                        $dll = $dllProperty.$prop
                        $dllPath = if ($dll -like "*.dll") { 
                            if ([System.IO.Path]::IsPathRooted($dll)) { $dll } else { "C:\Windows\System32\$dll" }
                        }
                        else { 
                            "C:\Windows\System32\$dll.dll" 
                        }
                    
                        $propPath = "HKLM:\SOFTWARE\Microsoft\NetSh\$prop"
                    
                        $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Netsh Helper DLL' -Classification 'MITRE ATT&CK T1546.007' -Path $propPath -Value $dllPath -AccessGained 'System/User' -Note 'Netsh Helper DLLs are loaded whenever netsh.exe runs, which may occur during system operations.' -Reference 'https://attack.mitre.org/techniques/T1546/007/'
                    
                        if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                            $script:globalPersistenceObjectArray.Add($PersistenceObject)
                        }
                    }
                }
            }
        }
    }

    function Get-SetupExecute {
        Write-Verbose "$hostname - Getting SetupExecute executables..."
    
        # Process SetupExecute
        $setupExecProperty = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" -Name 'SetupExecute' -ErrorAction SilentlyContinue
        if ($setupExecProperty -and $setupExecProperty.SetupExecute) {
            $exes = $setupExecProperty.SetupExecute -split '\s+' | Where-Object { $_ -ne '' }
            foreach ($exe in $exes) {
                $exePath = if (([System.IO.Path]::IsPathRooted([System.Environment]::ExpandEnvironmentVariables($exe))) -eq $false) {
                    "C:\Windows\System32\$exe"
                }
                else { $exe }
            
                $propPath = (Convert-Path -Path $setupExecProperty.PSPath -ErrorAction SilentlyContinue) + '\SetupExecute'
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'SetupExecute Binary' -Classification 'Uncatalogued Technique N.20' -Path $propPath -Value $exePath -AccessGained 'System' -Note 'SetupExecute programs run during system startup before other processes.' -Reference 'https://github.com/rad9800/BootExecuteEDR'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }

        # Process SetupExecuteNoPnpSync
        $setupExecNoPnpProperty = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" -Name 'SetupExecuteNoPnpSync' -ErrorAction SilentlyContinue
        if ($setupExecNoPnpProperty -and $setupExecNoPnpProperty.SetupExecuteNoPnpSync) {
            $exes = $setupExecNoPnpProperty.SetupExecuteNoPnpSync -split '\s+' | Where-Object { $_ -ne '' }
            foreach ($exe in $exes) {
                $exePath = if (([System.IO.Path]::IsPathRooted([System.Environment]::ExpandEnvironmentVariables($exe))) -eq $false) {
                    "C:\Windows\System32\$exe"
                }
                else { $exe }
            
                $propPath = (Convert-Path -Path $setupExecNoPnpProperty.PSPath -ErrorAction SilentlyContinue) + '\SetupExecuteNoPnpSync'
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'SetupExecuteNoPnpSync Binary' -Classification 'Uncatalogued Technique N.20' -Path $propPath -Value $exePath -AccessGained 'System' -Note 'SetupExecuteNoPnpSync programs run during startup without PnP synchronization.' -Reference 'https://github.com/rad9800/BootExecuteEDR'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
    }

    function Get-PlatformExecute {
        Write-Verbose "$hostname - Getting PlatformExecute executables..."
        $platformExecProperty = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" -Name 'PlatformExecute' -ErrorAction SilentlyContinue
        if ($platformExecProperty -and $platformExecProperty.PlatformExecute) {
            $exes = $platformExecProperty.PlatformExecute -split '\s+' | Where-Object { $_ -ne '' }
            foreach ($exe in $exes) {
                $exePath = if (([System.IO.Path]::IsPathRooted([System.Environment]::ExpandEnvironmentVariables($exe))) -eq $false) {
                    "C:\Windows\System32\$exe"
                }
                else { $exe }
            
                $propPath = (Convert-Path -Path $platformExecProperty.PSPath -ErrorAction SilentlyContinue) + '\PlatformExecute'
            
                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'PlatformExecute Binary' -Classification 'Uncatalogued Technique N.21' -Path $propPath -Value $exePath -AccessGained 'System' -Note 'PlatformExecute programs run during platform-specific startup operations.' -Reference 'https://github.com/rad9800/BootExecuteEDR'
            
                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                }
            }
        }
    }

    
    function Get-ScheduledTasks {
        Write-Verbose "$hostname - Getting scheduled tasks..."

        try {
            # Primary method: Use Get-ScheduledTask
            $tasks = $null
            try {
                $tasks = Get-ScheduledTask -ErrorAction Stop
                Write-Verbose "$hostname - Retrieved $($tasks.Count) scheduled tasks"
            }
            catch {
                Write-Verbose "$hostname - Get-ScheduledTask failed: $($_.Exception.Message)"
                Write-Verbose "$hostname - Attempting schtasks.exe fallback"
            
                # Fallback method: Parse schtasks output
                try {
                    $schtasksOutput = schtasks.exe /query /fo csv /v 2>$null
                    if ($schtasksOutput -and $schtasksOutput.Count -gt 1) {
                        $csvData = $schtasksOutput | ConvertFrom-Csv -ErrorAction Stop
                        Write-Verbose "$hostname - Parsed $($csvData.Count) tasks from schtasks.exe"
                    
                        foreach ($row in $csvData) {
                            if ($row.'Task To Run' -and $row.'Task To Run' -ne 'N/A' -and $row.'Task To Run'.Trim() -ne '') {
                                $taskPath = if ($row.TaskName) { $row.TaskName } else { "Unknown" }
                                $executable = $row.'Task To Run'
                                $status = if ($row.Status) { $row.Status } else { "Unknown" }
                            
                                $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Scheduled Task' -Classification 'MITRE ATT&CK T1053.005' -Path $taskPath -Value $executable -AccessGained 'User/System' -Note "Scheduled tasks execute actions and run files when triggered." -Reference 'https://attack.mitre.org/techniques/T1053/005/' -Status $status
                            
                                if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                                    $script:globalPersistenceObjectArray.Add($PersistenceObject)
                                }
                            }
                        }
                        Write-Verbose "$hostname - Completed fallback task processing"
                        return
                    }
                    else {
                        Write-Verbose "$hostname - schtasks.exe returned no usable output"
                    }
                }
                catch {
                    Write-Verbose "$hostname - schtasks.exe fallback also failed: $($_.Exception.Message)"
                }
            }

            if (-not $tasks -or $tasks.Count -eq 0) {
                Write-Verbose "$hostname - No scheduled tasks retrieved from any method"
                return
            }
        
            Write-Verbose "$hostname - Processing $($tasks.Count) scheduled tasks"
            $processedCount = 0
            $errorCount = 0

            foreach ($task in $tasks) {
                try {
                    # Skip tasks with no actions
                    if (-not $task.Actions -or $task.Actions.Count -eq 0) { 
                        continue 
                    }

                    # Safely get task info with error handling
                    $taskInfo = $null
                    try {
                        $taskInfo = Get-ScheduledTaskInfo -TaskName $task.TaskName -TaskPath $task.TaskPath -ErrorAction Stop
                    }
                    catch {
                        Write-Verbose "$hostname - Could not retrieve task info for $($task.TaskName): $($_.Exception.Message)"
                    }

                    # Process each action in the task
                    foreach ($action in $task.Actions) {
                        if (-not $action.Execute) { continue }
                    
                        try {
                            $executable = [Environment]::ExpandEnvironmentVariables($action.Execute)
                            $arguments = if ($action.Arguments) { [Environment]::ExpandEnvironmentVariables($action.Arguments) } else { "" }
                            $fullCommand = if ($arguments) { "$executable $arguments" } else { $executable }

                            # Determine access level
                            $access = switch ($task.Principal.UserId) {
                                { $_ -in @('SYSTEM', 'S-1-5-18', 'S-1-5-19', 'S-1-5-20') } { 'System' }
                                default { 
                                    if ($task.Principal.RunLevel -eq 'Highest') { 'User/Admin' } else { 'User' }
                                }
                            }

                            $taskPath = $task.TaskPath + $task.TaskName

                            # Safely get task state with error handling
                            $statusString = "Unknown"
                            try {
                                $statusString = $task.State.ToString()
                                if ($taskInfo -and $taskInfo.LastTaskResult -ne $null) {
                                    $statusString += "/$($taskInfo.LastTaskResult)"
                                }
                                if ($task.State -eq 'Disabled') { 
                                    $taskPath += " [DISABLED]" 
                                    $statusString = "Disabled"
                                }
                            }
                            catch {
                                Write-Verbose "$hostname - Could not determine state for task $($task.TaskName), using 'Unknown'"
                            }

                            # Build note with author information
                            $note = "Scheduled tasks execute actions and run files when triggered."
                            try {
                                if ($task.Author -and $task.Author -ne 'Microsoft Corporation' -and $task.Author.Trim() -ne '') {
                                    $note += " Author: $($task.Author)."
                                }
                            }
                            catch {
                                # Ignore author retrieval errors
                            }

                            $PersistenceObject = New-PersistenceObject -Hostname $hostname -Technique 'Scheduled Task' -Classification 'MITRE ATT&CK T1053.005' -Path $taskPath -Value $fullCommand -AccessGained $access -Note $note -Reference 'https://attack.mitre.org/techniques/T1053/005/' -Status $statusString

                            if ((Test-ShouldIncludeEntry $PersistenceObject $Mode) -and (-not (Test-ExcludeEntry $PersistenceObject))) {
                                $script:globalPersistenceObjectArray.Add($PersistenceObject)
                                $processedCount++
                            }
                        }
                        catch {
                            Write-Verbose "$hostname - Error processing action for task $($task.TaskName): $($_.Exception.Message)"
                            $errorCount++
                            continue
                        }
                    }
                }
                catch {
                    Write-Verbose "$hostname - Error processing task $($task.TaskName): $($_.Exception.Message)"
                    $errorCount++
                    continue
                }
            }
        
            Write-Verbose "$hostname - Completed scheduled task processing: $processedCount items processed"
            if ($errorCount -gt 0) {
                Write-Verbose "$hostname - Encountered $errorCount errors during task processing"
            }
        }
        catch {
            Write-Verbose "$hostname - Critical error in scheduled task enumeration: $($_.Exception.Message)"
        }
    }


    # Enhanced error handling wrapper
    try {
        # Main execution logic
        Write-Verbose "$hostname - Starting execution..."
        # Enhanced error handling wrapper
        # Main execution logic
        Write-Verbose "=== MAIN EXECUTION STARTED ==="
        Write-Verbose "$hostname - Starting execution with Mode: $Mode, Technique: $Technique"
        if ($Technique -eq 'All') {
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Registry Run Keys..." -PercentComplete 2 }
            Get-RunKeys
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Image File Execution Options..." -PercentComplete 4 }
            Get-ImageFileExecutionOptions
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Windows Services..." -PercentComplete 6 }
            Get-WindowsServices
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Scheduled Tasks..." -PercentComplete 8 }
            Get-ScheduledTasks
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting NLDP DLL Override..." -PercentComplete 10 }
            Get-NLDPDllOverridePath
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting AeDebug..." -PercentComplete 12 }
            Get-AeDebug
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting WerFault Hangs..." -PercentComplete 14 }
            Get-WerFaultHangs
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Command AutoRun..." -PercentComplete 16 }
            Get-CmdAutoRun
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Explorer Load..." -PercentComplete 18 }
            Get-ExplorerLoad
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Winlogon Userinit..." -PercentComplete 20 }
            Get-WinlogonUserinit
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Winlogon Shell..." -PercentComplete 22 }
            Get-WinlogonShell
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Terminal Profile..." -PercentComplete 24 }
            Get-TerminalProfileStartOnUserLogin
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting AppCert DLLs..." -PercentComplete 26 }
            Get-AppCertDlls
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Service DLLs..." -PercentComplete 28 }
            Get-ServiceDlls
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting GP Extension DLLs..." -PercentComplete 30 }
            Get-GPExtensionDlls
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Winlogon MPNotify..." -PercentComplete 32 }
            Get-WinlogonMPNotify
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting CHM Helper DLL..." -PercentComplete 34 }
            Get-CHMHelperDll
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting HHCtrl Hijacking..." -PercentComplete 36 }
            Get-HHCtrlHijacking
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Startup Programs..." -PercentComplete 38 }
            Get-StartupPrograms
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting User Init Script..." -PercentComplete 40 }
            Get-UserInitMprScript
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Autodial DLL..." -PercentComplete 42 }
            Get-AutodialDLL
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting LSA Extensions..." -PercentComplete 44 }
            Get-LsaExtensions
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Server Plugin DLL..." -PercentComplete 46 }
            Get-ServerLevelPluginDll
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Password Filter..." -PercentComplete 48 }
            Get-LsaPasswordFilter
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Auth Packages..." -PercentComplete 50 }
            Get-LsaAuthenticationPackages
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Security Packages..." -PercentComplete 52 }
            Get-LsaSecurityPackages
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Notification Packages..." -PercentComplete 54 }
            Get-WinlogonNotificationPackages
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Explorer Tools..." -PercentComplete 56 }
            Get-ExplorerTools
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting .NET Debugger..." -PercentComplete 58 }
            Get-DotNetDebugger
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Error Handler..." -PercentComplete 60 }
            Get-ErrorHandlerCmd
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting WMI Events..." -PercentComplete 62 }
            Get-WMIEventsSubscrition
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting TS Initial Program..." -PercentComplete 64 }
            Get-TSInitialProgram
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Accessibility Tools..." -PercentComplete 66 }
            Get-AccessibilityTools
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting AMSI Providers..." -PercentComplete 68 }
            Get-AMSIProviders
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting PowerShell Profiles..." -PercentComplete 70 }
            Get-PowershellProfiles
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Silent Exit Monitor..." -PercentComplete 72 }
            Get-SilentExitMonitor
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Telemetry Controller..." -PercentComplete 74 }
            Get-TelemetryController
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting RDP WDS Programs..." -PercentComplete 76 }
            Get-RDPWDSStartupPrograms
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting BITS Jobs..." -PercentComplete 78 }
            Get-BitsJobsNotifyCmdLine
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Screensaver..." -PercentComplete 80 }
            Get-Screensaver
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Power Automate..." -PercentComplete 82 }
            Get-PowerAutomate
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Office Templates..." -PercentComplete 84 }
            Get-OfficeTemplates
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Context Menu..." -PercentComplete 86 }
            Get-ExplorerContextMenu
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting SCM Security..." -PercentComplete 88 }
            Get-ServiceControlManagerSecurityDescriptor
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Office AI Hijacking..." -PercentComplete 90 }
            Get-MicrosoftOfficeAIHijacking
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting .NET Startup Hooks..." -PercentComplete 92 }
            Get-DotNetStartupHooks
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Suborner Attack..." -PercentComplete 94 }
            Get-SubornerAttack
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting DSRM Backdoor..." -PercentComplete 96 }
            Get-DSRMBackdoor
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Boot Verification..." -PercentComplete 97 }
            Get-BootVerificationProgram
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting AppInit DLLs..." -PercentComplete 98 }
            Get-AppInitDLLs
            if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Boot Execute..." -PercentComplete 99 }
            Get-BootExecute
            Get-NetshHelperDLL
            Get-SetupExecute
            Get-PlatformExecute
            Get-AppPaths
        }
        else {
            switch ($Technique) {
                'RegistryRunKeys' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Registry Run Keys..." -PercentComplete 50 }
                    Get-RunKeys
                    break 
                }
                'ImageFileExecutionOptions' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Image File Execution Options..." -PercentComplete 50 }
                    Get-ImageFileExecutionOptions
                    break 
                }
                'ScheduledTasks' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Scheduled Tasks..." -PercentComplete 50 }
                    Get-ScheduledTasks
                    break 
                }
                'Services' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Windows Services..." -PercentComplete 50 }
                    Get-WindowsServices
                    break 
                }
                'NLDPDllOverridePath' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting NLDP DLL Override..." -PercentComplete 50 }
                    Get-NLDPDllOverridePath
                    break 
                }
                'AeDebug' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting AeDebug..." -PercentComplete 50 }
                    Get-AeDebug
                    break 
                }
                'WerFaultHangs' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting WerFault Hangs..." -PercentComplete 50 }
                    Get-WerFaultHangs
                    break 
                }
                'CmdAutoRun' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Command AutoRun..." -PercentComplete 50 }
                    Get-CmdAutoRun
                    break 
                }
                'ExplorerLoad' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Explorer Load..." -PercentComplete 50 }
                    Get-ExplorerLoad
                    break 
                }
                'WinlogonUserinit' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Winlogon Userinit..." -PercentComplete 50 }
                    Get-WinlogonUserinit
                    break 
                }
                'WinlogonShell' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Winlogon Shell..." -PercentComplete 50 }
                    Get-WinlogonShell
                    break 
                }
                'TerminalProfileStartOnUserLogin' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Terminal Profile..." -PercentComplete 50 }
                    Get-TerminalProfileStartOnUserLogin
                    break 
                }
                'AppCertDlls' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting AppCert DLLs..." -PercentComplete 50 }
                    Get-AppCertDlls
                    break 
                }
                'ServiceDlls' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Service DLLs..." -PercentComplete 50 }
                    Get-ServiceDlls
                    break 
                }
                'GPExtensionDlls' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting GP Extension DLLs..." -PercentComplete 50 }
                    Get-GPExtensionDlls
                    break 
                }
                'WinlogonMPNotify' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Winlogon MPNotify..." -PercentComplete 50 }
                    Get-WinlogonMPNotify
                    break 
                }
                'CHMHelperDll' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting CHM Helper DLL..." -PercentComplete 50 }
                    Get-CHMHelperDll
                    break 
                }
                'HHCtrlHijacking' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting HHCtrl Hijacking..." -PercentComplete 50 }
                    Get-HHCtrlHijacking
                    break 
                }
                'StartupPrograms' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Startup Programs..." -PercentComplete 50 }
                    Get-StartupPrograms
                    break 
                }
                'UserInitMprScript' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting User Init Script..." -PercentComplete 50 }
                    Get-UserInitMprScript
                    break 
                }
                'AutodialDLL' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Autodial DLL..." -PercentComplete 50 }
                    Get-AutodialDLL
                    break 
                }
                'LsaExtensions' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting LSA Extensions..." -PercentComplete 50 }
                    Get-LsaExtensions
                    break 
                }
                'ServerLevelPluginDll' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Server Plugin DLL..." -PercentComplete 50 }
                    Get-ServerLevelPluginDll
                    break 
                }
                'LsaPasswordFilter' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Password Filter..." -PercentComplete 50 }
                    Get-LsaPasswordFilter
                    break 
                }
                'LsaAuthenticationPackages' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Auth Packages..." -PercentComplete 50 }
                    Get-LsaAuthenticationPackages
                    break 
                }
                'LsaSecurityPackages' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Security Packages..." -PercentComplete 50 }
                    Get-LsaSecurityPackages
                    break 
                }
                'WinlogonNotificationPackages' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Notification Packages..." -PercentComplete 50 }
                    Get-WinlogonNotificationPackages
                    break 
                }
                'ExplorerTools' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Explorer Tools..." -PercentComplete 50 }
                    Get-ExplorerTools
                    break 
                }
                'DotNetDebugger' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting .NET Debugger..." -PercentComplete 50 }
                    Get-DotNetDebugger
                    break 
                }
                'ErrorHandlerCmd' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Error Handler..." -PercentComplete 50 }
                    Get-ErrorHandlerCmd
                    break 
                }
                'WMIEventsSubscrition' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting WMI Events..." -PercentComplete 50 }
                    Get-WMIEventsSubscrition
                    break 
                }
                'AppPaths' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting App Paths..." -PercentComplete 50 }
                    Get-AppPaths
                    break 
                }
                'TerminalServicesInitialProgram' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting TS Initial Program..." -PercentComplete 50 }
                    Get-TSInitialProgram
                    break 
                }
                'AccessibilityTools' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Accessibility Tools..." -PercentComplete 50 }
                    Get-AccessibilityTools
                    break 
                }
                'AMSIProviders' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting AMSI Providers..." -PercentComplete 50 }
                    Get-AMSIProviders
                    break 
                }
                'PowershellProfiles' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting PowerShell Profiles..." -PercentComplete 50 }
                    Get-PowershellProfiles
                    break 
                }
                'SilentExitMonitor' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Silent Exit Monitor..." -PercentComplete 50 }
                    Get-SilentExitMonitor
                    break 
                }
                'TelemetryController' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Telemetry Controller..." -PercentComplete 50 }
                    Get-TelemetryController
                    break 
                }
                'RDPWDSStartupPrograms' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting RDP WDS Programs..." -PercentComplete 50 }
                    Get-RDPWDSStartupPrograms
                    break 
                }
                'BitsJobsNotify' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting BITS Jobs..." -PercentComplete 50 }
                    Get-BitsJobsNotifyCmdLine
                    break 
                }
                'Screensaver' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Screensaver..." -PercentComplete 50 }
                    Get-Screensaver
                    break 
                }
                'PowerAutomate' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Power Automate..." -PercentComplete 50 }
                    Get-PowerAutomate
                    break 
                }
                'OfficeAddinsAndTemplates' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Office Templates..." -PercentComplete 50 }
                    Get-OfficeTemplates
                    break 
                }
                'ExplorerContextMenu' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Context Menu..." -PercentComplete 50 }
                    Get-ExplorerContextMenu
                    break 
                }
                'ServiceControlManagerSD' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting SCM Security..." -PercentComplete 50 }
                    Get-ServiceControlManagerSecurityDescriptor
                    break 
                }
                'OfficeAiHijacking' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Office AI Hijacking..." -PercentComplete 50 }
                    Get-MicrosoftOfficeAIHijacking
                    break 
                }
                'DotNetStartupHooks' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting .NET Startup Hooks..." -PercentComplete 50 }
                    Get-DotNetStartupHooks
                    break 
                }
                'SubornerAttack' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Suborner Attack..." -PercentComplete 50 }
                    Get-SubornerAttack
                    break 
                }
                'DSRMBackdoor' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting DSRM Backdoor..." -PercentComplete 50 }
                    Get-DSRMBackdoor
                    break 
                }
                'BootVerificationProgram' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Boot Verification..." -PercentComplete 50 }
                    Get-BootVerificationProgram
                    break 
                }
                'AppInitDLLs' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting AppInit DLLs..." -PercentComplete 50 }
                    Get-AppInitDLLs
                    break 
                }
                'BootExecute' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Boot Execute..." -PercentComplete 50 }
                    Get-BootExecute
                    break 
                }
                'NetshHelperDLL' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Netsh Helper DLL..." -PercentComplete 50 }
                    Get-NetshHelperDLL
                    break 
                }
                'SetupExecute' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Setup Execute..." -PercentComplete 50 }
                    Get-SetupExecute
                    break 
                }
                'PlatformExecute' { 
                    if (-not $Quiet) { Write-Progress -Activity "Hunt-Persistence" -Status "Getting Platform Execute..." -PercentComplete 50 }
                    Get-PlatformExecute
                    break 
                }
            }
        }

        # Convert to array for further processing
        $script:globalPersistenceObjectArray = @($script:globalPersistenceObjectArray)
        
        # CRITICAL: Close registry handles before attempting dismount
        Write-Verbose "Closing registry handles after persistence hunting..."
        Close-RegistryHandles
    
        # Handle CSV export
        if ($OutputCSV) {
            try {
                if ($null -eq $script:globalPersistenceObjectArray -or $script:globalPersistenceObjectArray.Count -eq 0) {
                    # Create empty CSV with headers
                    $headers = @("Hostname", "Technique", "Classification", "Path", "Execute Path", "Value", "SHA256", "Rights", "Note", "Reference", "Signature", "IsBuiltinBinary", "IsLolbin", "Flag", "Status", "LnkTargetPath", "LnkTargetHash")
                    $headerLine = '"' + ($headers -join '","') + '"'
                    $headerLine | Out-File -FilePath $OutputCSV -Encoding UTF8 -ErrorAction Stop

                    if (-not $Quiet) {
                        Write-Host "Empty results exported to: $OutputCSV" -ForegroundColor Yellow
                    }
                }
                else {
                    # Helper function to sanitize individual fields
                    function Sanitize-CSVField {
                        param([string]$Value)
        
                        if ([string]::IsNullOrEmpty($Value)) { return "" }
        
                        # Convert to string and handle null/empty
                        $sanitized = $Value.ToString().Trim()
        
                        # Remove control characters and non-printable chars
                        $sanitized = $sanitized -replace '[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]', ''
        
                        # Excel formula injection protection - escape dangerous starting characters
                        if ($sanitized -match '^[=@+\-]') {
                            $sanitized = "'" + $sanitized
                        }
        
                        # Replace line breaks with spaces
                        $sanitized = $sanitized -replace '[\r\n]+', ' ' -replace '\s+', ' '
        
                        # Limit length for Excel (32,767 character limit per cell)
                        if ($sanitized.Length -gt 32767) {
                            $sanitized = $sanitized.Substring(0, 32764) + "..."
                        }
        
                        # Escape quotes for CSV
                        $sanitized = $sanitized -replace '"', '""'
        
                        return $sanitized
                    }

                    # Export using Export-Csv with proper handling
                    $csvData = foreach ($obj in $script:globalPersistenceObjectArray) {
                        [PSCustomObject]@{
                            'Hostname'        = if ($obj.Hostname) { Sanitize-CSVField $obj.Hostname } else { "" }
                            'Technique'       = if ($obj.Technique) { Sanitize-CSVField $obj.Technique } else { "" }
                            'Classification'  = if ($obj.Classification) { Sanitize-CSVField $obj.Classification } else { "" }
                            'Path'            = if ($obj.Path) { Sanitize-CSVField $obj.Path } else { "" }
                            'Execute Path'    = if ($obj.'Execute Path') { Sanitize-CSVField $obj.'Execute Path' } else { "" }
                            'Value'           = if ($obj.Value) { Sanitize-CSVField $obj.Value } else { "" }
                            'SHA256'          = if ($obj.SHA256) { Sanitize-CSVField $obj.SHA256 } else { "" }
                            'Rights'          = if ($obj.Rights) { Sanitize-CSVField $obj.Rights } else { "" }
                            'Note'            = if ($obj.Note) { Sanitize-CSVField $obj.Note } else { "" }
                            'Reference'       = if ($obj.Reference) { Sanitize-CSVField $obj.Reference } else { "" }
                            'Signature'       = if ($obj.Signature) { Sanitize-CSVField $obj.Signature } else { "" }
                            'IsBuiltinBinary' = if ($obj.IsBuiltinBinary) { Sanitize-CSVField $obj.IsBuiltinBinary.ToString() } else { "" }
                            'IsLolbin'        = if ($obj.IsLolbin) { Sanitize-CSVField $obj.IsLolbin.ToString() } else { "" }
                            'Flag'            = if ($obj.Flag) { Sanitize-CSVField $obj.Flag } else { "" }
                            'Status'          = if ($obj.Status) { Sanitize-CSVField $obj.Status } else { "" }
                            'LnkTargetPath'   = if ($obj.PSObject.Properties.Name -contains 'LnkTargetPath' -and $obj.LnkTargetPath) { Sanitize-CSVField $obj.LnkTargetPath } else { "" }
                            'LnkTargetHash'   = if ($obj.PSObject.Properties.Name -contains 'LnkTargetHash' -and $obj.LnkTargetHash) { Sanitize-CSVField $obj.LnkTargetHash } else { "" }
                        }
                    }

                    $csvData | Export-Csv -Path $OutputCSV -NoTypeInformation -Encoding UTF8 -ErrorAction Stop

                    if (-not $Quiet) {
                        Write-Host "Results exported to: $OutputCSV" -ForegroundColor Green
                        Write-Host "Total items exported: $($csvData.Count)" -ForegroundColor Cyan
                    }
                }
            }
            catch {
                Write-Error "Failed to export CSV to $OutputCSV : $($_.Exception.Message)"
                if ($PassThru) { return @() }
                return
            }
        }

    }
    catch {
        Write-Error "Critical error during persistence hunting: $($_.Exception.Message)"
    }

    # Display results to console (unless Quiet is specified)
    if (-not $Quiet) {
        if ($null -eq $script:globalPersistenceObjectArray -or $script:globalPersistenceObjectArray.Count -eq 0) {
            Write-Host "`n[X] No persistence mechanisms found" -ForegroundColor Red
        }
        else {
            # Summary
            $modeText = switch ($Mode) {
                'Aggressive' { 
                    if ($Insane) { "insane mode" } else { "aggressive mode" }
                }
                'All' { "all mode" }
                default { "auto mode" }
            }
            Write-Host "-------------------- $($script:globalPersistenceObjectArray.Count) potential persistence mechanisms ($modeText) --------------------" -ForegroundColor Green
            # Use indexed access instead of foreach
            for ($i = 0; $i -lt $script:globalPersistenceObjectArray.Count; $i++) {
                try {
                    Write-ColoredPersistenceResult $script:globalPersistenceObjectArray[$i]
                }
                catch {
                    Write-Verbose "Error displaying result: $($_.Exception.Message)"
                    continue
                }
            }

            Write-Host ""
            Write-Host "-------------------- $($script:globalPersistenceObjectArray.Count) potential persistence mechanisms ($modeText) --------------------" -ForegroundColor Green
        }
        Write-Host ""
    }

    # Return objects only if PassThru is specified
    if ($PassThru) {
        Write-Verbose "Returning $($script:globalPersistenceObjectArray.Count) objects via PassThru"
        return $script:globalPersistenceObjectArray
    }

    # Final cleanup
    try {
        Dismount-AllRegistryHives -Quiet:$Quiet
        
        if (-not $Quiet) {
            Write-Progress -Activity "Hunt-Persistence" -Completed
        }
    }
    catch {
        Write-Warning "Cleanup error: $($_.Exception.Message)"
    }
}


Function Hunt-Logs {
    [CmdletBinding()]
    <#
.SYNOPSIS
Comprehensive DFIR tool for hunting threats across Windows Event Logs and file systems with advanced filtering and IOC detection.

.DESCRIPTION
Hunt-Logs searches Windows Event Logs and file systems for indicators of compromise (IOCs), suspicious activities, and security events. 
Supports live system analysis, offline EVTX examination, automated threat hunting modes, and flexible export capabilities.

Key Features:
- Time-based log filtering with multiple date formats
- String-based IOC searching with wildcard support
- Event ID filtering and exclusion
- Automated hunting modes with predefined IOCs
- File system log scanning (aggressive mode)
- CSV export and EVTX archive creation
- Timezone conversion support
- Deduplication and intelligent result sorting

.PARAMETER StartDate
Start date for log search. Accepts multiple formats:
- DateTime objects: [datetime]"2025-01-01 10:00:00"
- Relative time strings: '7D' (days), '24H' (hours), '30M' (minutes)
- Keyword: 'Now' for current time
Default: If not specified, retrieves ALL available logs (no time filter)

.PARAMETER EndDate
End date for log search. Uses same formats as StartDate.
Default: If StartDate specified without EndDate, defaults to 'Now' (current time)
Note: Cannot specify EndDate without StartDate

.PARAMETER Search
Array of strings to search for in event messages. Case-insensitive pattern matching.
TAKES PRECEDENCE over -Exclude when specified. Any event matching a Search string will be included even if it matches Exclude strings.
Note: By default, only searches message text. Use -SearchXML to also search XML event data.
Special characters are automatically escaped for safe matching.

.PARAMETER SearchXML
Enables searching in formatted XML event data in addition to message text. Requires -Search parameter.
XML is searched in the same format as displayed (e.g., search "ProcessID: 10468" to find that value in XML).
Matched strings in XML will be highlighted in red when displayed.
WARNING: Searching XML significantly impacts performance. Only use when IOCs are known to appear in XML fields.
Default: Disabled (searches messages only for better performance)

.PARAMETER Exclude  
Array of strings to exclude from results. Events containing these strings are filtered out.
OVERRIDDEN by -Search parameter. If an event matches both Search and Exclude, it will be included.

.PARAMETER EventId
Array of Event IDs to include. Only events with these IDs will be returned.

.PARAMETER ExcludeEventId
Array of Event IDs to exclude. Takes precedence over all other filters including -Search.
Use for filtering out noise (e.g., ExcludeEventId 4634 to remove logoff events).

.PARAMETER ProcessID
Array of Process IDs to filter for. Only events with these Process IDs will be included.
Works as additive filter with -Search (event must match both).
Example: -ProcessID 1234,5678

.PARAMETER ThreadID
Array of Thread IDs to filter for. Only events with these Thread IDs will be included.
Works as additive filter with -Search (event must match both).
Example: -ThreadID 9876,5432

.PARAMETER LogNames
Array of log names to search. If not specified, searches all available logs with activity.
Examples: "Security", "System", "Application", "Microsoft-Windows-PowerShell/Operational"

.PARAMETER SortOrder
Sort order for results. Valid values: "NewestFirst" (default), "OldestFirst"

.PARAMETER XML
Controls XML data display. 
- 0: Disable XML display
- Positive number: Truncate XML to specified character length
- -1: Show full XML (use with caution for large datasets)
Default: 0 (disabled)

.PARAMETER MSG
Controls message display truncation.
- 0: Disable message display
- Positive number: Truncate messages to specified character length  
- -1: Show full messages
Default: 1000 characters

.PARAMETER MaxPrint
Maximum characters to print before truncating output. Use to prevent console overflow.
- 0: No limit (default)
- Positive number: Stop printing after specified character count
Warning: Large result sets can overwhelm the console without this limit.

.PARAMETER Timezone
Target timezone for time display and input interpretation. System timezone used if not specified.
Accepts: 'UTC', 'EST', 'EDT', 'CST', 'CDT', 'MST', 'MDT', 'PST', 'PDT' or full timezone names
Example: -Timezone "UTC" displays all times in UTC regardless of system timezone

.PARAMETER FolderPath
Path to folder containing EVTX files for offline analysis, or path to specific .evtx file.
When specified, analyzes archived logs instead of live system logs.

.PARAMETER Aggressive
Enables file system scanning for .log files containing IOCs.
- Empty string or switch: Scans entire C:\ drive
- Specific path: Scans only specified directory
Requires -Search parameter. Results cached for performance on subsequent C:\ scans.
WARNING: Full C:\ scans can be time-intensive. Files >100MB automatically skipped.

.PARAMETER Auto
Automated hunting mode using the full GlobalLogIOCs list.
Applies all IOCs from $script:GlobalLogIOCs to the search.
User can specify any StartDate, EndDate, LogNames, and other parameters.
Auto mode does not enforce any date ranges or log provider restrictions.

.PARAMETER StopLogging
Stops Windows Event Log service and configures logs for forensic preservation.
Sets logs to archive mode (no overwrite) and increases size limits.
Requires Administrator privileges. Use during active incident response to preserve evidence.
WARNING: Remember to restart EventLog service after forensics: Start-Service EventLog

.PARAMETER Export
Exports all EVTX files to compressed ZIP archive.
- Switch only: Saves to temp directory with auto-generated name
- Directory path: Saves to specified directory with auto-generated name  
- Full path with .zip: Saves to exact specified location
Requires Administrator privileges for complete log access. Uses wevtutil for active logs.

.PARAMETER PassThru
Returns PowerShell objects for programmatic processing instead of console output.
Use with -Quiet for silent operation. Results accessible via returned object array.

.PARAMETER Quiet
Suppresses all console output. Use with -PassThru or -OutputCSV for silent operation.

.PARAMETER OutputCSV
Exports results to CSV format for analysis in Excel or other tools.
- Switch only: Saves to current directory with auto-generated name
- Directory path: Saves to specified directory with auto-generated name
- Full path with .csv: Saves to exact specified location
CSV includes all fields: timestamps, event data, matched strings, XML data, file system results.

.PARAMETER MaxEvents
Maximum events to retrieve PER LOG before filtering. Controls memory usage and performance.
- 0: No limit (retrieves ALL events - USE WITH CAUTION on large logs)
- Positive number: Limits events retrieved per log (default: 100000)

IMPORTANT: Get-WinEvent with MaxEvents returns events in the following order:
- With -SortOrder "NewestFirst" (default): Returns MOST RECENT events first
- With -SortOrder "OldestFirst": Returns OLDEST events first (reverses retrieval order)

WARNING: Setting MaxEvents too low may cause you to miss events outside the retrieved window.
Example: MaxEvents 1000 on a log with 500k events = only 0.2% coverage

.EXAMPLE
Hunt-Logs
Searches last 7 days of all logs with no filtering (default behavior with warning).

.EXAMPLE
Hunt-Logs -StartDate "7D" -Search "mimikatz","sekurlsa" -OutputCSV "C:\DFIR\results.csv"
Searches last 7 days for Mimikatz indicators, exports to CSV.

.EXAMPLE
Hunt-Logs -StartDate "2025-01-01" -EndDate "2025-01-31" -Search "powershell.exe","encoded" -LogNames "Security","Microsoft-Windows-PowerShell/Operational" -Timezone "UTC"
Searches January 2025 in UTC time for PowerShell IOCs in specific logs.

.EXAMPLE
Hunt-Logs -Auto 2 -OutputCSV "C:\Hunt\"
Runs Level 2 automated hunt (30-day comprehensive) with CSV export.

.EXAMPLE
Hunt-Logs -StartDate "24H" -Search "lateral movement","psexec" -Aggressive "C:\Windows\Logs" -ExcludeEventId 4634,4624
Searches last 24 hours for lateral movement IOCs, scans filesystem, excludes logon/logoff noise.

.EXAMPLE
$results = Hunt-Logs -StartDate "48H" -Search "ransomware" -PassThru -Quiet
Silent search returning objects for custom processing.

.EXAMPLE
Hunt-Logs -FolderPath "C:\Evidence\EVTX" -Search "malicious.exe" -XML -1 -MSG -1
Analyzes offline EVTX files with full XML and message display.

.EXAMPLE
Hunt-Logs -Export "C:\Forensics\Evidence.zip"
Exports all EVTX files to specified archive for offline analysis.

.EXAMPLE
Hunt-Logs -StopLogging
Stops event logging and configures preservation mode during active incident.

.EXAMPLE
Hunt-Logs -ClearCache
Clears the event log cache. Use when switching between sessions or if cache behavior seems incorrect.

.EXAMPLE
Hunt-Logs -StartDate "7D" -Search "mimikatz" -SearchXML -OutputCSV "C:\Hunt\"
Searches last 7 days for "mimikatz" in both message AND XML data (slower but more thorough).

.EXAMPLE
Hunt-Logs -StartDate "24H" -Search "malicious" -ProcessID 1234,5678 -XML 2500
Searches last 24 hours for "malicious" but ONLY in events from Process IDs 1234 or 5678.

.EXAMPLE
Hunt-Logs -StartDate "48H" -EventId 4688 -ProcessID 2468 -ThreadID 3912
Finds all 4688 events from the last 48 hours with specific Process ID and Thread ID.

.NOTES
Version: 2.1
Requires: PowerShell 5.0+
Privileges: Administrator recommended for complete log access and forensic features
Performance: Use -MaxPrint for large result sets. Aggressive mode caches C:\ scans.
Caching: Event log results are automatically cached in the PowerShell session for improved performance.
         - Cached events are RAW (unfiltered) to ensure accuracy across different search queries
         - Cache automatically supplements itself when queries extend beyond cached time ranges
         - Use -ClearCache to manually clear the cache if needed
         - Cache is invalidated when switching between Live/EVTX modes or changing timezones
Special Characters: Search uses regex pattern matching. All special characters are automatically escaped.
                    Very short strings (1-2 chars) may cause false positives - use longer, specific patterns.
Time Ranges: Invalid date inputs will throw descriptive errors. Relative times calculated from current time.
Search Priority: -Search takes precedence over -Exclude. -ExcludeEventId takes precedence over everything.
Default Behavior: Without date parameters, retrieves ALL available logs with no time filtering.
#>
    param (
        [Parameter(Mandatory = $false)]
        $StartDate,
        [Parameter(Mandatory = $false)]
        $EndDate,
        [Parameter(Mandatory = $false)]
        [string[]]$Search = @(),
        [Parameter(Mandatory = $false)]
        [string[]]$Exclude = @(),
        [Parameter(Mandatory = $false)]
        [switch]$SearchXML,
        [Parameter(Mandatory = $false)]
        [int[]]$EventId = @(),
        [Parameter(Mandatory = $false)]
        [int[]]$ExcludeEventId = @(),
        [Parameter(Mandatory = $false)]
        [int[]]$ProcessID = @(),
        [Parameter(Mandatory = $false)]
        [int[]]$ThreadID = @(),
        [Parameter(Mandatory = $false)]
        [string[]]$LogNames = @(),
        [Parameter(Mandatory = $false)]
        [ValidateSet("OldestFirst", "NewestFirst")]
        [string]$SortOrder = "NewestFirst",
        [Parameter(Mandatory = $false)]
        [int]$XML = 0,
        [Parameter(Mandatory = $false)]
        [int]$MSG = 1000,
        [Parameter(Mandatory = $false)]
        [int]$MaxPrint = 0,
        [Parameter(Mandatory = $false)]
        [int]$MaxEvents = 100000,  
        [Parameter(Mandatory = $false)]
        [string]$Timezone = "",
        [Parameter(Mandatory = $false)]
        [switch]$StopLogging,
        [Parameter(Mandatory = $false)]
        [string]$Export,
        [Parameter(Mandatory = $false)]
        [string]$FolderPath,
        [Parameter(Mandatory = $false)]
        [string]$Aggressive,
        [Parameter(Mandatory = $false)]
        [switch]$Auto,
        [Parameter(Mandatory = $false)]
        [switch]$PassThru,
        [Parameter(Mandatory = $false)]
        [string]$OutputCSV,
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        [Parameter(Mandatory = $false)]
        [switch]$ClearCache
    )

    # ============================================================================
    # PERFORMANCE: Initialize regex cache for large IOC lists
    # ============================================================================
    
    # Cache regex patterns to avoid rebuilding them for each event
    $script:CachedSearchRegex = $null
    $script:CachedSearchReference = $null
    $script:CachedExcludeRegex = $null
    $script:CachedExcludeReference = $null
    
    # ============================================================================
    # DEFENSIVE VALIDATION
    # ============================================================================

    # ============================================================================
    # DEFENSIVE VALIDATION
    # ============================================================================
    
    # Helper function to sanitize search/exclude strings for regex compatibility
    function Get-SanitizedSearchString {
        param([string]$InputString)
        
        if ([string]::IsNullOrWhiteSpace($InputString)) {
            return $null
        }
        
        # No sanitization needed - regex.Escape handles everything
        # Just return trimmed string
        return $InputString.Trim()
    }
    
    # Validate and sanitize Search strings
    if ($Search.Count -gt 0) {
        $sanitizedSearch = @()
        $shortStringCount = 0
        foreach ($searchStr in $Search) {
            $cleanStr = Get-SanitizedSearchString -InputString $searchStr
            if ($null -ne $cleanStr) {
                # Warn about very short strings (high false positive rate)
                if ($cleanStr.Length -le 2) {
                    $shortStringCount++
                    Write-Verbose "Warning: Very short search string '$cleanStr' may cause false positives"
                }
                $sanitizedSearch += $cleanStr
            }
        }
        
        if ($shortStringCount -gt 0 -and -not $Quiet) {
            Write-Warning "Detected $shortStringCount search string(s) with 2 or fewer characters. This may cause false positives. Consider using longer, more specific strings."
        }
        
        if ($sanitizedSearch.Count -eq 0) {
            Write-Warning "All Search strings were empty after sanitization. Search filter disabled."
            $Search = @()
        }
        else {
            $Search = $sanitizedSearch
            Write-Verbose "Sanitized $($Search.Count) search string(s)"
        }
    }
    
    # Validate and sanitize Exclude strings
    if ($Exclude.Count -gt 0) {
        $sanitizedExclude = @()
        foreach ($excludeStr in $Exclude) {
            $cleanStr = Get-SanitizedSearchString -InputString $excludeStr
            if ($null -ne $cleanStr) {
                $sanitizedExclude += $cleanStr
            }
        }
        
        if ($sanitizedExclude.Count -eq 0) {
            Write-Warning "All Exclude strings were empty after sanitization. Exclude filter disabled."
            $Exclude = @()
        }
        else {
            $Exclude = $sanitizedExclude
            Write-Verbose "Sanitized $($Exclude.Count) exclude string(s)"
        }
    }
    
    # Validate EventId arrays contain only valid integers
    if ($EventId.Count -gt 0) {
        $invalidIds = $EventId | Where-Object { $_ -lt 0 -or $_ -gt 65535 }
        if ($invalidIds) {
            Write-Warning "Invalid Event IDs detected (must be 0-65535): $($invalidIds -join ', ')"
            $EventId = $EventId | Where-Object { $_ -ge 0 -and $_ -le 65535 }
        }
    }
    
    if ($ExcludeEventId.Count -gt 0) {
        $invalidIds = $ExcludeEventId | Where-Object { $_ -lt 0 -or $_ -gt 65535 }
        if ($invalidIds) {
            Write-Warning "Invalid Exclude Event IDs detected (must be 0-65535): $($invalidIds -join ', ')"
            $ExcludeEventId = $ExcludeEventId | Where-Object { $_ -ge 0 -and $_ -le 65535 }
        }
    }
    
    # Validate ProcessID arrays contain only valid integers (process IDs are always >= 0)
    if ($ProcessID.Count -gt 0) {
        $validPIDs = @()
        $invalidPIDs = @()
        foreach ($processIdentifier in $ProcessID) {
            if ($processIdentifier -ge 0) {
                $validPIDs += $processIdentifier
            }
            else {
                $invalidPIDs += $processIdentifier
            }
        }
        if ($invalidPIDs.Count -gt 0) {
            Write-Warning "Invalid Process IDs detected (must be non-negative): $($invalidPIDs -join ', ')"
            $ProcessID = $validPIDs
        }
    }
    
    # Validate ThreadID arrays contain only valid integers (thread IDs are always >= 0)
    if ($ThreadID.Count -gt 0) {
        $validTIDs = @()
        $invalidTIDs = @()
        foreach ($tid in $ThreadID) {
            if ($tid -ge 0) {
                $validTIDs += $tid
            }
            else {
                $invalidTIDs += $tid
            }
        }
        if ($invalidTIDs.Count -gt 0) {
            Write-Warning "Invalid Thread IDs detected (must be non-negative): $($invalidTIDs -join ', ')"
            $ThreadID = $validTIDs
        }
    }
    
    # Validate parameter combinations
    if ($PSBoundParameters.ContainsKey('Aggressive') -and $Search.Count -eq 0) {
        throw "The -Aggressive parameter requires -Search to be specified. Aggressive mode searches file systems for IOCs specified in -Search."
    }
    
    if ($SearchXML -and $Search.Count -eq 0) {
        throw "The -SearchXML parameter requires -Search to be specified. SearchXML searches XML event data in addition to messages."
    }
    
    if ($Quiet -and -not $PassThru -and -not $PSBoundParameters.ContainsKey('OutputCSV')) {
        Write-Warning "-Quiet specified without -PassThru or -OutputCSV. No output will be generated."
        Write-Host "Recommend using: -Quiet -PassThru or -Quiet -OutputCSV" -ForegroundColor Yellow
    }
    
    if ($PassThru -and $PSBoundParameters.ContainsKey('MaxPrint') -and $MaxPrint -gt 0) {
        Write-Verbose "MaxPrint parameter has no effect with -PassThru (only affects console output)"
    }

    # Performance warning for MaxEvents=0
    if ($MaxEvents -eq 0) {
        Write-Warning "MaxEvents set to 0 (unlimited), this may cause performance issues on large datasets."
    }
    
    # Warn about large time ranges combined with unlimited events
    if ($MaxEvents -eq 0 -and $null -ne $StartDate -and $null -ne $EndDate) {
        try {
            $testStart = ConvertTo-DateTime -InputValue $StartDate -TargetTimeZone ([System.TimeZoneInfo]::Local)
            $testEnd = ConvertTo-DateTime -InputValue $EndDate -TargetTimeZone ([System.TimeZoneInfo]::Local)
            $daysDiff = ($testEnd - $testStart).TotalDays
            
            if ($daysDiff -gt 30) {
                Write-Warning "Large time range ($([math]::Round($daysDiff,0)) days) with unlimited MaxEvents."
            }
        }
        catch {
            # Can't parse dates yet, will catch later
        }
    }
    
    # ============================================================================
    # END VALIDATION
    # ============================================================================
    
    # Handle ClearCache parameter
    if ($ClearCache) {
        Clear-HuntLogsCache
        Write-Host "Hunt-Logs cache cleared successfully." -ForegroundColor Green
        return
    }

    # ============================================================================
    # CACHING SYSTEM
    # ============================================================================
    
    # Initialize global cache if not exists
    if (-not (Test-Path Variable:\global:HuntLogsCache)) {
        $global:HuntLogsCache = @{
            Enabled        = $true
            LastQueryTime  = $null
            CacheCreatedAt = $null
            Parameters     = @{
                StartDate  = $null  # Absolute DateTime
                EndDate    = $null  # Absolute DateTime
                LogNames   = @()
                EventId    = @()
                ProcessID  = @()
                ThreadID   = @()
                FolderPath = ""
                Mode       = ""     # "Live" or "EVTX"
                SystemTZ   = $null  # System timezone at cache time
            }
            RawEvents      = @{}  # HashTable keyed by event hash
            Statistics     = @{
                TotalEvents   = 0
                CacheHits     = 0
                CacheMisses   = 0
                PartialHits   = 0
                LastOperation = ""
            }
        }
    }
    
    # Function to clear cache
    function Clear-HuntLogsCache {
        [CmdletBinding()]
        param(
            [switch]$Silent
        )
        
        if ($global:HuntLogsCache.RawEvents.Count -gt 0 -and -not $Silent) {
            Write-Host "Clearing Hunt-Logs cache ($($global:HuntLogsCache.RawEvents.Count) events)..." -ForegroundColor Yellow
        }
        
        $global:HuntLogsCache = @{
            Enabled        = $true
            LastQueryTime  = $null
            CacheCreatedAt = $null
            Parameters     = @{
                StartDate  = $null
                EndDate    = $null
                LogNames   = @()
                EventId    = @()
                ProcessID  = @()
                ThreadID   = @()
                FolderPath = ""
                Mode       = ""
                SystemTZ   = $null
            }
            RawEvents      = @{}
            Statistics     = @{
                TotalEvents   = 0
                CacheHits     = 0
                CacheMisses   = 0
                PartialHits   = 0
                LastOperation = ""
            }
        }
    }
    
    # Function to test if cache can be used
    function Test-CacheValidity {
        [CmdletBinding()]
        param(
            $RequestedStartDate,
            $RequestedEndDate,
            [string[]]$RequestedLogNames,
            [int[]]$RequestedEventId,
            [int[]]$RequestedProcessID,
            [int[]]$RequestedThreadID,
            [string]$RequestedFolderPath,
            [string]$RequestedMode
        )
        
        try {
            # Cache must be enabled and have data
            if (-not $global:HuntLogsCache.Enabled) {
                Write-Verbose "Cache is disabled"
                return @{ Valid = $false; Reason = "Cache disabled" }
            }
            
            if ($global:HuntLogsCache.RawEvents.Count -eq 0) {
                Write-Verbose "Cache is empty"
                return @{ Valid = $false; Reason = "Cache empty" }
            }
            
            # Check if mode matches (Live vs EVTX)
            if ($global:HuntLogsCache.Parameters.Mode -ne $RequestedMode) {
                Write-Verbose "Cache mode mismatch: Cached=$($global:HuntLogsCache.Parameters.Mode), Requested=$RequestedMode"
                return @{ Valid = $false; Reason = "Mode mismatch"; RequiresFullRefresh = $true }
            }
            
            # For EVTX mode, folder path must match exactly
            if ($RequestedMode -eq "EVTX") {
                if ($global:HuntLogsCache.Parameters.FolderPath -ne $RequestedFolderPath) {
                    Write-Verbose "EVTX path mismatch"
                    return @{ Valid = $false; Reason = "EVTX path mismatch"; RequiresFullRefresh = $true }
                }
            }
            
            # Check timezone hasn't changed (affects time comparisons)
            $currentSystemTZ = [System.TimeZoneInfo]::Local.Id
            if ($null -ne $global:HuntLogsCache.Parameters.SystemTZ -and 
                $global:HuntLogsCache.Parameters.SystemTZ -ne $currentSystemTZ) {
                Write-Verbose "System timezone changed since cache creation"
                return @{ Valid = $false; Reason = "Timezone changed"; RequiresFullRefresh = $true }
            }
            
            # Handle null date scenarios (requesting ALL logs)
            if ($null -eq $RequestedStartDate -and $null -eq $RequestedEndDate) {
                # Requesting ALL logs - cache is only valid if it also cached ALL logs
                if ($null -eq $global:HuntLogsCache.Parameters.StartDate -and 
                    $null -eq $global:HuntLogsCache.Parameters.EndDate) {
                    Write-Verbose "Cache contains ALL logs, matches request for ALL logs"
                    # Continue to other validation checks
                }
                else {
                    Write-Verbose "Requesting ALL logs but cache has date filters"
                    return @{ Valid = $false; Reason = "Cache has date filters, requesting ALL"; RequiresFullRefresh = $true }
                }
            }
            elseif ($null -eq $global:HuntLogsCache.Parameters.StartDate -and 
                $null -eq $global:HuntLogsCache.Parameters.EndDate) {
                # Cache has ALL logs but request has date filters - cache can still be used
                Write-Verbose "Cache has ALL logs, can filter for requested date range"
                # Continue to validation - cache covers the requested range
            }
            else {
                # Both have dates - validate compatibility
                if ($null -eq $global:HuntLogsCache.Parameters.StartDate -or 
                    $null -eq $global:HuntLogsCache.Parameters.EndDate) {
                    Write-Verbose "Cache has partial null dates (invalid state)"
                    return @{ Valid = $false; Reason = "Invalid cache dates"; RequiresFullRefresh = $true }
                }
                
                if ($null -eq $RequestedStartDate -or $null -eq $RequestedEndDate) {
                    Write-Verbose "Request has partial null dates (invalid state)"
                    return @{ Valid = $false; Reason = "Invalid request dates"; RequiresFullRefresh = $true }
                }
                
                $cachedStart = $global:HuntLogsCache.Parameters.StartDate
                $cachedEnd = $global:HuntLogsCache.Parameters.EndDate
                
                # Check time range compatibility
                # Requested range must be within or equal to cached range for full cache use
                # If requested range extends beyond cached, we need partial refresh
                
                $needsEarlierData = $RequestedStartDate -lt $cachedStart
                $needsLaterData = $RequestedEndDate -gt $cachedEnd
            
                if ($needsEarlierData -or $needsLaterData) {
                    # Requested range extends beyond cached range
                    Write-Verbose "Requested range extends beyond cache: Earlier=$needsEarlierData, Later=$needsLaterData"
                    
                    return @{
                        Valid                  = $true
                        UseCache               = $true
                        RequiresPartialRefresh = $true
                        NeedsEarlierData       = $needsEarlierData
                        NeedsLaterData         = $needsLaterData
                        CachedStart            = $cachedStart
                        CachedEnd              = $cachedEnd
                        Reason                 = "Partial cache hit - needs supplemental data"
                    }
                }
            }
            
           
            # Check if requested logs are subset of cached logs
            # Empty cached log list means "all logs" were cached
            if ($global:HuntLogsCache.Parameters.LogNames.Count -gt 0) {
                if ($RequestedLogNames.Count -eq 0) {
                    # Requested "all logs" but cache only has specific logs
                    Write-Verbose "Requested all logs, but cache has specific logs only"
                    return @{ Valid = $false; Reason = "Cache has subset of logs"; RequiresFullRefresh = $true }
                }
                
                # Check if all requested logs are in cache
                $cachedLogsLower = $global:HuntLogsCache.Parameters.LogNames | ForEach-Object { $_.ToLower() }
                foreach ($requestedLog in $RequestedLogNames) {
                    if ($cachedLogsLower -notcontains $requestedLog.ToLower()) {
                        Write-Verbose "Requested log '$requestedLog' not in cache"
                        return @{ Valid = $false; Reason = "Requested log not in cache"; RequiresFullRefresh = $true }
                    }
                }
            }
            
            # Check if requested EventIds are subset of cached EventIds
            # Empty cached EventId list means "all event IDs" were cached
            if ($global:HuntLogsCache.Parameters.EventId.Count -gt 0) {
                if ($RequestedEventId.Count -eq 0) {
                    # Requested "all event IDs" but cache only has specific IDs
                    Write-Verbose "Requested all event IDs, but cache has specific IDs only"
                    return @{ Valid = $false; Reason = "Cache has subset of event IDs"; RequiresFullRefresh = $true }
                }
                
                # Check if all requested IDs are in cache
                foreach ($requestedId in $RequestedEventId) {
                    if ($global:HuntLogsCache.Parameters.EventId -notcontains $requestedId) {
                        Write-Verbose "Requested Event ID $requestedId not in cache"
                        return @{ Valid = $false; Reason = "Requested Event ID not in cache"; RequiresFullRefresh = $true }
                    }
                }
            }
            
            # Check if requested ProcessIDs are subset of cached ProcessIDs
            # Empty cached ProcessID list means "all ProcessIDs" were cached
            if ($global:HuntLogsCache.Parameters.ProcessID.Count -gt 0) {
                if ($RequestedProcessID.Count -eq 0) {
                    # Requested "all ProcessIDs" but cache only has specific ProcessIDs
                    Write-Verbose "Requested all ProcessIDs, but cache has specific ProcessIDs only"
                    return @{ Valid = $false; Reason = "Cache has subset of ProcessIDs"; RequiresFullRefresh = $true }
                }
                
                # Check if all requested ProcessIDs are in cache
                foreach ($requestedPid in $RequestedProcessID) {
                    if ($global:HuntLogsCache.Parameters.ProcessID -notcontains $requestedPid) {
                        Write-Verbose "Requested ProcessID $requestedPid not in cache"
                        return @{ Valid = $false; Reason = "Requested ProcessID not in cache"; RequiresFullRefresh = $true }
                    }
                }
            }
            
            # Check if requested ThreadIDs are subset of cached ThreadIDs
            # Empty cached ThreadID list means "all ThreadIDs" were cached
            if ($global:HuntLogsCache.Parameters.ThreadID.Count -gt 0) {
                if ($RequestedThreadID.Count -eq 0) {
                    # Requested "all ThreadIDs" but cache only has specific ThreadIDs
                    Write-Verbose "Requested all ThreadIDs, but cache has specific ThreadIDs only"
                    return @{ Valid = $false; Reason = "Cache has subset of ThreadIDs"; RequiresFullRefresh = $true }
                }
                
                # Check if all requested ThreadIDs are in cache
                foreach ($requestedTid in $RequestedThreadID) {
                    if ($global:HuntLogsCache.Parameters.ThreadID -notcontains $requestedTid) {
                        Write-Verbose "Requested ThreadID $requestedTid not in cache"
                        return @{ Valid = $false; Reason = "Requested ThreadID not in cache"; RequiresFullRefresh = $true }
                    }
                }
            }
            
            # Cache is valid and fully covers requested query
            Write-Verbose "Cache is valid and covers requested query"
            return @{
                Valid                  = $true
                UseCache               = $true
                RequiresPartialRefresh = $false
                Reason                 = "Full cache hit"
            }
        }
        catch {
            Write-Verbose "Error validating cache: $($_.Exception.Message)"
            return @{ Valid = $false; Reason = "Cache validation error: $($_.Exception.Message)"; RequiresFullRefresh = $true }
        }
    }
    
    # Function to filter cached events based on query parameters
    function Get-FilteredCachedEvents {
        [CmdletBinding()]
        param(
            $StartDate,
            $EndDate,
            [string[]]$LogNames,
            [int[]]$EventId,
            [int[]]$ProcessID,
            [int[]]$ThreadID
        )
        
        try {
            $filteredEvents = @{}
            
            foreach ($key in $global:HuntLogsCache.RawEvents.Keys) {
                $event = $global:HuntLogsCache.RawEvents[$key]
                
                # Filter by time range (only if dates provided)
                if ($null -ne $StartDate -and $event.TimeCreated -lt $StartDate) {
                    continue
                }
                if ($null -ne $EndDate -and $event.TimeCreated -gt $EndDate) {
                    continue
                }
                
                # Filter by log names (if specified)
                if ($LogNames.Count -gt 0) {
                    $matchFound = $false
                    foreach ($logName in $LogNames) {
                        if ($event.LogName -like "*$logName*" -or $logName -like "*$($event.LogName)*") {
                            $matchFound = $true
                            break
                        }
                    }
                    if (-not $matchFound) { continue }
                }
                
                # Filter by event IDs (if specified)
                if ($EventId.Count -gt 0) {
                    if ($EventId -notcontains $event.Id) {
                        continue
                    }
                }
                
                # Filter by Process IDs (if specified)
                if ($ProcessID.Count -gt 0) {
                    if ($ProcessID -notcontains $event.ProcessId) {
                        continue
                    }
                }
                
                # Filter by Thread IDs (if specified)
                if ($ThreadID.Count -gt 0) {
                    if ($ThreadID -notcontains $event.ThreadId) {
                        continue
                    }
                }
                
                # Event passes all filters
                $filteredEvents[$key] = $event
            }
            
            Write-Verbose "Filtered cache: $($filteredEvents.Count) of $($global:HuntLogsCache.RawEvents.Count) events match query"
            return $filteredEvents
        }
        catch {
            Write-Warning "Error filtering cached events: $($_.Exception.Message)"
            return @{}
        }
    }
    
    # Function to add events to cache
    function Add-EventsToCache {
        [CmdletBinding()]
        param(
            [hashtable]$NewEvents
        )
        
        try {
            $addedCount = 0
            foreach ($key in $NewEvents.Keys) {
                if (-not $global:HuntLogsCache.RawEvents.ContainsKey($key)) {
                    $global:HuntLogsCache.RawEvents[$key] = $NewEvents[$key]
                    $addedCount++
                }
            }
            
            $global:HuntLogsCache.Statistics.TotalEvents = $global:HuntLogsCache.RawEvents.Count
            Write-Verbose "Added $addedCount new events to cache (Total: $($global:HuntLogsCache.RawEvents.Count))"
            
            return $addedCount
        }
        catch {
            Write-Warning "Error adding events to cache: $($_.Exception.Message)"
            return 0
        }
    }
    
    # Function to update cache parameters
    function Update-CacheParameters {
        [CmdletBinding()]
        param(
            $StartDate,
            $EndDate,
            [string[]]$LogNames,
            [int[]]$EventId,
            [int[]]$ProcessID,
            [int[]]$ThreadID,
            [string]$FolderPath,
            [string]$Mode
        )
        
        try {
            # Handle null dates (ALL logs scenario)
            if ($null -eq $StartDate -and $null -eq $EndDate) {
                # Caching ALL logs - set cache parameters to null
                $global:HuntLogsCache.Parameters.StartDate = $null
                $global:HuntLogsCache.Parameters.EndDate = $null
            }
            elseif ($null -ne $StartDate -and $null -ne $EndDate) {
                # Update time range (expand if necessary)
                if ($null -eq $global:HuntLogsCache.Parameters.StartDate -or 
                    $StartDate -lt $global:HuntLogsCache.Parameters.StartDate) {
                    $global:HuntLogsCache.Parameters.StartDate = $StartDate
                }
                
                if ($null -eq $global:HuntLogsCache.Parameters.EndDate -or 
                    $EndDate -gt $global:HuntLogsCache.Parameters.EndDate) {
                    $global:HuntLogsCache.Parameters.EndDate = $EndDate
                }
            }
            # If parameters are mixed null/non-null, keep existing cache dates
            
            # Update log names (expand if necessary)
            if ($LogNames.Count -eq 0) {
                # "All logs" query - clear specific log names
                $global:HuntLogsCache.Parameters.LogNames = @()
            }
            elseif ($global:HuntLogsCache.Parameters.LogNames.Count -gt 0) {
                # Add any new log names
                foreach ($logName in $LogNames) {
                    if ($global:HuntLogsCache.Parameters.LogNames -notcontains $logName) {
                        $global:HuntLogsCache.Parameters.LogNames += $logName
                    }
                }
            }
            else {
                # Cache had "all logs", keep it that way
            }
            
            # Update event IDs (expand if necessary)
            if ($EventId.Count -eq 0) {
                # "All event IDs" query - clear specific IDs
                $global:HuntLogsCache.Parameters.EventId = @()
            }
            elseif ($global:HuntLogsCache.Parameters.EventId.Count -gt 0) {
                # Add any new event IDs
                foreach ($id in $EventId) {
                    if ($global:HuntLogsCache.Parameters.EventId -notcontains $id) {
                        $global:HuntLogsCache.Parameters.EventId += $id
                    }
                }
            }
            else {
                # Cache had "all IDs", keep it that way
            }
            
            # Update ProcessIDs (expand if necessary)
            if ($ProcessID.Count -eq 0) {
                # "All ProcessIDs" query - clear specific ProcessIDs
                $global:HuntLogsCache.Parameters.ProcessID = @()
            }
            elseif ($global:HuntLogsCache.Parameters.ProcessID.Count -gt 0) {
                # Add any new ProcessIDs
                foreach ($id in $ProcessID) {
                    if ($global:HuntLogsCache.Parameters.ProcessID -notcontains $id) {
                        $global:HuntLogsCache.Parameters.ProcessID += $id
                    }
                }
            }
            else {
                # Cache had "all ProcessIDs", keep it that way
            }
            
            # Update ThreadIDs (expand if necessary)
            if ($ThreadID.Count -eq 0) {
                # "All ThreadIDs" query - clear specific ThreadIDs
                $global:HuntLogsCache.Parameters.ThreadID = @()
            }
            elseif ($global:HuntLogsCache.Parameters.ThreadID.Count -gt 0) {
                # Add any new ThreadIDs
                foreach ($id in $ThreadID) {
                    if ($global:HuntLogsCache.Parameters.ThreadID -notcontains $id) {
                        $global:HuntLogsCache.Parameters.ThreadID += $id
                    }
                }
            }
            else {
                # Cache had "all ThreadIDs", keep it that way
            }
            
            $global:HuntLogsCache.Parameters.FolderPath = $FolderPath
            $global:HuntLogsCache.Parameters.Mode = $Mode
            $global:HuntLogsCache.Parameters.SystemTZ = [System.TimeZoneInfo]::Local.Id
            $global:HuntLogsCache.LastQueryTime = Get-Date
            
            if ($null -eq $global:HuntLogsCache.CacheCreatedAt) {
                $global:HuntLogsCache.CacheCreatedAt = Get-Date
            }
            
            Write-Verbose "Cache parameters updated"
        }
        catch {
            Write-Warning "Error updating cache parameters: $($_.Exception.Message)"
        }
    }
    
    # ============================================================================
    # END CACHING SYSTEM
    # ============================================================================


    # Define script IOC list if not already defined
    if ($null -eq (Get-Variable -Name "GlobalLogIOCs" -Scope Script -ErrorAction SilentlyContinue)) {
        Write-Warning "Event Log IOCs not found. Defining default IOC list."
        $script:GlobalLogIOCs = @("")
    }

    # Check for administrator privileges for optimal functionality
    $currentPrincipal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())
    if (-not $currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
        Write-Warning "Not running as Administrator. Some event logs may be inaccessible, reducing detection coverage."
    }

    # Initialize result collection for PassThru
    $script:HuntLogResults = @()

    # Helper function to create log result object
    function New-LogResult {
        param(
            $LogEvent,
            $TargetTimeZone,
            $MatchedStrings = "",
            $IsAggressive = $false,
            $FilePath = "",
            $Match = ""
        )

        if ($IsAggressive) {
            return [PSCustomObject]@{
                Type             = "FileSystem"
                FilePath         = $FilePath
                FileName         = if ($FilePath) { Split-Path $FilePath -Leaf } else { "" }
                CreationDate     = $LogEvent.CreationDate
                LastModifiedDate = $LogEvent.LastModifiedDate
                Match            = $Match  # This is correct
                Text             = $LogEvent.Text
                Hostname         = ([Net.Dns]::GetHostByName($env:computerName)).HostName
                TimeCreated      = $null
                FormattedTime    = ""
                LogName          = "FileSystem"
                EventId          = $null
                RecordId         = $null
                Message          = $LogEvent.Text
                XML              = ""
                LevelDisplayName = ""
                ProcessId        = $null
                ThreadId         = $null
                UserId           = $null
            }
        }
        else {
            $formattedTime = Format-DateTimeWithTimeZone -DateTime $LogEvent.TimeCreated -TargetTimeZone $TargetTimeZone
        
            $xmlData = ""
            try {
                $xmlData = $LogEvent.ToXml()
            }
            catch {
                $xmlData = ""
            }

            return [PSCustomObject]@{
                Type             = "EventLog"
                TimeCreated      = $LogEvent.TimeCreated
                FormattedTime    = $formattedTime
                LogName          = $LogEvent.LogName
                EventId          = $LogEvent.Id
                RecordId         = $LogEvent.RecordId
                Message          = if ([string]::IsNullOrWhiteSpace($LogEvent.Message)) { "[No Message]" } else { $LogEvent.Message }
                MatchedStrings   = $MatchedStrings
                XML              = $xmlData
                LevelDisplayName = $LogEvent.LevelDisplayName
                ProcessId        = $LogEvent.ProcessId
                ThreadId         = $LogEvent.ThreadId
                UserId           = $LogEvent.UserId
                Hostname         = ([Net.Dns]::GetHostByName($env:computerName)).HostName
                FilePath         = ""      # Always blank for EventLog
                FileName         = ""      # Always blank for EventLog  
                CreationDate     = $null   # Always null for EventLog
                LastModifiedDate = $null   # Always null for EventLog
                Match            = $MatchedStrings  # Use MatchedStrings for EventLog entries
                Text             = if ([string]::IsNullOrWhiteSpace($LogEvent.Message)) { "[No Message]" } else { $LogEvent.Message }
            }
        }
    }
    # Function to get timezone info by name/abbreviation
    function Get-TimezoneInfo {
        param($TimezoneName)
    
        $TimezoneName = $TimezoneName.ToUpper()
    
        $timezoneMap = @{
            'UTC' = 'UTC'
            'GMT' = 'GMT Standard Time'
            'EST' = 'Eastern Standard Time'
            'CST' = 'Central Standard Time' 
            'MST' = 'Mountain Standard Time'
            'PST' = 'Pacific Standard Time'
            'EDT' = 'Eastern Standard Time'
            'CDT' = 'Central Standard Time'
            'MDT' = 'Mountain Standard Time'
            'PDT' = 'Pacific Standard Time'
        }
    
        $mappedName = if ($timezoneMap.ContainsKey($TimezoneName)) { $timezoneMap[$TimezoneName] } else { $TimezoneName }
    
        try {
            if ($mappedName -eq 'UTC') {
                return [System.TimeZoneInfo]::Utc
            }
            return [System.TimeZoneInfo]::FindSystemTimeZoneById($mappedName)
        }
        catch {
            Write-Warning "Invalid timezone '$TimezoneName', using system local time"
            return [System.TimeZoneInfo]::Local
        }
    }

    # Function to parse time strings and convert to target timezone for search queries
    function ConvertTo-DateTime {
        param($InputValue, $TargetTimeZone)
        
        # Get current system timezone
        $currentSystemTZ = [System.TimeZoneInfo]::Local
        
        if ($InputValue -is [datetime]) {
            # Convert to target timezone for internal processing, then back to system time for search
            if ($TargetTimeZone.Id -ne $currentSystemTZ.Id) {
                $convertedTime = [System.TimeZoneInfo]::ConvertTime($InputValue, $TargetTimeZone, $currentSystemTZ)
                return $convertedTime
            }
            return $InputValue
        }
        
        if ($InputValue -is [string]) {
            $InputValue = $InputValue.Trim()
            
            if ($InputValue.ToLower() -eq 'now') {
                return Get-Date
            }
            
            if ($InputValue -match '^(\d+)([DHMdhm])$') {
                $number = [int]$matches[1]
                $unit = $matches[2].ToUpper()
                
                $currentTime = Get-Date
                switch ($unit) {
                    'D' { return $currentTime.AddDays(-$number) }
                    'H' { return $currentTime.AddHours(-$number) }
                    'M' { return $currentTime.AddMinutes(-$number) }
                }
            }
            else {
                try {
                    $parsedDate = [datetime]$InputValue
                    # If user specified a timezone, interpret the input date as being in that timezone
                    if ($TargetTimeZone.Id -ne $currentSystemTZ.Id) {
                        # Convert from target timezone to system timezone for search
                        $convertedTime = [System.TimeZoneInfo]::ConvertTime($parsedDate, $TargetTimeZone, $currentSystemTZ)
                        return $convertedTime
                    }
                    return $parsedDate
                }
                catch {
                    throw "Invalid date format: $InputValue. Use datetime, 'now', or relative format like '1D', '4H', or '10m'"
                }
            }
        }
        
        throw "Invalid date input: $InputValue"
    }

    # Function to format datetime with timezone for display
    function Format-DateTimeWithTimeZone {
        param($DateTime, $TargetTimeZone)
        
        # Defensive: Validate DateTime parameter
        if ($null -eq $DateTime) {
            return "[Invalid DateTime]"
        }
        
        # Get current system timezone for comparison
        $currentSystemTZ = [System.TimeZoneInfo]::Local
        
        # Convert from system time to target timezone for display
        if ($TargetTimeZone.Id -eq $currentSystemTZ.Id) {
            $convertedTime = $DateTime
            $tzAbbrev = $currentSystemTZ.StandardName.Split(' ')[0]
        }
        else {
            $convertedTime = [System.TimeZoneInfo]::ConvertTime($DateTime, $currentSystemTZ, $TargetTimeZone)
            
            $tzAbbrev = if ($TargetTimeZone.Id -eq 'UTC') { 
                'UTC' 
            }
            elseif ($TargetTimeZone.StandardName -like "*Eastern*") { 
                if ($TargetTimeZone.IsDaylightSavingTime($convertedTime)) { 'EDT' } else { 'EST' } 
            }
            elseif ($TargetTimeZone.StandardName -like "*Central*") { 
                if ($TargetTimeZone.IsDaylightSavingTime($convertedTime)) { 'CDT' } else { 'CST' } 
            }
            elseif ($TargetTimeZone.StandardName -like "*Mountain*") { 
                if ($TargetTimeZone.IsDaylightSavingTime($convertedTime)) { 'MDT' } else { 'MST' } 
            }
            elseif ($TargetTimeZone.StandardName -like "*Pacific*") { 
                if ($TargetTimeZone.IsDaylightSavingTime($convertedTime)) { 'PDT' } else { 'PST' } 
            }
            else { 
                $TargetTimeZone.StandardName.Split(' ')[0] 
            }
        }
        
        return $convertedTime.ToString("yyyy-MM-dd HH:mm:ss") + " $tzAbbrev"
    }

    $targetTimeZone = if ([string]::IsNullOrWhiteSpace($Timezone)) { [System.TimeZoneInfo]::Local } else { Get-TimezoneInfo -TimezoneName $Timezone }

    # Handle Auto mode - SIMPLIFIED VERSION
    if ($Auto) {
        Write-Host "Running in Auto Mode..." -ForegroundColor Cyan
        Write-Host "Auto Mode: Using full IOC list ($($script:GlobalLogIOCs.Count) IOCs) with user-specified parameters" -ForegroundColor Yellow
        
        # Build search parameters - use ONLY what user specified
        $finalParams = @{
            Search    = @($script:GlobalLogIOCs) + $Search  # Full IOC list + user additions
            SortOrder = $SortOrder
            XML       = $XML
            MSG       = $MSG
            MaxPrint  = $MaxPrint
            Timezone  = $Timezone
            PassThru  = $PassThru
            Quiet     = $Quiet
        }
        
        # Add user-specified parameters (dates, logs, filters)
        if ($PSBoundParameters.ContainsKey('StartDate')) { $finalParams.StartDate = $StartDate }
        if ($PSBoundParameters.ContainsKey('EndDate')) { $finalParams.EndDate = $EndDate }
        if ($LogNames.Count -gt 0) { $finalParams.LogNames = $LogNames }
        if ($Exclude.Count -gt 0) { $finalParams.Exclude = $Exclude }
        if ($EventId.Count -gt 0) { $finalParams.EventId = $EventId }
        if ($ExcludeEventId.Count -gt 0) { $finalParams.ExcludeEventId = $ExcludeEventId }
        if ($ProcessID.Count -gt 0) { $finalParams.ProcessID = $ProcessID }
        if ($ThreadID.Count -gt 0) { $finalParams.ThreadID = $ThreadID }
        if ($PSBoundParameters.ContainsKey('FolderPath')) { $finalParams.FolderPath = $FolderPath }
        if ($PSBoundParameters.ContainsKey('Export')) { $finalParams.Export = $Export }
        if ($PSBoundParameters.ContainsKey('Aggressive')) { $finalParams.Aggressive = $Aggressive }
        if ($PSBoundParameters.ContainsKey('OutputCSV')) { $finalParams.OutputCSV = $OutputCSV }
        if ($PSBoundParameters.ContainsKey('MaxEvents')) { $finalParams.MaxEvents = $MaxEvents }
        
        Write-Host "Total IOCs: $($script:GlobalLogIOCs.Count)" -ForegroundColor Green
        if ($Search.Count -gt 0) {
            Write-Host "Additional User IOCs: $($Search.Count)" -ForegroundColor Green
        }
        Write-Host "Total Search Strings: $($finalParams.Search.Count)" -ForegroundColor Green
        
        # Recursively call Hunt-Logs with final parameters
        return Hunt-Logs @finalParams
    }

    # Validate Aggressive parameter requires Search
    if ($PSBoundParameters.ContainsKey('Aggressive') -and $Search.Count -eq 0) {
        throw "The -Aggressive parameter requires -Search to be specified. Aggressive mode searches file systems for IOCs specified in -Search."
    }

    # Handle StopLogging switch
    if ($StopLogging) {
        Write-Host "Attempting to stop event logging services to prevent log overwrites during forensics..." -ForegroundColor Yellow
        
        try {
            # Check for admin privileges
            if (-NOT ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) {
                throw "Administrator privileges required to stop event logging services."
            }

            $eventLogService = Get-Service -Name "EventLog" -ErrorAction SilentlyContinue
            if (($null -ne $eventLogService) -and ($eventLogService.Status -eq "Running")) {
                Stop-Service -Name "EventLog" -Force -ErrorAction SilentlyContinue
                Write-Host "Stopped Windows Event Log service." -ForegroundColor Green
            }

            $logNameList = @("Application", "System", "Security", "Setup")
            $eventLogPath = "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog"
            if (Test-Path $eventLogPath) {
                $additionalLogs = Get-ChildItem $eventLogPath | Select-Object -ExpandProperty PSChildName
                $logNameList += $additionalLogs | Where-Object { $_ -notin @("Application", "System", "Security", "Setup") }
            }

            foreach ($logName in $logNameList) {
                try {
                    $logPath = "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\$logName"
                    if (Test-Path $logPath) {
                        Set-ItemProperty -Path $logPath -Name "AutoBackupLogFiles" -Value 1 -ErrorAction SilentlyContinue
                        Set-ItemProperty -Path $logPath -Name "MaxSize" -Value 536870912 -ErrorAction SilentlyContinue
                        Write-Host "Configured $logName log to archive mode (no overwrite, 512MB max)." -ForegroundColor Green
                    }
                }
                catch {
                    Write-Warning "Could not configure $logName log: $($_.Exception.Message)"
                }
            }

            Write-Host "Event logging has been paused. Remember to restart the EventLog service when forensics is complete." -ForegroundColor Cyan
            Write-Host "To restart: Start-Service -Name 'EventLog'" -ForegroundColor Cyan
            
        }
        catch {
            Write-Error "Error stopping event logging: $($_.Exception.Message)"
        }
        
        return
    }
    # Handle Export parameter - supports switch or path input
    if ($Export) {
        Write-Host "Starting EVTX export process..." -ForegroundColor Yellow
        
        try {
            # Check for admin privileges first
            $currentPrincipal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())
            $isAdmin = $currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
            
            if (-not $isAdmin) {
                Write-Warning "Administrator privileges recommended for complete EVTX export. Some logs may be inaccessible."
            }

            $machineName = $env:COMPUTERNAME
            $datetime = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
            $tempDir = [System.IO.Path]::GetTempPath()
            
            # Create safe filename without problematic characters
            $safeFilename = "EVTX_${machineName}_$datetime.zip"
            
            # Handle different export path scenarios
            try {
                if (($Export -eq $true) -or [string]::IsNullOrWhiteSpace($Export)) {
                    # Just -Export with no path specified - use temp directory
                    $exportFullPath = Join-Path $tempDir $safeFilename
                    Write-Host "No export path specified, using default: $exportFullPath" -ForegroundColor Cyan
                }
                elseif ($Export -match '\.zip$') {
                    # Contains .zip extension
                    if ([System.IO.Path]::IsPathRooted($Export)) {
                        # Full absolute path with .zip extension
                        $exportFullPath = $Export
                    }
                    else {
                        # Relative path with .zip extension - treat as file in current directory
                        $currentDir = Get-Location -ErrorAction Stop
                        $exportFullPath = Join-Path $currentDir.Path $Export
                    }
                }
                else {
                    # No .zip extension - treat as directory path
                    if ([System.IO.Path]::IsPathRooted($Export)) {
                        # Full absolute directory path
                        $exportFullPath = Join-Path $Export $safeFilename
                    }
                    else {
                        # Relative directory path
                        $currentDir = Get-Location -ErrorAction Stop
                        $targetDir = Join-Path $currentDir.Path $Export
                        $exportFullPath = Join-Path $targetDir $safeFilename
                    }
                }
            }
            catch {
                throw "Failed to determine export path: $($_.Exception.Message)"
            }

            # Validate and create export directory
            $exportDir = Split-Path $exportFullPath -Parent
            if ([string]::IsNullOrWhiteSpace($exportDir)) {
                throw "Invalid export path: Cannot determine parent directory for '$exportFullPath'"
            }
            
            if (-not (Test-Path $exportDir)) {
                try {
                    Write-Host "Creating export directory: $exportDir" -ForegroundColor Yellow
                    New-Item -Path $exportDir -ItemType Directory -Force -ErrorAction Stop | Out-Null
                }
                catch {
                    throw "Cannot create export directory '$exportDir': $($_.Exception.Message)"
                }
            }
            
            # Verify directory is writable
            try {
                $testFile = Join-Path $exportDir "test_write_$(Get-Random).tmp"
                New-Item -Path $testFile -ItemType File -Force -ErrorAction Stop | Out-Null
                Remove-Item $testFile -Force -ErrorAction SilentlyContinue
            }
            catch {
                throw "Export directory '$exportDir' is not writable: $($_.Exception.Message)"
            }

            Write-Host "Export path: $exportFullPath" -ForegroundColor Cyan

            # Create temporary export directory
            $tempEvtxDir = Join-Path $tempDir "EVTX_Export_$datetime"
            try {
                New-Item -Path $tempEvtxDir -ItemType Directory -Force -ErrorAction Stop | Out-Null
            }
            catch {
                throw "Cannot create temporary directory '$tempEvtxDir': $($_.Exception.Message)"
            }

            # Enhanced EVTX file discovery - focus on the main logs directory
            $evtxPaths = @(
                "$env:SystemRoot\System32\winevt\Logs"
            )

            # Add additional paths only if they exist and contain EVTX files
            $additionalPaths = @(
                "$env:SystemRoot\System32\config",
                "$env:SystemRoot\System32\LogFiles\WMI"
            )

            foreach ($path in $additionalPaths) {
                if (Test-Path $path) {
                    try {
                        $testFiles = Get-ChildItem -Path $path -Filter *.evtx -ErrorAction SilentlyContinue | Select-Object -First 1
                        if ($null -ne $testFiles) {
                            $evtxPaths += $path
                        }
                    }
                    catch {
                        Write-Verbose "Cannot access path: $path"
                    }
                }
            }

            $evtxFileList = @()
            $accessDeniedCount = 0
            
            # Loop through each directory in $evtxPaths
            foreach ($basePath in $evtxPaths) {
                if (Test-Path $basePath) {
                    try {
                        $files = Get-ChildItem -Path $basePath -Filter *.evtx -ErrorAction SilentlyContinue
                        foreach ($file in $files) {
                            # Don't test file access - just check if file exists and add to list
                            # Windows will handle locked files during copy operation
                            if (Test-Path $file.FullName -PathType Leaf) {
                                $evtxFileList += $file
                            }
                        }
                    }
                    catch {
                        Write-Verbose "Cannot enumerate path: $basePath - $($_.Exception.Message)"
                    }
                }
                else {
                    Write-Warning "Path does not exist: $basePath"
                }
            }

            if ($evtxFileList.Count -eq 0) {
                Write-Warning "No EVTX files found to export."
                return
            }

            Write-Host "Found $($evtxFileList.Count) event log files to process." -ForegroundColor Green

            $copiedCount = 0
            $totalSize = 0
            $copyErrors = 0
            
            # Use wevtutil to export logs when possible, fall back to file copy
            foreach ($file in $evtxFileList) {
                if ($null -eq $file -or [string]::IsNullOrWhiteSpace($file.Name)) {
                    continue
                }
                
                $logName = [System.IO.Path]::GetFileNameWithoutExtension($file.Name)
                $destPath = Join-Path $tempEvtxDir $file.Name
                $exported = $false
                
                try {
                    # Try wevtutil first for active logs (more reliable)
                    $null = & wevtutil.exe epl $logName $destPath 2>$null
                    if ($LASTEXITCODE -eq 0 -and (Test-Path $destPath)) {
                        $fileSize = (Get-Item $destPath -ErrorAction SilentlyContinue).Length
                        if ($null -ne $fileSize -and $fileSize -gt 0) {
                            $copiedCount++
                            $totalSize += $fileSize
                            $exported = $true
                        }
                    }
                }
                catch {
                    # wevtutil failed, will try file copy
                }
                
                if (-not $exported) {
                    try {
                        # Fall back to file copy for archived/inactive logs
                        if (Test-Path $file.FullName -PathType Leaf) {
                            Copy-Item $file.FullName $destPath -ErrorAction Stop
                            $copiedCount++
                            $totalSize += $file.Length
                        }
                        else {
                            Write-Verbose "Source file no longer exists: $($file.FullName)"
                            $copyErrors++
                        }
                    }
                    catch [UnauthorizedAccessException] {
                        Write-Verbose "Access denied copying $($file.Name)"
                        $accessDeniedCount++
                    }
                    catch [System.IO.IOException] {
                        Write-Verbose "File in use, skipping $($file.Name)"
                        $copyErrors++
                    }
                    catch {
                        Write-Verbose "Could not copy $($file.Name): $($_.Exception.Message)"
                        $copyErrors++
                    }
                }
            }

            Write-Host "Successfully exported $copiedCount event log files." -ForegroundColor Green
            if ($copyErrors -gt 0) {
                Write-Host "$copyErrors files failed to copy (likely in use by system)." -ForegroundColor Yellow
            }
            if ($accessDeniedCount -gt 0) {
                Write-Host "$accessDeniedCount files inaccessible due to permissions." -ForegroundColor Yellow
            }

            # Create system info
            $sysInfoPath = Join-Path $tempEvtxDir "SystemInfo.txt"
            try {
                $osInfo = Get-CimInstance Win32_OperatingSystem -ErrorAction SilentlyContinue
                $osVersion = if ($null -ne $osInfo) { "$($osInfo.Caption) $($osInfo.Version)" } else { "Unknown" }
                $architecture = if ($null -ne $osInfo) { $osInfo.OSArchitecture } else { $env:PROCESSOR_ARCHITECTURE }
                $sysInfo = @"
EVTX Export Information
=======================
Machine Name: $machineName
Export Date: $(Get-Date)
User: $env:USERNAME
Domain: $env:USERDOMAIN
OS: $osVersion
Architecture: $architecture
Admin Rights: $isAdmin
Files Exported: $copiedCount
Copy Errors: $copyErrors
Access Denied: $accessDeniedCount
Total Raw Size: $([math]::Round($totalSize / 1MB, 2)) MB
"@
                $sysInfo | Out-File -FilePath $sysInfoPath -Encoding UTF8
            }
            catch {
                Write-Verbose "Could not create system information file."
            }

            if ($copiedCount -eq 0) {
                Write-Warning "No files were successfully exported. Archive creation skipped."
                # Clean up empty temp directory
                Remove-Item $tempEvtxDir -Recurse -Force -ErrorAction SilentlyContinue
                return
            }

            Write-Host "Creating ZIP archive..." -ForegroundColor Yellow
            
            try {
                # PowerShell 5.1 compatible compression
                if (Get-Command Compress-Archive -ErrorAction SilentlyContinue) {
                    Compress-Archive -Path "$tempEvtxDir\*" -DestinationPath $exportFullPath -CompressionLevel Optimal -Force
                }
                else {
                    # Fallback for older PowerShell versions
                    Add-Type -AssemblyName System.IO.Compression.FileSystem
                    [System.IO.Compression.ZipFile]::CreateFromDirectory($tempEvtxDir, $exportFullPath)
                }
            }
            catch {
                throw "Failed to create ZIP archive: $($_.Exception.Message)"
            }

            # Clean up temporary directory
            try {
                Remove-Item $tempEvtxDir -Recurse -Force -ErrorAction SilentlyContinue
            }
            catch {
                Write-Verbose "Could not clean up temporary directory: $tempEvtxDir"
            }

            # Get final archive information
            if (Test-Path $exportFullPath) {
                $exportItem = Get-Item $exportFullPath
                $exportSize = $exportItem.Length
                $exportSizeMB = [math]::Round($exportSize / 1MB, 2)
                $compressionRatio = if ($totalSize -gt 0) { 
                    [math]::Round((1 - ($exportSize / $totalSize)) * 100, 1) 
                }
                else { 
                    0 
                }
                
                Write-Host ""
                Write-Host "EVTX Export Complete!" -ForegroundColor Green
                Write-Host "Location: $exportFullPath" -ForegroundColor Cyan
                Write-Host "Archive Size: $exportSizeMB MB" -ForegroundColor Cyan
                Write-Host "Original Size: $([math]::Round($totalSize / 1MB, 2)) MB" -ForegroundColor Cyan
                Write-Host "Compression: $compressionRatio%" -ForegroundColor Cyan
                Write-Host "Logs: $copiedCount providers" -ForegroundColor Cyan
                
                if ($accessDeniedCount -gt 0 -or $copyErrors -gt 0) {
                    Write-Host ""
                    Write-Host "Note: $($accessDeniedCount + $copyErrors) files could not be exported." -ForegroundColor Yellow
                    Write-Host "Run as Administrator for better access to system logs." -ForegroundColor Yellow
                }
            }
            else {
                throw "Export file was not created successfully."
            }

        }
        catch {
            Write-Error "Error during EVTX export: $($_.Exception.Message)"
        }
        
        return
    }

    # Handle default date logic - if no StartDate specified, get ALL logs
    if (-not $PSBoundParameters.ContainsKey('StartDate') -and -not $PSBoundParameters.ContainsKey('EndDate')) {
        # No dates specified - retrieve ALL logs (no date filtering)
        $StartDate = $null
        $EndDate = $null
        # Message will be displayed later in the date parsing section
    }
    elseif ($PSBoundParameters.ContainsKey('StartDate') -and -not $PSBoundParameters.ContainsKey('EndDate')) {
        # StartDate provided but no EndDate - default EndDate to Now
        if ($null -eq $EndDate) {
            $EndDate = "Now"
        }
        if (-not $Quiet) {
            Write-Verbose "EndDate not specified, defaulting to current time"
        }
    }
    elseif (-not $PSBoundParameters.ContainsKey('StartDate') -and $PSBoundParameters.ContainsKey('EndDate')) {
        # EndDate provided but no StartDate - this is an error
        throw "EndDate specified but StartDate is missing. Please provide both dates or neither for all logs."
    }
    # If both are provided, they'll be validated below

    # Handle parameter logic for XML and MSG truncation
    $xmlTruncateLength = $XML
    $msgTruncateLength = $MSG
    
    if ($PSBoundParameters.ContainsKey('XML') -and $null -eq $XML) {
        $xmlTruncateLength = -1
    }
    if ($PSBoundParameters.ContainsKey('MSG') -and $null -eq $MSG) {
        $msgTruncateLength = -1
    }

    # Function to sanitize CSV data for Excel compatibility
    function Format-CSVValue {
        param($Value)
    
        if ($null -eq $Value -or $Value -eq "") {
            return ""
        }
    
        $stringValue = $Value.ToString()
    
        # Remove or escape problematic characters
        $stringValue = $stringValue -replace '[\r\n]+', ' ' # Replace newlines with spaces
        $stringValue = $stringValue -replace '\t', ' '      # Replace tabs with spaces
        $stringValue = $stringValue -replace '"', '""'      # Escape quotes for CSV
    
        # Sanitize formula triggers for Excel security
        if ($stringValue -match '^[=@+\-]') {
            $stringValue = "'" + $stringValue
        }
    
        # Truncate if too long for Excel (32,767 character limit per cell)
        if ($stringValue.Length -gt 32760) {
            $stringValue = $stringValue.Substring(0, 32760) + "..."
        }
    
        return $stringValue
    }

    # Function to format XML - MUST BE DEFINED BEFORE Test-EventMatches
    function Format-EventXml {
        param(
            [Parameter(Mandatory = $true)]
            [AllowEmptyString()]
            [string]$XmlString,
            
            [Parameter(Mandatory = $true)]
            [int]$TruncateLength
        )
        
        try {
            # Defensive: Handle null/empty input
            if ([string]::IsNullOrWhiteSpace($XmlString)) { 
                Write-Verbose "Format-EventXml: XML string is null or empty"
                return "[No XML Data]" 
            }
            
            # Defensive: Handle disabled display
            if ($TruncateLength -eq 0) { 
                Write-Verbose "Format-EventXml: XML display disabled (TruncateLength=0)"
                return "[XML Display Disabled]" 
            }
            
            # Parse XML with defensive error handling
            $xmlDoc = [xml]$XmlString
            $outputLines = @()
            
            # Defensive: Verify XML structure
            if ($null -eq $xmlDoc -or $null -eq $xmlDoc.Event) {
                Write-Verbose "Format-EventXml: Invalid XML structure - Event node missing"
                return "  [Invalid XML Structure]"
            }
            
            if ($xmlDoc.Event.System) {
                $system = $xmlDoc.Event.System
                $outputLines += "  System:"
                if ($system.Provider.Name) { $outputLines += "    Provider: $($system.Provider.Name)" }
                if ($system.EventID) { $outputLines += "    EventID: $($system.EventID)" }
                if ($system.Level) { $outputLines += "    Level: $($system.Level)" }
                if ($system.Task) { $outputLines += "    Task: $($system.Task)" }
                if ($system.Keywords) { $outputLines += "    Keywords: $($system.Keywords)" }
                if ($system.TimeCreated.SystemTime) { $outputLines += "    TimeCreated: $($system.TimeCreated.SystemTime)" }
                if ($system.EventRecordID) { $outputLines += "    RecordID: $($system.EventRecordID)" }
                if ($system.Execution.ProcessID) { $outputLines += "    ProcessID: $($system.Execution.ProcessID)" }
                if ($system.Execution.ThreadID) { $outputLines += "    ThreadID: $($system.Execution.ThreadID)" }
                if ($system.Channel) { $outputLines += "    Channel: $($system.Channel)" }
                if ($system.Computer) { $outputLines += "    Computer: $($system.Computer)" }
            }
            
            if ($xmlDoc.Event.EventData -and $xmlDoc.Event.EventData.Data) {
                $outputLines += "  EventData:"
                foreach ($data in $xmlDoc.Event.EventData.Data) {
                    if ($data -is [System.Xml.XmlElement]) {
                        $name = if ($data.Name) { $data.Name } else { "Data" }
                        $value = if ($data.InnerText) { $data.InnerText } else { $data.'#text' }
                        if (![string]::IsNullOrWhiteSpace($value)) {
                            $outputLines += "    $name`: $value"
                        }
                    }
                    elseif ($data -is [string] -and ![string]::IsNullOrWhiteSpace($data)) {
                        $outputLines += "    Data: $data"
                    }
                }
            }
            
            if ($xmlDoc.Event.UserData) {
                $outputLines += "  UserData:"
                foreach ($child in $xmlDoc.Event.UserData.ChildNodes) {
                    if ($child.InnerText) {
                        $outputLines += "    $($child.Name): $($child.InnerText)"
                    }
                    elseif ($child.HasChildNodes) {
                        $outputLines += "    $($child.Name):"
                        foreach ($subChild in $child.ChildNodes) {
                            if ($subChild.InnerText) {
                                $outputLines += "      $($subChild.Name): $($subChild.InnerText)"
                            }
                        }
                    }
                }
            }
            
            # Join output lines
            $result = ($outputLines -join "`n")
            Write-Verbose "Format-EventXml: Successfully formatted XML ($($outputLines.Count) lines, $($result.Length) chars)"
            
            # Apply truncation if needed (defensive length checks)
            if ($TruncateLength -gt 0 -and $result.Length -gt $TruncateLength) {
                try {
                    $truncateLen = [Math]::Min($TruncateLength, $result.Length)
                    if ($truncateLen -gt 0 -and $truncateLen -le $result.Length) {
                        $result = $result.Substring(0, $truncateLen) + "..."
                        Write-Verbose "Format-EventXml: Truncated to $truncateLen characters"
                    }
                }
                catch {
                    Write-Verbose "Format-EventXml: Truncation failed, returning full result"
                }
            }
            
            return $result
            
        }
        catch {
            Write-Verbose "Format-EventXml: XML parsing error - $($_.Exception.Message)"
            
            # Return safe error message (defensive truncation)
            $rawResult = "  [XML Parse Error]"
            if ($TruncateLength -gt 0) {
                try {
                    $truncateLen = [Math]::Min($TruncateLength, $rawResult.Length)
                    if ($truncateLen -gt 0 -and $truncateLen -le $rawResult.Length) {
                        $rawResult = $rawResult.Substring(0, $truncateLen) + "..."
                    }
                }
                catch {
                    # If even error truncation fails, return minimal error
                    $rawResult = "  [XML Error]"
                }
            }
            return $rawResult
        }
    }

    # Function to test if strings match - Search takes precedence over Exclude
    # PERFORMANCE: Uses regex for bulk pattern matching with 85+ IOCs
    function Test-EventMatches {
        param($Event, $Search, $Exclude, $SearchXMLEnabled)
        
        # Build searchable content efficiently
        $message = if ([string]::IsNullOrWhiteSpace($Event.Message)) { "" } else { $Event.Message }
        
        # PERFORMANCE OPTIMIZATION: Build regex pattern once for multiple IOCs
        # Regex is MUCH faster than multiple -like comparisons for large IOC lists
        $needsXml = $false
        
        # PRIORITY 1: If Search is specified, check for matches
        if ($Search.Count -gt 0) {
            # Build combined regex pattern (escape special chars, join with OR)
            # PERFORMANCE: Cache based on reference equality for speed
            if (-not $script:CachedSearchRegex -or $script:CachedSearchReference -ne $Search) {
                $escapedPatterns = $Search | ForEach-Object { [regex]::Escape($_) }
                $script:CachedSearchRegex = ($escapedPatterns -join '|')
                $script:CachedSearchReference = $Search
            }
            
            # Single regex match is MUCH faster than 85 -like comparisons
            if ($message -match $script:CachedSearchRegex) {
                return $true  # Match found in message - skip XML entirely
            }
            
            # Only check XML if SearchXML switch is enabled
            if ($SearchXMLEnabled) {
                $needsXml = $true
            }
            else {
                # XML search disabled and no match in message
                # Return false only if Search was specified (filtering mode)
                # If no Search specified, we're only checking Exclude
                if ($Search.Count -gt 0) {
                    return $false  # Search specified but no match found
                }
            }
        }
        
        # PRIORITY 2: Check Exclude only if Search didn't match or wasn't specified
        if ($Exclude.Count -gt 0 -and -not $needsXml) {
            # Build exclude regex pattern
            # PERFORMANCE: Cache based on reference equality for speed
            if (-not $script:CachedExcludeRegex -or $script:CachedExcludeReference -ne $Exclude) {
                $escapedExcludes = $Exclude | ForEach-Object { [regex]::Escape($_) }
                $script:CachedExcludeRegex = ($escapedExcludes -join '|')
                $script:CachedExcludeReference = $Exclude
            }
            
            if ($message -match $script:CachedExcludeRegex) {
                return $false  # Excluded - no need to check XML
            }
            
            # Only check XML exclude if SearchXML switch is enabled
            if ($SearchXMLEnabled) {
                $needsXml = $true
            }
        }
        
        # Only parse XML if absolutely necessary
        $xmlContent = ""
        if ($needsXml) {
            # Cache FORMATTED XML (same format as display) for consistent search/display
            # Defensive: Check if cached XML exists and is valid (not empty)
            $hasCachedXml = $Event.PSObject.Properties['_CachedFormattedXml']
            $cachedIsValid = $hasCachedXml -and (-not [string]::IsNullOrWhiteSpace($Event._CachedFormattedXml))
            
            if (-not $cachedIsValid) {
                # Need to format XML - defensive error handling
                try {
                    $rawXml = $Event.ToXml()
                    
                    # Defensive: Verify we got valid XML string
                    if ([string]::IsNullOrWhiteSpace($rawXml)) {
                        Write-Verbose "Test-EventMatches: Event.ToXml() returned empty string"
                        $xmlContent = ""
                    }
                    else {
                        # Format XML for searching (use -1 for full content, no truncation)
                        $formattedXml = Format-EventXml -XmlString $rawXml -TruncateLength -1
                        
                        # Defensive: Verify formatting succeeded
                        if ([string]::IsNullOrWhiteSpace($formattedXml)) {
                            Write-Verbose "Test-EventMatches: Format-EventXml returned empty string"
                            $xmlContent = ""
                        }
                        else {
                            # Cache the formatted XML and assign to search content
                            $Event | Add-Member -MemberType NoteProperty -Name "_CachedFormattedXml" -Value $formattedXml -Force
                            $xmlContent = $formattedXml
                            Write-Verbose "Test-EventMatches: Formatted and cached XML ($($xmlContent.Length) chars)"
                        }
                    }
                }
                catch {
                    Write-Verbose "Test-EventMatches: Error formatting XML - $($_.Exception.Message)"
                    $xmlContent = ""
                }
            }
            else {
                # Use valid cached XML
                $xmlContent = $Event._CachedFormattedXml
                Write-Verbose "Test-EventMatches: Using cached XML ($($xmlContent.Length) chars)"
            }
            
            # Complete Search check with XML - search each line with trimming for flexibility
            if ($Search.Count -gt 0) {
                # Defensive: Verify we have content to search
                if ([string]::IsNullOrWhiteSpace($xmlContent)) {
                    Write-Verbose "Test-EventMatches: No XML content available for search"
                    return $false
                }
                
                $foundMatch = $false
                
                try {
                    # Split XML into lines for line-by-line matching
                    $xmlLines = $xmlContent -split "`n"
                    
                    # Search each line (with trimming for flexibility)
                    foreach ($line in $xmlLines) {
                        if ([string]::IsNullOrWhiteSpace($line)) { continue }
                        
                        $trimmedLine = $line.Trim()
                        if ($trimmedLine -match $script:CachedSearchRegex) {
                            $foundMatch = $true
                            Write-Verbose "Test-EventMatches: Match found in XML"
                            break
                        }
                    }
                }
                catch {
                    Write-Verbose "Test-EventMatches: Error searching XML - $($_.Exception.Message)"
                    return $false
                }
                
                return $foundMatch
            }
            
            # Complete Exclude check with XML - search each line with trimming
            if ($Exclude.Count -gt 0) {
                $xmlLines = $xmlContent -split "`n"
                foreach ($line in $xmlLines) {
                    $trimmedLine = $line.Trim()
                    if ($trimmedLine -match $script:CachedExcludeRegex) {
                        return $false  # Found in exclude
                    }
                }
            }
        }
        
        # No Search specified and didn't match any Exclude - include event
        return $true
    }

    # Function to create hash key for deduplication
    # PERFORMANCE: Simplified to avoid expensive substring operations
    function Get-EventHashKey {
        param($Event)
        
        # Use RecordId as primary key when available (unique per log)
        # Only fall back to complex key for events without RecordId
        if ($Event.RecordId -and $Event.LogName) {
            return "$($Event.LogName)|$($Event.RecordId)"
        }
        
        # Fallback for EVTX files that might not have RecordId
        return "$($Event.LogName)|$($Event.Id)|$($Event.TimeCreated.Ticks)"
    }

    # Function to find matching include strings - returns formatted string of matches with locations
    # PERFORMANCE: Uses cached XML and optimized matching
    function Get-MatchedStrings {
        param($Event, $Search, $SearchXMLEnabled)
        
        if ($Search.Count -eq 0) {
            return ""
        }
        
        $matchList = @()
        $message = if ([string]::IsNullOrWhiteSpace($Event.Message)) { "" } else { $Event.Message }
        
        # Use cached FORMATTED XML (same format as display)
        $xmlContent = ""
        
        # Defensive: Check if cached XML exists and is valid (not empty)
        $hasCachedXml = $Event.PSObject.Properties['_CachedFormattedXml']
        $cachedIsValid = $hasCachedXml -and (-not [string]::IsNullOrWhiteSpace($Event._CachedFormattedXml))
        
        if ($cachedIsValid) {
            # Use existing valid cache
            $xmlContent = $Event._CachedFormattedXml
        }
        else {
            # Need to format XML - defensive error handling
            try {
                $rawXml = $Event.ToXml()
                
                if (-not [string]::IsNullOrWhiteSpace($rawXml)) {
                    $formattedXml = Format-EventXml -XmlString $rawXml -TruncateLength -1
                    
                    if (-not [string]::IsNullOrWhiteSpace($formattedXml)) {
                        $Event | Add-Member -MemberType NoteProperty -Name "_CachedFormattedXml" -Value $formattedXml -Force
                        $xmlContent = $formattedXml
                    }
                }
            }
            catch {
                Write-Verbose "Get-MatchedStrings: Error formatting XML - $($_.Exception.Message)"
                $xmlContent = ""
            }
        }
        
        # Collect ALL matches - forensics requires complete data
        foreach ($includeStr in $Search) {
            if ([string]::IsNullOrWhiteSpace($includeStr)) { continue }
            
            $foundIn = @()
            try {
                # Use -match for faster performance (already escaped in Test-EventMatches)
                $escapedPattern = [regex]::Escape($includeStr)
                if ($message -match $escapedPattern) { 
                    $foundIn += "MSG" 
                }
                # Only check XML if SearchXML is enabled - search each line with trimming
                if ($SearchXMLEnabled) {
                    $xmlLines = $xmlContent -split "`n"
                    foreach ($line in $xmlLines) {
                        $trimmedLine = $line.Trim()
                        if ($trimmedLine -match $escapedPattern) {
                            $foundIn += "XML"
                            break
                        }
                    }
                }
            }
            catch {
                Write-Verbose "Error matching string '$includeStr': $($_.Exception.Message)"
                continue
            }
            
            if ($foundIn.Count -gt 0) {
                # Truncate long search strings for display
                $matchStr = if ($includeStr.Length -gt 50) { 
                    $includeStr.Substring(0, 47) + "..." 
                }
                else { 
                    $includeStr 
                }
                $location = $foundIn -join ","
                $matchList += "$matchStr [$location]"
            }
        }
        
        return ($matchList -join "; ")
    }

    # Function to perform aggressive log file search
    function Search-AggressiveLogFiles {
        param($SearchPath, $Search, $MsgTruncateLength)
        
        $logMatches = @()
        $maxFileSizeMB = 100  # Safety limit - don't scan files larger than 100MB
        
        # Check if we've already scanned C:\ and have cached results
        if ($SearchPath -eq "C:\" -and $global:HuntLogs_SystemScanComplete -and $global:HuntLogs_LogFilePaths) {
            Write-Host "Using cached log file paths from previous system scan..." -ForegroundColor Cyan
            Write-Host "Cached paths: $($global:HuntLogs_LogFilePaths.Count) .log files" -ForegroundColor Green
            $logFileList = $global:HuntLogs_LogFilePaths | ForEach-Object { 
                if (Test-Path $_) { Get-Item $_ -ErrorAction SilentlyContinue }
            } | Where-Object { $null -ne $_ }
        }
        else {
            Write-Host "Starting aggressive log file search in: $SearchPath" -ForegroundColor Yellow
            Write-Progress -Activity "Aggressive Log Search" -Status "Scanning for .log files..." -PercentComplete 0
            
            try {
                $logFileList = Get-ChildItem -Path $SearchPath -Filter "*.log" -Recurse -File -ErrorAction SilentlyContinue -Force
                
                # Display discovered log file paths
                Write-Host "Discovered .log files:" -ForegroundColor Cyan
                $logFileList | ForEach-Object { Write-Host "  $($_.FullName) ($([math]::Round($_.Length / 1MB, 2)) MB)" -ForegroundColor Gray }
                
                # Cache results if scanning C:\
                if ($SearchPath -eq "C:\") {
                    $global:HuntLogs_SystemScanComplete = $true
                    $global:HuntLogs_LogFilePaths = $logFileList | Select-Object -ExpandProperty FullName
                    Write-Host "Cached $($logFileList.Count) log file paths for future searches." -ForegroundColor Green
                }
            }
            catch {
                Write-Warning "Error during log file discovery: $($_.Exception.Message)"
                return @()
            }
        }

        if ($logFileList.Count -eq 0) {
            Write-Host "No .log files found in: $SearchPath" -ForegroundColor Yellow
            return @()
        }

        Write-Host "Found $($logFileList.Count) log files. Applying safety filters..." -ForegroundColor Green
        
        # Apply safety filter for file size
        $safeLogFiles = @()
        $skippedLargeFiles = 0
        foreach ($logFile in $logFileList) {
            $fileSizeMB = $logFile.Length / 1MB
            if ($fileSizeMB -gt $maxFileSizeMB) {
                $skippedLargeFiles++
                Write-Verbose "Skipping large file: $($logFile.FullName) (Size: $([math]::Round($fileSizeMB, 2)) MB > $maxFileSizeMB MB limit)"
            }
            else {
                $safeLogFiles += $logFile
            }
        }
        
        if ($skippedLargeFiles -gt 0) {
            Write-Host "Safety filter: Skipped $skippedLargeFiles large files (>$maxFileSizeMB MB) to prevent timeouts" -ForegroundColor Yellow
        }
        
        if ($safeLogFiles.Count -eq 0) {
            Write-Host "No safe-sized log files to scan after applying safety filters." -ForegroundColor Yellow
            return @()
        }
        
        Write-Host "Scanning $($safeLogFiles.Count) safe-sized files for matches..." -ForegroundColor Green

        $currentFileIndex = 0
        $totalSafeFiles = $safeLogFiles.Count
        foreach ($logFile in $safeLogFiles) {
            $currentFileIndex++
            $percentComplete = [math]::Min(($currentFileIndex / $totalSafeFiles) * 100, 100)
            Write-Progress -Activity "Aggressive Log Search" -Status "Processing $($logFile.Name) ($currentFileIndex of $($safeLogFiles.Count))" -PercentComplete $percentComplete
            
            try {
                $content = Get-Content -Path $logFile.FullName -ErrorAction SilentlyContinue
                if ($null -eq $content) { continue }
                
                foreach ($line in $content) {
                    foreach ($searchString in $Search) {
                        if ($line -like "*$searchString*") {
                            $truncatedText = $line
                            if ($MsgTruncateLength -gt 0 -and $line.Length -gt $MsgTruncateLength) {
                                $truncatedText = $line.Substring(0, [math]::Max(1, $MsgTruncateLength)) + "..."
                            }
                            
                            $logMatches += [PSCustomObject]@{
                                FilePath         = $logFile.FullName
                                CreationDate     = $logFile.CreationTime
                                LastModifiedDate = $logFile.LastWriteTime
                                Match            = $searchString
                                Text             = $truncatedText
                            }
                            break # Only add one match per line
                        }
                    }
                }
            }
            catch {
                Write-Verbose "Error processing file $($logFile.FullName): $($_.Exception.Message)"
            }
        }
        
        Write-Progress -Activity "Aggressive Log Search" -Completed
        return $logMatches
    }

    # Convert input dates with defensive error handling
    $parsedStartDate = $null
    $parsedEndDate = $null
    
    if ($null -ne $StartDate -or $null -ne $EndDate) {
        try {
            # Parse dates if provided
            if ($null -ne $StartDate) {
                $parsedStartDate = ConvertTo-DateTime -InputValue $StartDate -TargetTimeZone $targetTimeZone
            }
            if ($null -ne $EndDate) {
                $parsedEndDate = ConvertTo-DateTime -InputValue $EndDate -TargetTimeZone $targetTimeZone
            }
            
            # Validation: Ensure StartDate is before EndDate (if both provided)
            if ($null -ne $parsedStartDate -and $null -ne $parsedEndDate) {
                if ($parsedStartDate -gt $parsedEndDate) {
                    throw "StartDate ($StartDate) cannot be after EndDate ($EndDate). Please check your date range."
                }
                
                # Validation: Warn if date range is excessively large 
                $daysDifference = ($parsedEndDate - $parsedStartDate).TotalDays
                if ($daysDifference -gt 30) {
                    Write-Warning "Large date range detected: $([math]::Round($daysDifference, 0)) days. This may take significant time to process."
                }
            }
            
            # Validation: Warn if searching future dates
            if ($null -ne $parsedStartDate) {
                $now = Get-Date
                if ($parsedStartDate -gt $now) {
                    Write-Warning "StartDate is in the future. No logs will be found."
                }
            }
            
            if (-not $Quiet) {
                if ($null -ne $parsedStartDate -and $null -ne $parsedEndDate) {
                    $formattedStart = Format-DateTimeWithTimeZone -DateTime $parsedStartDate -TargetTimeZone $targetTimeZone
                    $formattedEnd = Format-DateTimeWithTimeZone -DateTime $parsedEndDate -TargetTimeZone $targetTimeZone
                    Write-Host "[INFO] Search Range: $formattedStart to $formattedEnd" -ForegroundColor Cyan
                }
                elseif ($null -ne $parsedStartDate) {
                    $formattedStart = Format-DateTimeWithTimeZone -DateTime $parsedStartDate -TargetTimeZone $targetTimeZone
                    Write-Host "[INFO] Search Range: From $formattedStart to present" -ForegroundColor Cyan
                }
            }
        }
        catch {
            Write-Error "Date parsing error: $($_.Exception.Message)"
            Write-Host ""
            Write-Host "Valid date formats:" -ForegroundColor Yellow
            Write-Host "  - Relative: '7D' (days), '24H' (hours), '30M' (minutes)" -ForegroundColor Gray
            Write-Host "  - Absolute: '2025-01-01', '2025-01-01 14:30:00'" -ForegroundColor Gray
            Write-Host "  - Keyword: 'Now' for current time" -ForegroundColor Gray
            Write-Host "  - No dates: Retrieves ALL available logs" -ForegroundColor Gray
            Write-Host ""
            throw
        }
    }
    else {
        # No date filtering - will retrieve ALL logs
        if (-not $Quiet) {
            Write-Host "[INFO] No date range specified. Retrieving ALL available logs (no time filter)" -ForegroundColor Cyan
        }
    }

    # ============================================================================
    # CACHE DECISION LOGIC
    # ============================================================================
    
    # Determine query mode
    $queryMode = if (![string]::IsNullOrWhiteSpace($FolderPath)) { "EVTX" } else { "Live" }
    $queryFolderPath = if (![string]::IsNullOrWhiteSpace($FolderPath)) { $FolderPath } else { "" }
    
    # Check if we can use cache
    $cacheDecision = Test-CacheValidity `
        -RequestedStartDate $parsedStartDate `
        -RequestedEndDate $parsedEndDate `
        -RequestedLogNames $LogNames `
        -RequestedEventId $EventId `
        -RequestedProcessID $ProcessID `
        -RequestedThreadID $ThreadID `
        -RequestedFolderPath $queryFolderPath `
        -RequestedMode $queryMode
    
    $useCache = $false
    $requiresPartialRefresh = $false
    $requiresFullRefresh = $true
    $supplementalStartDate = $null
    $supplementalEndDate = $null
    
    if ($cacheDecision.Valid -and $cacheDecision.UseCache) {
        $useCache = $true
        
        if ($cacheDecision.RequiresPartialRefresh) {
            $requiresPartialRefresh = $true
            $requiresFullRefresh = $false
            
            # Calculate what additional data we need
            if ($cacheDecision.NeedsEarlierData -and $cacheDecision.NeedsLaterData) {
                # Need both earlier and later - this is complex, just do full refresh
                Write-Verbose "Cache needs both earlier and later data - performing full refresh"
                $requiresFullRefresh = $true
                $requiresPartialRefresh = $false
                $useCache = $false
                Clear-HuntLogsCache -Silent
            }
            elseif ($cacheDecision.NeedsEarlierData) {
                # Need earlier data
                $supplementalStartDate = $parsedStartDate
                $supplementalEndDate = $cacheDecision.CachedStart.AddSeconds(-1)
                Write-Verbose "Cache hit (partial) - need earlier data from $supplementalStartDate to $supplementalEndDate"
                
                $global:HuntLogsCache.Statistics.PartialHits++
                $global:HuntLogsCache.Statistics.LastOperation = "Partial hit - earlier data"
            }
            elseif ($cacheDecision.NeedsLaterData) {
                # Need later data
                $supplementalStartDate = $cacheDecision.CachedEnd.AddSeconds(1)
                $supplementalEndDate = $parsedEndDate
                Write-Verbose "Cache hit (partial) - need later data from $supplementalStartDate to $supplementalEndDate"
                
                $global:HuntLogsCache.Statistics.PartialHits++
                $global:HuntLogsCache.Statistics.LastOperation = "Partial hit - later data"
            }
        }
        else {
            # Full cache hit - no refresh needed
            $requiresFullRefresh = $false
            Write-Verbose "Cache hit (full) - using cached data"
            if (-not $Quiet) {
                Write-Host "[CACHE] Using cached results ($($global:HuntLogsCache.RawEvents.Count) events in cache)" -ForegroundColor Green
            }
            
            $global:HuntLogsCache.Statistics.CacheHits++
            $global:HuntLogsCache.Statistics.LastOperation = "Full cache hit"
        }
    }
    else {
        # Cache miss or invalid - full refresh needed
        Write-Verbose "Cache miss: $($cacheDecision.Reason)"
        if ($cacheDecision.RequiresFullRefresh) {
            Clear-HuntLogsCache -Silent
        }
        
        $global:HuntLogsCache.Statistics.CacheMisses++
        $global:HuntLogsCache.Statistics.LastOperation = "Cache miss - $($cacheDecision.Reason)"
    }
    
    # ============================================================================
    # END CACHE DECISION LOGIC
    # ============================================================================

    # Handle Aggressive search first (will be displayed last)
    $aggressiveResults = @()
    if ($PSBoundParameters.ContainsKey('Aggressive')) {
        $searchPath = if ([string]::IsNullOrWhiteSpace($Aggressive)) { "C:\" } else { $Aggressive }
        
        if (-not (Test-Path $searchPath)) {
            throw "Aggressive search path does not exist: $searchPath"
        }
        
        $aggressiveResults = Search-AggressiveLogFiles -SearchPath $searchPath -Search $Search -MsgTruncateLength $msgTruncateLength
    }

    Write-Progress -Activity "Initializing Hunt-Logs" -Status "Getting log list..." -PercentComplete 0

    $allEvents = @{}
    $eventCount = 0
    $filteredCount = 0
    $maxEventsHitCount = 0  
    $logsHitLimit = @()
    
    # ============================================================================
    # CACHE-AWARE EVENT COLLECTION
    # ============================================================================
    
    # If we have a full cache hit, use cached events directly
    if ($useCache -and -not $requiresPartialRefresh -and -not $requiresFullRefresh) {
        try {
            Write-Progress -Activity "Hunt-Logs Search" -Status "Retrieving events from cache..." -PercentComplete 50
            
            # Get RAW events from cache - NO FILTERING YET
            # Filtering happens later to ensure accuracy with changing query parameters
            $allEvents = Get-FilteredCachedEvents `
                -StartDate $parsedStartDate `
                -EndDate $parsedEndDate `
                -LogNames $LogNames `
                -EventId $EventId `
                -ProcessID $ProcessID `
                -ThreadID $ThreadID
            
            $eventCount = $allEvents.Count
            
            if (-not $Quiet) {
                Write-Host "[CACHE] Retrieved $eventCount raw events from cache (filtering will be applied next)" -ForegroundColor Green
            }
            
            # Update statistics
            Write-Progress -Activity "Hunt-Logs Search" -Status "Processing $eventCount cached events..." -PercentComplete 70
            
            # Skip log collection entirely - jump to filtering and display
        }
        catch {
            Write-Warning "Error retrieving cached events: $($_.Exception.Message). Falling back to full refresh."
            Clear-HuntLogsCache -Silent
            $requiresFullRefresh = $true
            $useCache = $false
        }
    }
    
    # Collect events if needed (full or partial refresh)
    if ($requiresFullRefresh -or $requiresPartialRefresh) {
        # Determine what date range to query
        $queryStartDate = if ($requiresPartialRefresh) { $supplementalStartDate } else { $parsedStartDate }
        $queryEndDate = if ($requiresPartialRefresh) { $supplementalEndDate } else { $parsedEndDate }
        
        if ($requiresPartialRefresh) {
            if (-not $Quiet) {
                $suppStart = Format-DateTimeWithTimeZone -DateTime $queryStartDate -TargetTimeZone $targetTimeZone
                $suppEnd = Format-DateTimeWithTimeZone -DateTime $queryEndDate -TargetTimeZone $targetTimeZone
                Write-Host "[CACHE] Collecting supplemental data: $suppStart to $suppEnd" -ForegroundColor Yellow
            }
            
            # Start with cached events
            foreach ($key in $global:HuntLogsCache.RawEvents.Keys) {
                $allEvents[$key] = $global:HuntLogsCache.RawEvents[$key]
            }
            $eventCount = $allEvents.Count
        }
    
        # Determine processing mode
        if (![string]::IsNullOrWhiteSpace($FolderPath)) {
            # EVTX File Mode
            if (-not (Test-Path $FolderPath)) {
                throw "EVTX path does not exist: $FolderPath"
            }

            $evtxFileList = @()
            if (Test-Path $FolderPath -PathType Container) {
                $evtxFileList = Get-ChildItem -Path $FolderPath -Filter "*.evtx" -File -ErrorAction SilentlyContinue
            }
            else {
                if ($FolderPath -like "*.evtx") {
                    $evtxFileList = @(Get-Item $FolderPath -ErrorAction SilentlyContinue)
                }
                else {
                    throw "Specified file is not an EVTX file: $FolderPath"
                }
            }

            if ($evtxFileList.Count -eq 0) {
                Write-Warning "No EVTX files found in: $FolderPath"
                return
            }

            Write-Progress -Activity "Hunt-Logs Search" -Status "Found $($evtxFileList.Count) EVTX files to process" -PercentComplete 15

            if ($LogNames.Count -gt 0) {
                $filteredEvtxFiles = @()
                foreach ($evtxFile in $evtxFileList) {
                    $fileName = [System.IO.Path]::GetFileNameWithoutExtension($evtxFile.Name)
                    foreach ($logName in $LogNames) {
                        if ($fileName -like "*$logName*" -or $logName -like "*$fileName*") {
                            $filteredEvtxFiles += $evtxFile
                            break
                        }
                    }
                }
                $evtxFileList = $filteredEvtxFiles
            }

            # Display timezone context for EVTX files
            $currentSystemTZ = [System.TimeZoneInfo]::Local
            if ($targetTimeZone.Id -ne $currentSystemTZ.Id) {
                Write-Host "EVTX Timezone Note: Search range converted from $($targetTimeZone.DisplayName) to system time" -ForegroundColor Cyan
                Write-Host "Log timestamps will be converted to $($targetTimeZone.DisplayName) for display" -ForegroundColor Cyan
            }

            $currentFileIndex = 0
            $totalFiles = $evtxFileList.Count
            foreach ($evtxFile in $evtxFileList) {
                $currentFileIndex++
                $percentComplete = [math]::Min(25 + (($currentFileIndex / $totalFiles) * 60), 85)
                Write-Progress -Activity "Hunt-Logs Search" -Status "Processing EVTX file $currentFileIndex of $totalFiles`: $($evtxFile.Name) (Found: $eventCount events)" -PercentComplete $percentComplete

                try {
                    $filterHash = @{
                        Path = $evtxFile.FullName
                    }
                    
                    # Only add time filters if dates are provided
                    if ($null -ne $queryStartDate) { $filterHash.StartTime = $queryStartDate }
                    if ($null -ne $queryEndDate) { $filterHash.EndTime = $queryEndDate }
                    
                    if ($EventId.Count -gt 0) { $filterHash.Id = $EventId }

                    # PERFORMANCE: Limit events retrieved per file
                    # SortOrder controls which events are retrieved when MaxEvents is reached
                    if ($MaxEvents -gt 0) {
                        if ($SortOrder -eq "OldestFirst") {
                            # Oldest first: Reverse the default retrieval order
                            $events = Get-WinEvent -FilterHashtable $filterHash -MaxEvents $MaxEvents -Oldest -ErrorAction SilentlyContinue
                        }
                        else {
                            # Newest first (default): Normal retrieval order
                            $events = Get-WinEvent -FilterHashtable $filterHash -MaxEvents $MaxEvents -ErrorAction SilentlyContinue
                        }
                    
                        # DETECTION: Check if we hit the MaxEvents limit
                        if ($events -and $events.Count -eq $MaxEvents) {
                            $maxEventsHitCount++
                            $logsHitLimit += $evtxFile.Name
                            $sortDirection = if ($SortOrder -eq "OldestFirst") { "Oldest" } else { "Newest" }
                            Write-Verbose "EVTX file '$($evtxFile.Name)' hit MaxEvents limit, read $MaxEvents $sortDirection events."
                        }
                    }
                    else {
                        # No limit: Retrieve all events
                        if ($SortOrder -eq "OldestFirst") {
                            $events = Get-WinEvent -FilterHashtable $filterHash -Oldest -ErrorAction SilentlyContinue
                        }
                        else {
                            $events = Get-WinEvent -FilterHashtable $filterHash -ErrorAction SilentlyContinue
                        }
                    }

                    if ($events) {
                        foreach ($eventItem in $events) {
                            # CACHE RAW EVENTS - NO FILTERING DURING COLLECTION
                            # All filtering happens later to ensure cache accuracy
                            $hashKey = Get-EventHashKey -Event $eventItem
                            if (-not $allEvents.ContainsKey($hashKey)) {
                                $allEvents[$hashKey] = $eventItem
                                $eventCount++
                            }
                        }
                    }
                }
                catch {
                    Write-Warning "Error processing EVTX file '$($evtxFile.Name)': $($_.Exception.Message)"
                }
            }
        
            # Update cache with newly collected EVTX events
            if ($requiresFullRefresh -or $requiresPartialRefresh) {
                try {
                    $newEventCount = Add-EventsToCache -NewEvents $allEvents
                    Update-CacheParameters `
                        -StartDate $parsedStartDate `
                        -EndDate $parsedEndDate `
                        -LogNames $LogNames `
                        -EventId $EventId `
                        -ProcessID $ProcessID `
                        -ThreadID $ThreadID `
                        -FolderPath $queryFolderPath `
                        -Mode $queryMode
                
                    if (-not $Quiet -and $newEventCount -gt 0) {
                        Write-Host "[CACHE] Added $newEventCount new RAW events to cache (unfiltered)" -ForegroundColor Green
                    }
                }
                catch {
                    Write-Warning "Error updating cache: $($_.Exception.Message)"
                }
            }

        }
        else {
            # Live Log Mode
            $logsToQuery = @()
            $currentQueryIndex = 0

            try {
                # Get all available logs with records
                if ($null -ne $parsedStartDate) {
                    # Filter by LastWriteTime if we have a start date
                    $availableLogs = Get-WinEvent -ListLog * -ErrorAction SilentlyContinue |
                    Where-Object { $_.RecordCount -gt 0 -and $_.RecordCount -lt 1000000 -and $_.LastWriteTime -ge $parsedStartDate.AddDays(-30) }
                }
                else {
                    # No start date - get all logs (no time filter on LastWriteTime)
                    $availableLogs = Get-WinEvent -ListLog * -ErrorAction SilentlyContinue |
                    Where-Object { $_.RecordCount -gt 0 -and $_.RecordCount -lt 1000000 }
                }

                if ($LogNames.Count -gt 0) {
                    # Wildcard matching support for LogNames
                    foreach ($logName in $LogNames) {
                        if ([string]::IsNullOrWhiteSpace($logName)) { continue }
                        
                        try {
                            # Check for wildcard characters
                            if ($logName -match '[\*\?]') {
                                # User specified wildcards - use -like matching
                                $matchedLogs = $availableLogs | Where-Object { $_.LogName -like $logName }
                                foreach ($matched in $matchedLogs) {
                                    if ($logsToQuery -notcontains $matched.LogName) {
                                        $logsToQuery += $matched.LogName
                                    }
                                }
                            }
                            else {
                                # No wildcards - use substring matching (case-insensitive)
                                # This handles "disk" matching "Microsoft-Windows-DiskDiagnostic..."
                                $matchedLogs = $availableLogs | Where-Object { $_.LogName -like "*$logName*" }
                                
                                if ($matchedLogs) {
                                    foreach ($matched in $matchedLogs) {
                                        if ($logsToQuery -notcontains $matched.LogName) {
                                            $logsToQuery += $matched.LogName
                                        }
                                    }
                                }
                                else {
                                    # No matches found - add as-is (may be exact name or will fail gracefully)
                                    if ($logsToQuery -notcontains $logName) {
                                        $logsToQuery += $logName
                                    }
                                }
                            }
                        }
                        catch {
                            Write-Verbose "Error matching log name '$logName': $($_.Exception.Message)"
                            # Add as-is on error
                            if ($logsToQuery -notcontains $logName) {
                                $logsToQuery += $logName
                            }
                        }
                    }
                    
                    if ($logsToQuery.Count -gt 0 -and -not $Quiet) {
                        Write-Host "[INFO] Matched $($logsToQuery.Count) log(s) from LogNames filter" -ForegroundColor Cyan
                    }
                }
                else {
                    $logsToQuery = $availableLogs | Select-Object -ExpandProperty LogName
                }
            }
            catch {
                Write-Verbose "Error getting log list: $($_.Exception.Message)"
            }

            $totalQueries = $logsToQuery.Count
            Write-Progress -Activity "Hunt-Logs Search" -Status "Found $totalQueries logs to search" -PercentComplete 15

            if ($totalQueries -eq 0) { 
                Write-Warning "No logs found to search."
                if ($aggressiveResults.Count -eq 0) { return }
            }

            foreach ($logName in $logsToQuery) {
                $currentQueryIndex++
                $percentComplete = [math]::Min(25 + (($currentQueryIndex / $totalQueries) * 60), 85)
                Write-Progress -Activity "Hunt-Logs Search" -Status "Processing log $currentQueryIndex of $totalQueries`: $logName (Found: $eventCount events)" -PercentComplete $percentComplete

                try {
                    $filterHash = @{ 
                        LogName = $logName
                    }
                    
                    # Only add time filters if dates are provided
                    if ($null -ne $queryStartDate) { $filterHash.StartTime = $queryStartDate }
                    if ($null -ne $queryEndDate) { $filterHash.EndTime = $queryEndDate }
                    
                    if ($EventId.Count -gt 0) { $filterHash.Id = $EventId }

                    # PERFORMANCE: Limit events retrieved per log (CRITICAL for large logs)
                    # SortOrder controls which events are retrieved when MaxEvents is reached
                    if ($MaxEvents -gt 0) {
                        if ($SortOrder -eq "OldestFirst") {
                            # Oldest first: Reverse the default retrieval order
                            $events = Get-WinEvent -FilterHashtable $filterHash -MaxEvents $MaxEvents -Oldest -ErrorAction SilentlyContinue
                        }
                        else {
                            # Newest first (default): Normal retrieval order
                            $events = Get-WinEvent -FilterHashtable $filterHash -MaxEvents $MaxEvents -ErrorAction SilentlyContinue
                        }
                    
                        # DETECTION: Check if we hit the MaxEvents limit
                        # If exactly MaxEvents returned, the log likely has more events that weren't retrieved
                        if ($events -and $events.Count -eq $MaxEvents) {
                            $maxEventsHitCount++
                            $logsHitLimit += $logName
                            $sortDirection = if ($SortOrder -eq "OldestFirst") { "Oldest" } else { "Newest" }
                            Write-Verbose "Log '$logName' hit MaxEvents limit, read $MaxEvents $sortDirection events."
                        }
                    }
                    else {
                        # User explicitly set MaxEvents=0, retrieve all (WARNING: can be slow)
                        if ($SortOrder -eq "OldestFirst") {
                            $events = Get-WinEvent -FilterHashtable $filterHash -Oldest -ErrorAction SilentlyContinue
                        }
                        else {
                            $events = Get-WinEvent -FilterHashtable $filterHash -ErrorAction SilentlyContinue
                        }
                    }

                    if ($events) {
                        foreach ($eventItem in $events) {
                            # CACHE RAW EVENTS - NO FILTERING DURING COLLECTION
                            # All filtering happens later to ensure cache accuracy
                            $hashKey = Get-EventHashKey -Event $eventItem
                            if (-not $allEvents.ContainsKey($hashKey)) {
                                $allEvents[$hashKey] = $eventItem
                                $eventCount++
                            }
                        }
                    }
                }
                catch {
                    Write-Verbose "Error processing log '$logName': $($_.Exception.Message)"
                }
            }
        
            # Update cache with newly collected live log events
            if ($requiresFullRefresh -or $requiresPartialRefresh) {
                try {
                    $newEventCount = Add-EventsToCache -NewEvents $allEvents
                    Update-CacheParameters `
                        -StartDate $parsedStartDate `
                        -EndDate $parsedEndDate `
                        -LogNames $LogNames `
                        -EventId $EventId `
                        -ProcessID $ProcessID `
                        -ThreadID $ThreadID `
                        -FolderPath $queryFolderPath `
                        -Mode $queryMode
                
                    if (-not $Quiet -and $newEventCount -gt 0) {
                        Write-Host "[CACHE] Added $newEventCount new events to cache" -ForegroundColor Green
                    }
                }
                catch {
                    Write-Warning "Error updating cache: $($_.Exception.Message)"
                }
            }
    
        } 
    
    } 
    
    # ============================================================================
    # END CACHE-AWARE EVENT COLLECTION
    # ============================================================================

    Write-Progress -Activity "Hunt-Logs Search" -Status "Applying filters to $($allEvents.Count) events..." -PercentComplete 90

    # ============================================================================
    # UNIFIED FILTERING STEP
    # ============================================================================
    # Apply all content-based filters AFTER event collection/retrieval
    # This ensures cache accuracy regardless of what filters were used previously
    
    $preFilterCount = $allEvents.Count
    $filteredEvents = @{}
    
    # Cache filter counts for performance
    $hasExcludeEventId = $ExcludeEventId.Count -gt 0
    $hasProcessIDFilter = $ProcessID.Count -gt 0
    $hasThreadIDFilter = $ThreadID.Count -gt 0
    $hasSearchOrExclude = $Search.Count -gt 0 -or $Exclude.Count -gt 0
    
    foreach ($key in $allEvents.Keys) {
        $event = $allEvents[$key]
        
        # FILTER 1: ExcludeEventId (highest precedence - skip immediately)
        if ($hasExcludeEventId -and $ExcludeEventId -contains $event.Id) {
            $filteredCount++
            continue
        }
        
        # FILTER 2: ProcessID filtering (additive with Search)
        if ($hasProcessIDFilter) {
            # Fast path: direct containment check (null ProcessId will never match)
            if ($ProcessID -notcontains $event.ProcessId) {
                $filteredCount++
                continue
            }
        }
        
        # FILTER 3: ThreadID filtering (additive with Search)
        if ($hasThreadIDFilter) {
            # Fast path: direct containment check (null ThreadId will never match)
            if ($ThreadID -notcontains $event.ThreadId) {
                $filteredCount++
                continue
            }
        }
        
        # FILTER 4: Search/Exclude (content-based filtering)
        if ($hasSearchOrExclude) {
            if (-not (Test-EventMatches -Event $event -Search $Search -Exclude $Exclude -SearchXMLEnabled $SearchXML)) {
                $filteredCount++
                continue
            }
        }
        
        # Event passed all filters
        $filteredEvents[$key] = $event
    }
    
    $allEvents = $filteredEvents
    $eventCount = $allEvents.Count
    
    if (-not $Quiet -and $filteredCount -gt 0) {
        Write-Verbose "Filtered: $preFilterCount events  $eventCount events (removed $filteredCount)"
    }
    
    # ============================================================================
    # END UNIFIED FILTERING STEP
    # ============================================================================

    Write-Progress -Activity "Hunt-Logs Search" -Status "Processing $eventCount filtered events..." -PercentComplete 92

    # Add matched strings to events - ALWAYS recalculate for current search
    # This is done after cache retrieval to ensure search strings match current query
    $hasSearch = $Search.Count -gt 0
    
    foreach ($key in $allEvents.Keys) {
        $event = $allEvents[$key]
        
        if ($hasSearch) {
            # ALWAYS recalculate - search strings may have changed since event was cached
            $matchInfo = Get-MatchedStrings -Event $event -Search $Search -SearchXMLEnabled $SearchXML
            $event | Add-Member -MemberType NoteProperty -Name "MatchedStrings" -Value $matchInfo -Force
        }
        else {
            # No search strings - set empty
            $event | Add-Member -MemberType NoteProperty -Name "MatchedStrings" -Value "" -Force
        }
    }

    $uniqueEvents = $allEvents.Values
    $sortedEvents = if ($SortOrder -eq "OldestFirst") {
        $uniqueEvents | Sort-Object TimeCreated
    }
    else {
        $uniqueEvents | Sort-Object TimeCreated -Descending
    }

    Write-Progress -Activity "Hunt-Logs Search" -Status "Complete - Found $($sortedEvents.Count) unique events" -PercentComplete 100
    Start-Sleep -Milliseconds 500
    Write-Progress -Activity "Hunt-Logs Search" -Completed

    $totalOutputChars = 0

    # Function to print message with highlighted search matches
    function Write-HighlightedMessage {
        param(
            [string]$Message,
            [string[]]$SearchStrings,
            [string]$NormalColor = "Green",
            [string]$HighlightColor = "Red"
        )
        
        if ([string]::IsNullOrWhiteSpace($Message) -or $SearchStrings.Count -eq 0) {
            Write-Host $Message -ForegroundColor $NormalColor
            return
        }
        
        try {
            # Build a list of all match positions for all search strings
            $allMatches = @()
            
            foreach ($searchStr in $SearchStrings) {
                if ([string]::IsNullOrWhiteSpace($searchStr)) { continue }
                
                # Find all occurrences of this search string (case-insensitive)
                $position = 0
                while ($position -lt $Message.Length) {
                    # Use -like style matching but find exact positions
                    $foundIndex = $Message.IndexOf($searchStr, $position, [StringComparison]::OrdinalIgnoreCase)
                    
                    if ($foundIndex -ge 0) {
                        $allMatches += [PSCustomObject]@{
                            Start = $foundIndex
                            End   = $foundIndex + $searchStr.Length
                            Text  = $Message.Substring($foundIndex, $searchStr.Length)
                        }
                        $position = $foundIndex + 1  # Move past this match to find overlapping matches
                    }
                    else {
                        break  # No more matches for this search string
                    }
                }
            }
            
            if ($allMatches.Count -eq 0) {
                # No matches found, print normally
                Write-Host $Message -ForegroundColor $NormalColor
                return
            }
            
            # Sort matches by start position and merge overlapping matches
            $sortedMatches = $allMatches | Sort-Object Start
            $mergedMatches = @()
            $currentMatch = $null
            
            foreach ($match in $sortedMatches) {
                if ($null -eq $currentMatch) {
                    $currentMatch = $match
                }
                elseif ($match.Start -le $currentMatch.End) {
                    # Overlapping or adjacent - extend current match
                    if ($match.End -gt $currentMatch.End) {
                        $currentMatch.End = $match.End
                        $currentMatch.Text = $Message.Substring($currentMatch.Start, $currentMatch.End - $currentMatch.Start)
                    }
                }
                else {
                    # Non-overlapping - save current and start new
                    $mergedMatches += $currentMatch
                    $currentMatch = $match
                }
            }
            # Add the last match
            if ($null -ne $currentMatch) {
                $mergedMatches += $currentMatch
            }
            
            # Now print the message with highlights
            $lastEnd = 0
            foreach ($match in $mergedMatches) {
                # Print the text before the match (normal color)
                if ($match.Start -gt $lastEnd) {
                    $beforeText = $Message.Substring($lastEnd, $match.Start - $lastEnd)
                    Write-Host $beforeText -NoNewline -ForegroundColor $NormalColor
                }
                
                # Print the matched text (highlighted color)
                Write-Host $match.Text -NoNewline -ForegroundColor $HighlightColor
                
                $lastEnd = $match.End
            }
            
            # Print any remaining text after the last match
            if ($lastEnd -lt $Message.Length) {
                $afterText = $Message.Substring($lastEnd)
                Write-Host $afterText -NoNewline -ForegroundColor $NormalColor
            }
            
            # End the line
            Write-Host ""
        }
        catch {
            # If highlighting fails for any reason, fall back to normal printing
            Write-Verbose "Error highlighting message: $($_.Exception.Message)"
            Write-Host $Message -ForegroundColor $NormalColor
        }
    }

    # Function to print XML with highlighted search matches
    function Write-HighlightedXML {
        param(
            [string]$XmlText,
            [string[]]$SearchStrings,
            [string]$NormalColor = "Gray",
            [string]$HighlightColor = "Red"
        )
        
        if ([string]::IsNullOrWhiteSpace($XmlText) -or $SearchStrings.Count -eq 0) {
            Write-Host $XmlText -ForegroundColor $NormalColor
            return
        }
        
        try {
            # Split XML into lines for proper indentation
            $xmlLines = $XmlText -split "`n"
            
            foreach ($line in $xmlLines) {
                if ([string]::IsNullOrWhiteSpace($line.Trim())) { continue }
                
                # Build a list of all match positions for this line
                $allMatches = @()
                
                foreach ($searchStr in $SearchStrings) {
                    if ([string]::IsNullOrWhiteSpace($searchStr)) { continue }
                    
                    $position = 0
                    while ($position -lt $line.Length) {
                        $foundIndex = $line.IndexOf($searchStr, $position, [StringComparison]::OrdinalIgnoreCase)
                        
                        if ($foundIndex -ge 0) {
                            $allMatches += [PSCustomObject]@{
                                Start = $foundIndex
                                End   = $foundIndex + $searchStr.Length
                                Text  = $line.Substring($foundIndex, $searchStr.Length)
                            }
                            $position = $foundIndex + 1
                        }
                        else {
                            break
                        }
                    }
                }
                
                if ($allMatches.Count -eq 0) {
                    # No matches in this line
                    Write-Host $line -ForegroundColor $NormalColor
                    continue
                }
                
                # Sort and merge overlapping matches
                $sortedMatches = $allMatches | Sort-Object Start
                $mergedMatches = @()
                $currentMatch = $null
                
                foreach ($match in $sortedMatches) {
                    if ($null -eq $currentMatch) {
                        $currentMatch = $match
                    }
                    elseif ($match.Start -le $currentMatch.End) {
                        if ($match.End -gt $currentMatch.End) {
                            $currentMatch.End = $match.End
                            $currentMatch.Text = $line.Substring($currentMatch.Start, $currentMatch.End - $currentMatch.Start)
                        }
                    }
                    else {
                        $mergedMatches += $currentMatch
                        $currentMatch = $match
                    }
                }
                if ($null -ne $currentMatch) {
                    $mergedMatches += $currentMatch
                }
                
                # Print line with highlights
                $lastEnd = 0
                foreach ($match in $mergedMatches) {
                    if ($match.Start -gt $lastEnd) {
                        $beforeText = $line.Substring($lastEnd, $match.Start - $lastEnd)
                        Write-Host $beforeText -NoNewline -ForegroundColor $NormalColor
                    }
                    Write-Host $match.Text -NoNewline -ForegroundColor $HighlightColor
                    $lastEnd = $match.End
                }
                
                if ($lastEnd -lt $line.Length) {
                    $afterText = $line.Substring($lastEnd)
                    Write-Host $afterText -NoNewline -ForegroundColor $NormalColor
                }
                
                Write-Host ""
            }
        }
        catch {
            Write-Verbose "Error highlighting XML: $($_.Exception.Message)"
            Write-Host $XmlText -ForegroundColor $NormalColor
        }
    }

    # Collect results for PassThru and CSV export (always collect, regardless of PassThru)
    foreach ($logEvent in $sortedEvents) {
        $message = if ([string]::IsNullOrWhiteSpace($logEvent.Message)) { "[No Message]" } else { $logEvent.Message }
        $cleanMessage = $message -replace '\r?\n', ' ' -replace '\s+', ' ' -replace '^\s+|\s+$', ''

        # Always create result object for CSV export and potential PassThru
        $matchedStrings = if (($Search.Count -gt 0) -and $logEvent.MatchedStrings) { $logEvent.MatchedStrings } else { "" }
        $logResult = New-LogResult -LogEvent $logEvent -TargetTimeZone $targetTimeZone -MatchedStrings $matchedStrings
        $script:HuntLogResults += $logResult

        # Display only if not Quiet
        if (-not $Quiet) {
            # Prepare display message with dynamic truncation to ensure matches are visible
            $displayMessage = ""
            
            if ($msgTruncateLength -eq 0) {
                $displayMessage = "[Message Display Disabled]"
            }
            elseif ($msgTruncateLength -eq -1 -or $cleanMessage.Length -le $msgTruncateLength) {
                # Show full message (no truncation needed)
                $displayMessage = $cleanMessage
            }
            elseif ($msgTruncateLength -gt 0 -and $Search.Count -gt 0) {
                # Dynamic truncation: Ensure first match is visible
                try {
                    $firstMatchPosition = -1
                    $matchedSearchString = ""
                    
                    # Find the earliest match position in the message
                    foreach ($searchStr in $Search) {
                        if ([string]::IsNullOrWhiteSpace($searchStr)) { continue }
                        
                        $foundIndex = $cleanMessage.IndexOf($searchStr, [StringComparison]::OrdinalIgnoreCase)
                        if ($foundIndex -ge 0) {
                            if ($firstMatchPosition -eq -1 -or $foundIndex -lt $firstMatchPosition) {
                                $firstMatchPosition = $foundIndex
                                $matchedSearchString = $searchStr
                            }
                        }
                    }
                    
                    if ($firstMatchPosition -ge 0) {
                        # Found a match - ensure it's visible in truncated output
                        $matchEndPosition = $firstMatchPosition + $matchedSearchString.Length
                        
                        if ($matchEndPosition -le $msgTruncateLength) {
                            # Match is within normal truncation length - use standard truncation
                            $displayMessage = $cleanMessage.Substring(0, [math]::Max(1, $msgTruncateLength)) + "..."
                        }
                        else {
                            # Match extends beyond truncation length - extend to show full match plus context
                            # Add 20 characters of context after the match for readability
                            $extendedLength = [math]::Min($matchEndPosition + 20, $cleanMessage.Length)
                            $displayMessage = $cleanMessage.Substring(0, $extendedLength) + "..."
                            
                            Write-Verbose "Extended message display from $msgTruncateLength to $extendedLength chars to show match"
                        }
                    }
                    else {
                        # No match found in message (matched in XML only) - use standard truncation
                        $displayMessage = $cleanMessage.Substring(0, [math]::Max(1, $msgTruncateLength)) + "..."
                    }
                }
                catch {
                    # Error in dynamic truncation - fall back to standard truncation
                    Write-Verbose "Error in dynamic message truncation: $($_.Exception.Message)"
                    $displayMessage = $cleanMessage.Substring(0, [math]::Max(1, $msgTruncateLength)) + "..."
                }
            }
            else {
                # No search strings - use standard truncation
                $displayMessage = $cleanMessage.Substring(0, [math]::Max(1, $msgTruncateLength)) + "..."
            }

            $formattedTime = Format-DateTimeWithTimeZone -DateTime $logEvent.TimeCreated -TargetTimeZone $targetTimeZone

            # Get formatted XML
            $formattedXml = ""
            try {
                $rawXml = $logEvent.ToXml()
                $formattedXml = Format-EventXml -XmlString $rawXml -TruncateLength $xmlTruncateLength
            }
            catch {
                $formattedXml = "[XML Unavailable]"
            }

            # Check MaxPrint limit before displaying
            if ($MaxPrint -gt 0) {
                $eventOutputSize = 300 + $displayMessage.Length + $logEvent.LogName.Length + $formattedTime.Length + $formattedXml.Length
                if (($Search.Count -gt 0) -and $logEvent.MatchedStrings) {
                    $eventOutputSize += $logEvent.MatchedStrings.Length + 50
                }

                if ($totalOutputChars + $eventOutputSize -gt $MaxPrint) {
                    $remainingEvents = $sortedEvents.Count - $sortedEvents.IndexOf($logEvent)
                    Write-Host ""
                    Write-Host "Output truncated: MaxPrint limit ($MaxPrint chars) reached. $remainingEvents more events available." -ForegroundColor DarkRed
                    break
                }
                $totalOutputChars += $eventOutputSize
            }

            # Display event information
            Write-Host ""
            Write-Host "----------------------------------------" -ForegroundColor Gray
            Write-Host "Time     : " -NoNewline -ForegroundColor Yellow
            Write-Host $formattedTime -ForegroundColor White
            Write-Host "Log Name : " -NoNewline -ForegroundColor Yellow
            Write-Host $logEvent.LogName -ForegroundColor Cyan

            Write-Host "Event ID : " -NoNewline -ForegroundColor Yellow
            Write-Host $logEvent.Id -ForegroundColor White
            
            # Show PID/TID if they exist on the event (helpful for debugging)
            if ($null -ne $logEvent.ProcessId) {
                Write-Host "PID      : " -NoNewline -ForegroundColor Yellow
                Write-Host $logEvent.ProcessId -ForegroundColor White
            }
            if ($null -ne $logEvent.ThreadId) {
                Write-Host "TID      : " -NoNewline -ForegroundColor Yellow
                Write-Host $logEvent.ThreadId -ForegroundColor White
            }
        
            # Always show Match field if Search was specified
            if ($Search.Count -gt 0) {
                Write-Host "Match    : " -NoNewline -ForegroundColor Yellow
                if (![string]::IsNullOrWhiteSpace($logEvent.MatchedStrings)) {
                    Write-Host $logEvent.MatchedStrings -ForegroundColor DarkRed
                }
                else {
                    # This should never happen after unified filtering, but handle gracefully
                    Write-Host "[Match info unavailable - search matched in XML]" -ForegroundColor DarkYellow
                }
            }
        
            # Display message with highlighted search matches
            Write-Host "Message  : " -NoNewline -ForegroundColor Yellow
            if ($Search.Count -gt 0 -and $msgTruncateLength -ne 0) {
                # Use highlighting when search strings are present
                Write-HighlightedMessage -Message $displayMessage -SearchStrings $Search -NormalColor "Green" -HighlightColor "Red"
            }
            else {
                # No search strings or message display disabled - print normally
                Write-Host $displayMessage -ForegroundColor Green
            }

            # Display XML data if enabled and available
            if (($xmlTruncateLength -ne 0) -and (-not [string]::IsNullOrWhiteSpace($formattedXml)) -and ($formattedXml -ne "[No XML Data]")) {
                Write-Host "XML Data : " -NoNewline -ForegroundColor Yellow
                
                if ($Search.Count -gt 0 -and $SearchXML) {
                    # Use highlighting when search strings are present AND SearchXML is enabled
                    Write-Host ""
                    Write-HighlightedXML -XmlText $formattedXml -SearchStrings $Search -NormalColor "Gray" -HighlightColor "Red"
                }
                else {
                    # No search or SearchXML disabled - print normally
                    $xmlLines = $formattedXml -split "`n"
                    if ($xmlLines.Count -eq 1) {
                        Write-Host $formattedXml -ForegroundColor Gray
                    }
                    else {
                        Write-Host ""
                        foreach ($line in $xmlLines) {
                            if ($line.Trim()) {
                                Write-Host "  $line" -ForegroundColor Gray
                            }
                        }
                    }
                }
            }
        }
    }

    # Display MaxEvents warning if limits were hit
    if ($maxEventsHitCount -gt 0 -and -not $Quiet) {
        Write-Host "WARNING: MaxEvents limit ($MaxEvents) was reached on $maxEventsHitCount log(s). Results may be incomplete, adjust using '-MaxEvents' parameter..." -ForegroundColor Yellow
    }

    # Handle aggressive results display and collection
    if ($aggressiveResults.Count -gt 0) {
        # Always collect aggressive results for CSV export
        foreach ($result in $aggressiveResults) {
            $aggressiveResult = New-LogResult -LogEvent $result -TargetTimeZone $targetTimeZone -IsAggressive $true -FilePath $result.FilePath -Match $result.Match
            $script:HuntLogResults += $aggressiveResult
        }

        # Display aggressive results only if not Quiet
        if (-not $Quiet) {
            Write-Host "`n`n----------------------------------------`n"
            Write-Host "[!] Aggressive File System Log Search`n" -ForegroundColor Red
            foreach ($result in $aggressiveResults) {
                Write-Host "----------------------------------------" -ForegroundColor Gray
                Write-Host "File Path        : " -NoNewline -ForegroundColor Yellow
                Write-Host $result.FilePath -ForegroundColor Cyan
                Write-Host "Creation Date    : " -NoNewline -ForegroundColor Yellow
                Write-Host $result.CreationDate.ToString("yyyy-MM-dd HH:mm:ss") -ForegroundColor White
                Write-Host "Last Modified    : " -NoNewline -ForegroundColor Yellow
                Write-Host $result.LastModifiedDate.ToString("yyyy-MM-dd HH:mm:ss") -ForegroundColor White
                Write-Host "Match            : " -NoNewline -ForegroundColor Yellow
                Write-Host $result.Match -ForegroundColor Red
                Write-Host "Text             : " -NoNewline -ForegroundColor Yellow
                # Highlight the matched text in the file content
                if ($Search.Count -gt 0) {
                    Write-HighlightedMessage -Message $result.Text -SearchStrings $Search -NormalColor "Green" -HighlightColor "Red"
                }
                else {
                    Write-Host $result.Text -ForegroundColor Green
                }
            }
        }
    }
    elseif ($PSBoundParameters.ContainsKey('Aggressive') -and -not $Quiet) {
        Write-Host "`n[X] No Filesystem Logs Found" -ForegroundColor Red
    }

    # Handle CSV Export
    if ($PSBoundParameters.ContainsKey('OutputCSV')) {
        try {
            # Determine export path
            $csvPath = ""
            if ([string]::IsNullOrWhiteSpace($OutputCSV)) {
                # Handle switch usage (just -OutputCSV with no value)
                $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
                $hostname = $env:COMPUTERNAME
                $csvFilename = "HuntLogs_${hostname}_${timestamp}.csv"
                $csvPath = Join-Path (Get-Location) $csvFilename
            }
            elseif (Test-Path $OutputCSV -PathType Container) {
                # Directory provided, generate filename
                $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
                $hostname = $env:COMPUTERNAME
                $csvFilename = "HuntLogs_${hostname}_${timestamp}.csv"
                $csvPath = Join-Path $OutputCSV $csvFilename
            }
            elseif ($OutputCSV -match '\.csv$') {
                # Full path with .csv extension
                $csvPath = $OutputCSV
            }
            else {
                # Assume it's a path, add .csv extension
                $csvPath = $OutputCSV + ".csv"
            }
        
            # Validate directory exists
            $csvDir = Split-Path $csvPath -Parent
            if (![string]::IsNullOrWhiteSpace($csvDir) -and !(Test-Path $csvDir)) {
                New-Item -Path $csvDir -ItemType Directory -Force -ErrorAction Stop | Out-Null
            }
        
            # Export data if we have results
            if ($script:HuntLogResults.Count -gt 0) {
                # Sanitize data for CSV export
                $sanitizedResults = @()
                foreach ($result in $script:HuntLogResults) {
                    $sanitizedResult = [PSCustomObject]@{
                        Type             = Format-CSVValue $result.Type
                        FormattedTime    = Format-CSVValue $result.FormattedTime
                        TimeCreated      = Format-CSVValue $result.TimeCreated
                        LogName          = Format-CSVValue $result.LogName
                        EventId          = Format-CSVValue $result.EventId
                        RecordId         = Format-CSVValue $result.RecordId
                        LevelDisplayName = Format-CSVValue $result.LevelDisplayName
                        ProcessId        = Format-CSVValue $result.ProcessId
                        ThreadId         = Format-CSVValue $result.ThreadId
                        UserId           = Format-CSVValue $result.UserId
                        Message          = Format-CSVValue $result.Message
                        MatchedStrings   = Format-CSVValue $result.MatchedStrings
                        Match            = Format-CSVValue $result.Match
                        Text             = Format-CSVValue $result.Text
                        XML              = Format-CSVValue $result.XML
                        FilePath         = Format-CSVValue $result.FilePath
                        FileName         = Format-CSVValue $result.FileName
                        CreationDate     = Format-CSVValue $result.CreationDate
                        LastModifiedDate = Format-CSVValue $result.LastModifiedDate
                        Hostname         = Format-CSVValue $result.Hostname
                    }
                    $sanitizedResults += $sanitizedResult
                }
            
                # Export to CSV
                $sanitizedResults | Export-Csv -Path $csvPath -NoTypeInformation -Encoding UTF8
            
                if (-not $Quiet) {
                    Write-Host "Results exported to CSV: $csvPath" -ForegroundColor Green
                    Write-Host "Total records exported: $($sanitizedResults.Count)" -ForegroundColor Cyan
                }
            }
            else {
                if (-not $Quiet) {
                    Write-Host "No results to export to CSV" -ForegroundColor Yellow
                }
            }
        }
        catch {
            Write-Error "CSV Export Error: $($_.Exception.Message)"
        }
    }
    Write-Progress -Activity "Hunt-Logs" -Completed
    # Summary and filtering info
    if (-not $Quiet) {
        if ((($ExcludeEventId.Count -gt 0) -or ($Exclude.Count -gt 0)) -and ($filteredCount -gt 0)) {
            Write-Host ""
            Write-Host "[INFO]: $filteredCount event logs filtered out by exclude parameters." -ForegroundColor DarkYellow
        }
    }

    # Return objects only if PassThru is specified
    if ($PassThru) {
        if ($script:HuntLogResults.Count -eq 0) {
            if (-not $Quiet) { Write-Verbose "No results to return via PassThru" }
            return @()
        }
        return $script:HuntLogResults
    }

    if (-not $Quiet) {
        Write-Host ""
    }
    Write-Host "`n"
}


function Hunt-Browser {
    [CmdletBinding()]
    <#
.SYNOPSIS
Hunts for browser artifacts, history, and network indicators across user profiles and DNS logs.

.DESCRIPTION
Hunt-Browser is a digital forensics function that extracts and analyzes browser history, cache data, and DNS logs to identify suspicious network activity, malicious URLs, and file system artifacts. It supports multiple browsers including Chrome, Firefox, Edge, and their variants.

Default Mode: Hunt-Browser runs in All mode by default, returning all discovered artifacts. Use -Auto or -Aggressive for pattern-based filtering, or -Search/-Exclude for custom filtering.

Cache Behavior: Once browser history is cached (via LoadTool mode), all subsequent Hunt-Browser commands automatically use the cache for faster searches. The cache persists for the PowerShell session and can be cleared with -ClearCache. Use -LoadTool to refresh cached data or -NoCache to bypass the cache for a single query.

.PARAMETER Auto
Uses predefined suspicious patterns to identify potentially malicious artifacts. Optional mode for filtered detection.

.PARAMETER Aggressive
Expands detection to Search broader patterns that may generate more false positives.

.PARAMETER All
Returns all discovered browser artifacts without filtering (default mode).

.PARAMETER Extensions
Enumerates all installed browser extensions across all browsers and user profiles.
Displays extension metadata including name, version, description, permissions, and installation path.

.PARAMETER LoadTool
Switch to enable LoadTool mode, which uses BrowsingHistoryView tool from NirSoft for comprehensive history extraction.

.PARAMETER LoadToolPath
Optional path to local BrowsingHistoryView.exe. If not specified or invalid, downloads from NirSoft.
Also accepts directory path for CSV output (auto-generates filename) or full path with .csv extension.

.PARAMETER LoadCSVPath
Path to existing BrowsingHistoryView CSV file to load into cache for analysis.
Use this to analyze previously exported browser history without re-running the tool.
Records are cached for subsequent searches with different filters.

.PARAMETER NoCache
Disables caching for this query. Results will not be stored in session cache.
Use when you want one-time analysis without affecting cached data.

.PARAMETER ClearCache
Clears the LoadTool browser history cache and exits.
Use when you want to free memory or force fresh data collection.

.PARAMETER Truncate
Limits the display length of discovered strings to specified number of characters.

.PARAMETER Search
Array of patterns to search for in results (wildcards supported).

.PARAMETER Exclude
Array of patterns to exclude from results (wildcards supported).

.PARAMETER OutputDir
Directory for temporary files (default: $env:TEMP\ForensicHunter\Hunt-Browser).

.PARAMETER OutputCSV
Export results to CSV file. Accepts file path or directory path (auto-generates filename).

.PARAMETER Quiet
Suppresses console output except for errors and critical information.

.PARAMETER PassThru
Returns PowerShell objects for programmatic use instead of displaying results.

.PARAMETER SkipConfirmation
Skips user confirmation prompt when using LoadTool mode.

.PARAMETER StartDate
Start date for filtering browser history (LoadTool mode only).
Accepts formats: datetime string, 'now', 'alltime', or relative format like '7d', '24h', '30m'.
Examples: '2025-10-01', '7d' (last 7 days), '24h' (last 24 hours), 'alltime' (no filter).

.PARAMETER EndDate
End date for filtering browser history (LoadTool mode only). Defaults to 'Now'.
Accepts same formats as StartDate parameter.

.PARAMETER SortOrder
Sort order for LoadTool results display. Valid values: "NewestFirst" (default), "OldestFirst"
Only applies to LoadTool/cached results. Native mode uses its own sorting logic.

.EXAMPLE
Hunt-Browser
Runs in All mode (default), scanning all user profiles and returning all browser artifacts.

.EXAMPLE
Hunt-Browser -All -OutputCSV "C:\Reports\browser_analysis.csv" -Quiet
Extracts all browser artifacts and exports to CSV with minimal console output.

.EXAMPLE
Hunt-Browser -Include "*.evil.com*","*malware*" -Exclude "*google*" -PassThru | Where-Object Count -gt 5
Filters for specific patterns and returns objects for further PowerShell processing.

.EXAMPLE
Hunt-Browser -LoadTool -SkipConfirmation
Downloads and uses BrowsingHistoryView tool to extract comprehensive browser history.

.EXAMPLE
Hunt-Browser -LoadTool -LoadToolPath "C:\Tools\BrowsingHistoryView.exe"
Uses local copy of BrowsingHistoryView.exe to extract browser history.

.EXAMPLE
Hunt-Browser -LoadTool -LoadToolPath "C:\Reports\output.csv" -SkipConfirmation
Downloads tool and saves results to specified CSV file.

.EXAMPLE
Hunt-Browser -LoadCSVPath "C:\Reports\BrowsingHistory.csv" -Search "*.evil.com*"
Loads existing CSV into cache and searches for specific domain pattern.

.EXAMPLE
Hunt-Browser -LoadTool -SkipConfirmation -Search "google"
Runs LoadTool, caches results, then filters for Google-related entries.
Subsequent searches will use cached data.

.EXAMPLE
Hunt-Browser -LoadTool -SkipConfirmation -NoCache
Runs LoadTool without caching results (one-time analysis).

.EXAMPLE
Hunt-Browser -ClearCache
Clears the browser history cache to free memory.

.EXAMPLE
Hunt-Browser -LoadTool -SkipConfirmation
Hunt-Browser -Search "github"
First command caches all browser history. Second command searches the cache without re-running the tool.

.EXAMPLE
Hunt-Browser -LoadTool -StartDate "1h" -SkipConfirmation
Filters browser history from the last 1 hour.

.EXAMPLE
Hunt-Browser -LoadTool -StartDate "24h" -SkipConfirmation
Filters browser history from the last 24 hours.

.EXAMPLE
Hunt-Browser -LoadTool -StartDate "7d" -SkipConfirmation
Filters browser history from the last 7 days.

.EXAMPLE
Hunt-Browser -LoadTool -StartDate "2025-11-02" -EndDate "2025-11-15" -SkipConfirmation
Filters browser history for a specific date range using PowerShell datetime format.

.EXAMPLE
Hunt-Browser -LoadTool -StartDate "2025-11-02 14:30:00" -SkipConfirmation
Filters browser history from a specific datetime.

.EXAMPLE
Hunt-Browser -LoadTool -StartDate "AllTime" -SkipConfirmation
Loads all available browser history (no date filter).

.EXAMPLE
Hunt-Browser -LoadTool -SkipConfirmation -Search "github"
Loads browser history and highlights matches for "github" in URL and Title fields.

.EXAMPLE
Hunt-Browser -Search "google" -SortOrder "OldestFirst"
Searches cached browser history and displays results from oldest to newest.

.EXAMPLE
Hunt-Browser -Extensions
Enumerates all installed browser extensions across all browsers and user profiles.

.EXAMPLE
Hunt-Browser -Extensions -Search "ublock","adblock" -OutputCSV "C:\Reports\extensions.csv"
Searches for specific extensions and exports results to CSV.

.EXAMPLE
Hunt-Browser -Extensions -PassThru | Where-Object Permissions -like "*webRequest*"
Returns extension objects with webRequest permissions for further analysis.

.NOTES
- Requires PowerShell 5.0 or higher
- Administrator privileges recommended for complete system access
- Some browser databases may be locked if browsers are currently running
- LoadTool mode downloads third-party executable from NirSoft
#>
    param(
        [switch]$Auto,
        [switch]$Aggressive,
        [switch]$All,
        [switch]$LoadTool,
        [switch]$Extensions,
        [string]$LoadToolPath = "",
        [string]$LoadCSVPath = "",
        [int]$Truncate = 0,
        [string[]]$Search = @(),
        [string[]]$Exclude = @(),
        [string]$OutputDir = "$env:TEMP\ForensicHunter\Hunt-Browser",
        [string]$OutputCSV,
        [switch]$Quiet,
        [switch]$PassThru,
        [switch]$SkipConfirmation,
        [switch]$NoCache,
        [switch]$ClearCache,
        $StartDate,
        $EndDate = "Now",
        [Parameter(Mandatory = $false)]
        [ValidateSet("OldestFirst", "NewestFirst")]
        [string]$SortOrder = "NewestFirst"
    )
    
    # Ensure script-level pattern arrays exist with fallback defaults
    if ($null -eq $script:suspiciousBrowserStrings) {
        $script:suspiciousBrowserStrings = @()
    }
    if ($null -eq $script:suspiciousTLDs) {
        $script:suspiciousTLDs = @()
    }
    if ($null -eq $script:aggressiveBrowserStrings) {
        $script:aggressiveBrowserStrings = @()
    }
    if ($null -eq $script:PossibleTLDs) {
        $script:PossibleTLDs = @()
    }

    # Initialize global cache if not exists
    if ($null -eq (Get-Variable -Name "HuntBrowserCache_LoadTool" -Scope Global -ErrorAction SilentlyContinue)) {
        $global:HuntBrowserCache_LoadTool = @{
            Enabled        = $true
            LastQueryTime  = $null
            CacheCreatedAt = $null
            Parameters     = @{
                StartDate     = $null
                EndDate       = $null
                SourceCSVPath = ""
                RecordCount   = 0
            }
            RawRecords     = @()  # Array of browser history records
            Statistics     = @{
                TotalRecords  = 0
                CacheHits     = 0
                CacheMisses   = 0
                LastOperation = ""
            }
        }
    }
    
    # Handle ClearCache parameter
    if ($ClearCache) {
        if ($global:HuntBrowserCache_LoadTool.RawRecords.Count -gt 0) {
            Write-Host "Clearing Hunt-Browser LoadTool cache ($($global:HuntBrowserCache_LoadTool.RawRecords.Count) records)..." -ForegroundColor Yellow
        }
        
        $global:HuntBrowserCache_LoadTool = @{
            Enabled        = $true
            LastQueryTime  = $null
            CacheCreatedAt = $null
            Parameters     = @{
                StartDate     = $null
                EndDate       = $null
                SourceCSVPath = ""
                RecordCount   = 0
            }
            RawRecords     = @()
            Statistics     = @{
                TotalRecords  = 0
                CacheHits     = 0
                CacheMisses   = 0
                LastOperation = ""
            }
        }
        
        Write-Host "Hunt-Browser LoadTool cache cleared successfully." -ForegroundColor Green
        return
    }
    
    # Disable cache if NoCache switch is present
    if ($NoCache) {
        $global:HuntBrowserCache_LoadTool.Enabled = $false
        if (-not $Quiet) {
            Write-Verbose "Caching disabled for this query (NoCache switch)"
        }
    }
    else {
        $global:HuntBrowserCache_LoadTool.Enabled = $true
    }

    # Validate output paths early
    if ($OutputCSV) {
        try {
            $testPath = Split-Path $OutputCSV -Parent
            if ($null -ne $testPath -and -not (Test-Path $testPath -ErrorAction SilentlyContinue)) {
                $null = New-Item -Path $testPath -ItemType Directory -Force -ErrorAction Stop
            }
        }
        catch {
            Write-Error "Cannot access output path for CSV: $OutputCSV"
            return
        }
    }

    # Initialize script variables
    $script:AllFilesToCleanup = @()
    $script:CreatedDirectories = @()
    $script:PersistentFiles = @()

    function Test-LoadToolCacheValidity {
        [CmdletBinding()]
        param(
            $RequestedStartDate,
            $RequestedEndDate,
            [string]$RequestedCSVPath
        )
        
        try {
            # Cache must be enabled and have data
            if (-not $global:HuntBrowserCache_LoadTool.Enabled) {
                Write-Verbose "LoadTool cache is disabled"
                return @{ Valid = $false; Reason = "Cache disabled" }
            }
            
            if ($global:HuntBrowserCache_LoadTool.RawRecords.Count -eq 0) {
                Write-Verbose "LoadTool cache is empty"
                return @{ Valid = $false; Reason = "Cache empty" }
            }
            
            # If loading from specific CSV, check if it matches cached source
            if (![string]::IsNullOrWhiteSpace($RequestedCSVPath)) {
                try {
                    $normalizedRequestPath = [System.IO.Path]::GetFullPath($RequestedCSVPath)
                    $cachedPath = $global:HuntBrowserCache_LoadTool.Parameters.SourceCSVPath
                    
                    if ($normalizedRequestPath -ne $cachedPath) {
                        Write-Verbose "Requested CSV path differs from cached source"
                        return @{ Valid = $false; Reason = "Different CSV source"; RequiresFullRefresh = $true }
                    }
                }
                catch {
                    Write-Verbose "Error validating CSV path"
                    return @{ Valid = $false; Reason = "CSV path validation error"; RequiresFullRefresh = $true }
                }
            }
            
            # Check date range compatibility
            $cachedStart = $global:HuntBrowserCache_LoadTool.Parameters.StartDate
            $cachedEnd = $global:HuntBrowserCache_LoadTool.Parameters.EndDate
            
            # If no dates requested (retrieve all), cache must also have all records
            if ($null -eq $RequestedStartDate -and $null -eq $RequestedEndDate) {
                if ($null -eq $cachedStart -and $null -eq $cachedEnd) {
                    Write-Verbose "Cache contains ALL records, matches request for ALL records"
                    return @{
                        Valid     = $true
                        UseCache  = $true
                        FullMatch = $true
                        Reason    = "Full cache hit - all records"
                    }
                }
                else {
                    Write-Verbose "Requesting ALL records but cache has date filters"
                    return @{ Valid = $false; Reason = "Cache filtered, requesting all"; RequiresFullRefresh = $true }
                }
            }
            
            # If cache has all records, it can satisfy any date-filtered request
            if ($null -eq $cachedStart -and $null -eq $cachedEnd) {
                Write-Verbose "Cache has ALL records, can filter for requested date range"
                return @{
                    Valid     = $true
                    UseCache  = $true
                    FullMatch = $true
                    Reason    = "Full cache hit - filtering from all records"
                }
            }
            
            # Both have dates - check if requested range is within cached range
            if ($null -ne $RequestedStartDate -and $null -ne $cachedStart) {
                if ($RequestedStartDate -ge $cachedStart -and 
                    ($null -eq $RequestedEndDate -or $null -eq $cachedEnd -or $RequestedEndDate -le $cachedEnd)) {
                    Write-Verbose "Requested date range within cached range"
                    return @{
                        Valid     = $true
                        UseCache  = $true
                        FullMatch = $true
                        Reason    = "Full cache hit - date range subset"
                    }
                }
            }
            
            # Requested range extends beyond cache
            Write-Verbose "Requested range extends beyond cache"
            return @{ Valid = $false; Reason = "Date range mismatch"; RequiresFullRefresh = $true }
            
        }
        catch {
            Write-Verbose "Error validating LoadTool cache: $($_.Exception.Message)"
            return @{ Valid = $false; Reason = "Cache validation error"; RequiresFullRefresh = $true }
        }
    }
    
    function Get-FilteredCachedBrowserRecords {
        [CmdletBinding()]
        param(
            $StartDate,
            $EndDate,
            [string[]]$Search,
            [string[]]$Exclude,
            [switch]$Quiet
        )
        
        try {
            $filtered = [System.Collections.Generic.List[PSObject]]::new()
            
            foreach ($record in $global:HuntBrowserCache_LoadTool.RawRecords) {
                # Filter by date range if specified
                if ($null -ne $StartDate -or $null -ne $EndDate) {
                    try {
                        # Parse the VisitTime from the cached record
                        $visitTimeStr = $record.'Visit Time'
                        if (![string]::IsNullOrWhiteSpace($visitTimeStr)) {
                            # Handle various date formats: "1/5/2025 7:14:32 PM", "2025-11-02", etc.
                            $visitTime = $null
                            try {
                                $visitTime = [datetime]::Parse($visitTimeStr)
                            }
                            catch {
                                # Try parsing with explicit format if standard parse fails
                                try {
                                    $visitTime = [datetime]::ParseExact($visitTimeStr, @('M/d/yyyy h:mm:ss tt', 'yyyy-MM-dd HH:mm:ss', 'yyyy-MM-dd', 'M/d/yyyy'), $null, [System.Globalization.DateTimeStyles]::None)
                                }
                                catch {
                                    Write-Verbose "Could not parse visit time: $visitTimeStr"
                                    continue
                                }
                            }
                            
                            if ($null -ne $visitTime) {
                                if ($null -ne $StartDate -and $visitTime -lt $StartDate) {
                                    continue
                                }
                                if ($null -ne $EndDate -and $visitTime -gt $EndDate) {
                                    continue
                                }
                            }
                        }
                    }
                    catch {
                        Write-Verbose "Error filtering by date for record: $($_.Exception.Message)"
                    }
                }
                
                # Filter by Search patterns
                if ($Search.Count -gt 0) {
                    $matchFound = $false
                    $url = $record.URL
                    $title = $record.Title
                    
                    foreach ($pattern in $Search) {
                        if ([string]::IsNullOrWhiteSpace($pattern)) { continue }
                        
                        if ($url -like "*$pattern*" -or $title -like "*$pattern*") {
                            $matchFound = $true
                            break
                        }
                    }
                    
                    if (-not $matchFound) { continue }
                }
                
                # Filter by Exclude patterns
                if ($Exclude.Count -gt 0) {
                    $excluded = $false
                    $url = $record.URL
                    $title = $record.Title
                    
                    foreach ($pattern in $Exclude) {
                        if ([string]::IsNullOrWhiteSpace($pattern)) { continue }
                        
                        if ($url -like "*$pattern*" -or $title -like "*$pattern*") {
                            $excluded = $true
                            break
                        }
                    }
                    
                    if ($excluded) { continue }
                }
                
                # Record passed all filters
                $filtered.Add($record)
            }
            
            if (-not $Quiet) {
                Write-Verbose "Filtered cache: $($filtered.Count) of $($global:HuntBrowserCache_LoadTool.RawRecords.Count) records match query"
            }
            
            return $filtered
        }
        catch {
            Write-Warning "Error filtering cached browser records: $($_.Exception.Message)"
            return [System.Collections.Generic.List[PSObject]]::new()
        }
    }
    
    function Add-RecordsToLoadToolCache {
        [CmdletBinding()]
        param(
            [array]$NewRecords,
            $StartDate,
            $EndDate,
            [string]$SourceCSVPath
        )
        
        try {
            # Replace cache contents entirely (LoadTool always provides complete dataset)
            $global:HuntBrowserCache_LoadTool.RawRecords = $NewRecords
            $global:HuntBrowserCache_LoadTool.Parameters.StartDate = $StartDate
            $global:HuntBrowserCache_LoadTool.Parameters.EndDate = $EndDate
            $global:HuntBrowserCache_LoadTool.Parameters.SourceCSVPath = $SourceCSVPath
            $global:HuntBrowserCache_LoadTool.Parameters.RecordCount = $NewRecords.Count
            $global:HuntBrowserCache_LoadTool.Statistics.TotalRecords = $NewRecords.Count
            $global:HuntBrowserCache_LoadTool.LastQueryTime = Get-Date
            
            if ($null -eq $global:HuntBrowserCache_LoadTool.CacheCreatedAt) {
                $global:HuntBrowserCache_LoadTool.CacheCreatedAt = Get-Date
            }
            
            Write-Verbose "LoadTool cache updated: $($NewRecords.Count) records"
            
            return $NewRecords.Count
        }
        catch {
            Write-Warning "Error updating LoadTool cache: $($_.Exception.Message)"
            return 0
        }
    }


    function ConvertTo-DateTime {
        param($InputValue)
    
        if ($InputValue -is [datetime]) {
            return $InputValue
        }
    
        if ($InputValue -is [string]) {
            $InputValue = $InputValue.Trim()
        
            if ($InputValue.ToLower() -eq 'now') {
                return Get-Date
            }
            
            if ($InputValue.ToLower() -eq 'alltime' -or $InputValue.ToLower() -eq 'all') {
                return [datetime]::new(1970, 1, 1)
            }
        
            # Case-insensitive regex for relative dates
            if ($InputValue -match '^(\d+)([DHMdhm])$') {
                $number = [int]$matches[1]
                $unit = $matches[2].ToUpper()
            
                $currentTime = Get-Date
                switch ($unit) {
                    'D' { return $currentTime.AddDays(-$number) }
                    'H' { return $currentTime.AddHours(-$number) }
                    'M' { return $currentTime.AddMinutes(-$number) }
                }
            }
            else {
                try {
                    # Try standard PowerShell datetime parsing
                    return [datetime]::Parse($InputValue)
                }
                catch {
                    throw "Invalid date format: $InputValue. Use datetime (e.g., '2025-11-02', '2025-11-02 14:30'), 'now', 'alltime', or relative format like '7d', '24h', '30m'"
                }
            }
        }
        
        # Default to all time if null or empty
        return [datetime]::new(1970, 1, 1)
    }


    function Sanitize-SearchPattern {
        param([string]$Pattern)
    
        if ([string]::IsNullOrWhiteSpace($Pattern)) { return "" }
    
        # Remove potentially dangerous characters
        $sanitized = $Pattern -replace '[`$();{}|&<>]', ''
        return $sanitized.Trim()
    }

    function Resolve-SafePath {
        param(
            [string]$Path,
            [string]$DefaultPath,
            [switch]$AllowNew,
            [string]$Extension
        )
    
        if ([string]::IsNullOrWhiteSpace($Path)) {
            return $DefaultPath
        }
    
        try {
            # Prevent path traversal
            $normalizedPath = [System.IO.Path]::GetFullPath($Path)
        
            # Basic validation - ensure it's within reasonable system paths
            if ($normalizedPath -notmatch '^[A-Za-z]:\\' -and $normalizedPath -notmatch '^\\\\[^\\]+\\[^\\]+') {
                throw "Invalid path format"
            }
        
            # Check for suspicious patterns
            if ($normalizedPath -match '\.\.' -or $normalizedPath -match '[<>"|?*]') {
                throw "Path contains invalid characters"
            }
        
            # Add extension if specified
            if ($Extension -and -not $normalizedPath.EndsWith($Extension, [StringComparison]::OrdinalIgnoreCase)) {
                $normalizedPath += $Extension
            }
        
            # For new files, ensure parent directory is valid
            if ($AllowNew) {
                $parentDir = Split-Path $normalizedPath -Parent
                if ($parentDir -and -not (Test-Path $parentDir -ErrorAction SilentlyContinue)) {
                    # Don't create here, just validate the path structure is reasonable
                    if ($parentDir.Length -lt 3 -or $parentDir.Length -gt 248) {
                        throw "Invalid parent directory path length"
                    }
                }
            }
        
            return $normalizedPath
        }
        catch {
            return $DefaultPath
        }
    }

    function Sanitize-Output {
        param($Value)

        # CRITICAL: Never use $Input as parameter name - it's a reserved automatic variable!
        
        # Handle null or empty values gracefully
        if ($null -eq $Value -or $Value -eq '') {
            return ''
        }
        
        # Convert to string safely
        $stringValue = $Value.ToString()    
        # Only remove characters that break CSV/Excel files
        $sanitized = $stringValue -replace '[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]', ''  # Control characters
        $sanitized = $sanitized -replace '"', '""'  # Escape double quotes for CSV    
        $sanitized = $sanitized.Trim()
        # Limit length to prevent memory issues
        if ($sanitized.Length -gt 32767) {
            $sanitized = $sanitized.Substring(0, 32767) + "...[TRUNCATED]"
            Write-Verbose "[DEBUG] Truncated to 32767 chars"
        }
    
        return $sanitized
    }

    function Export-ResultsToCSV {
        param(
            [array]$Results,
            [string]$Path,
            [switch]$Quiet
        )
    
        if ($null -eq $Results -or $Results.Count -eq 0) {
            if (-not $Quiet) {
                Write-Host "[CSV] No results to export" -ForegroundColor Yellow
            }
            return
        }
    
        try {
            # Handle directory vs file path
            if (Test-Path $Path -PathType Container -ErrorAction SilentlyContinue) {
                $timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
                $Path = Join-Path $Path "Hunt-Browser-Results-$timestamp.csv"
            }
        
            # Ensure the parent directory exists
            $parentDir = Split-Path $Path -Parent
            if ($null -ne $parentDir -and -not (Test-Path $parentDir -ErrorAction SilentlyContinue)) {
                New-Item -Path $parentDir -ItemType Directory -Force -ErrorAction Stop | Out-Null
                if (-not $Quiet) {
                    Write-Host "[CSV] Created directory: $parentDir" -ForegroundColor Green
                }
            }
        
            # CRITICAL: Use regular foreach loop instead of pipeline to prevent enumeration corruption
            $csvData = [System.Collections.ArrayList]::new($Results.Count)
        
            # Excel-safe sanitization function (defined once, outside loop)
            $sanitizeForExcel = {
                param($value)
                if ($null -eq $value) { return "" }
            
                $stringValue = $value.ToString()
                # Escape leading = to prevent formula injection
                if ($stringValue.StartsWith("=")) {
                    $stringValue = "'" + $stringValue
                }
                # Remove or escape other formula triggers
                $stringValue = $stringValue -replace '^[@+\-]', "'$&"
                # Remove control characters but preserve newlines as spaces
                $stringValue = $stringValue -replace '[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]', ''
                # Escape double quotes for CSV
                $stringValue = $stringValue -replace '"', '""'
                # Limit length to Excel's cell limit
                if ($stringValue.Length -gt 32767) {
                    $stringValue = $stringValue.Substring(0, 32764) + "..."
                }
                return $stringValue
            }
        
            # Use regular foreach to avoid pipeline enumeration corruption
            foreach ($result in $Results) {
                $csvRow = [PSCustomObject]@{
                    Timestamp    = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                    Hostname     = & $sanitizeForExcel $result.Hostname
                    User         = & $sanitizeForExcel $result.User
                    Source       = & $sanitizeForExcel $result.Source
                    Browser      = & $sanitizeForExcel $result.Browser
                    String       = & $sanitizeForExcel $result.String
                    FullString   = & $sanitizeForExcel $result.FullString
                    MatchPattern = & $sanitizeForExcel $result.MatchPattern
                    Length       = $result.Length
                    Count        = if ($null -ne $result.Count) { $result.Count } else { 1 }
                    Title        = if ($null -ne $result.Title) { & $sanitizeForExcel $result.Title } else { "" }
                    VisitTime    = if ($null -ne $result.VisitTime) { & $sanitizeForExcel $result.VisitTime } else { "" }
                }
            
                [void]$csvData.Add($csvRow)
            }                
            $csvData | Export-Csv -Path $Path -NoTypeInformation -Encoding UTF8 -ErrorAction Stop
        
            if (-not $Quiet) {
                Write-Host "[CSV] Exported $($Results.Count) results to: $Path" -ForegroundColor Green
            }
        }
        catch {
            Write-Error "Failed to export CSV: $($_.Exception.Message)"
        }
    }
    function Process-BrowserData {
        param(
            [string]$UserProfile,
            [string]$UserName,
            [hashtable]$Browser,
            [string]$OutputDir,
            [string]$Timestamp,
            [string]$Hostname,
            [string]$EffectiveMode,
            [string[]]$Search,
            [string[]]$Exclude,
            [int]$Truncate,
            [switch]$Quiet
        )
    
        $results = @()
    
        try {
            if (-not (Test-Path $UserProfile -PathType Container -ErrorAction SilentlyContinue)) {
                return @()
            }
        
            # Determine base paths based on browser type
            $searchPaths = @()
        
            if ($Browser.Type -eq "Firefox") {
                $firefoxBase = Join-Path $UserProfile "AppData\Roaming\Mozilla\Firefox\Profiles"
                if (Test-Path $firefoxBase -ErrorAction SilentlyContinue) {
                    $profileDirs = Get-ChildItem $firefoxBase -Directory -ErrorAction SilentlyContinue
                    foreach ($profileDir in $profileDirs) {
                        $placesPath = Join-Path $profileDir.FullName "places.sqlite"
                        if (Test-Path $placesPath -ErrorAction SilentlyContinue) {
                            $searchPaths += $placesPath
                        }
                    }
                }
            
                # Check other Firefox variants
                $otherFirefoxPaths = @(
                    "AppData\Roaming\Waterfox\Profiles",
                    "AppData\Roaming\Moonchild Productions\Pale Moon\Profiles",
                    "AppData\Roaming\Mozilla\SeaMonkey\Profiles"
                )
            
                foreach ($ffPath in $otherFirefoxPaths) {
                    $fullPath = Join-Path $UserProfile $ffPath
                    if (Test-Path $fullPath -ErrorAction SilentlyContinue) {
                        $profileDirs = Get-ChildItem $fullPath -Directory -ErrorAction SilentlyContinue
                        foreach ($profileDir in $profileDirs) {
                            $placesPath = Join-Path $profileDir.FullName "places.sqlite"
                            if (Test-Path $placesPath -ErrorAction SilentlyContinue) {
                                $searchPaths += $placesPath
                            }
                        }
                    }
                }
            }
            else {
                # Chromium-based browsers
                $basePath = Join-Path $UserProfile "AppData\Local$($Browser.Path)"
                if (Test-Path $basePath -ErrorAction SilentlyContinue) {
                    $searchPaths += $basePath
                }
            
                # Check for multiple profiles in Chromium browsers
                $profilesDir = Split-Path $basePath -Parent
                if (Test-Path $profilesDir -ErrorAction SilentlyContinue) {
                    $profileDirs = Get-ChildItem $profilesDir -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match "^(Default|Profile \d+)$" }
                    foreach ($profileDir in $profileDirs) {
                        $historyPath = Join-Path $profileDir.FullName "History"
                        if (Test-Path $historyPath -ErrorAction SilentlyContinue) {
                            $searchPaths += $historyPath
                        }
                    }
                }
            }
        
            # Process all found paths
            foreach ($filePath in $searchPaths) {
                try {
                    if (Test-Path $filePath -ErrorAction SilentlyContinue) {
                        $fileResults = Process-SingleBrowserFile -FilePath $filePath -BrowserName $Browser.Name -UserName $UserName -OutputDir $OutputDir -Timestamp $Timestamp -EffectiveMode $EffectiveMode -Include $Search -Exclude $Exclude -Truncate $Truncate -Hostname $Hostname -Quiet:$Quiet
                        if ($fileResults) {
                            $results += $fileResults
                        }
                    }
                }
                catch { 
                    if (-not $Quiet) {
                        Write-Warning "Failed to process $filePath`: $($_.Exception.Message)"
                    }
                    continue 
                }
            }
        }
        catch { }
    
        return $results
    }

    function Process-SingleBrowserFile {
        param(
            [string]$FilePath,
            [string]$BrowserName,
            [string]$UserName,
            [string]$OutputDir,
            [string]$Timestamp,
            [string]$Hostname,
            [string]$EffectiveMode,
            [string[]]$Search,
            [string[]]$Exclude,
            [int]$Truncate,
            [switch]$Quiet
        )
    
        # Validate file path
        try {
            $FilePath = [System.IO.Path]::GetFullPath($FilePath)
        }
        catch {
            return @()
        }
    
        if (-not (Test-Path $FilePath -ErrorAction SilentlyContinue)) {
            if (-not $Quiet) {
                # Write-Host "[DEBUG] File not found: $FilePath" -ForegroundColor Red
            }
            return @()
        }
    
        if (-not $Quiet) {
            # Write-Host "[DEBUG] Processing file: $FilePath" -ForegroundColor Green
        }
    
        # Check file size to prevent memory issues
        try {
            $fileInfo = Get-Item $FilePath -ErrorAction Stop
            if (-not $Quiet) {
                # Write-Host "[DEBUG] File size: $([math]::Round($fileInfo.Length / 1MB, 2)) MB" -ForegroundColor Cyan
            }
        
            if ($fileInfo.Length -gt 100MB) {
                if (-not $Quiet) {
                    Write-Warning "Skipping large file (>100MB): $FilePath"
                }
                return @()
            }
        
            if ($fileInfo.Length -eq 0) {
                if (-not $Quiet) {
                    # Write-Host "[DEBUG] Empty file, skipping: $FilePath" -ForegroundColor Yellow
                }
                return @()
            }
        }
        catch {
            return @()
        }
    
        try {
            # Create temporary copy for processing
            $tempFile = Join-Path $env:TEMP "browser_temp_$([guid]::NewGuid())"
            try {
                Copy-Item $FilePath $tempFile -Force -ErrorAction Stop
                $script:AllFilesToCleanup += $tempFile
                $sourceFile = $tempFile
            }
            catch {
                return @()
            }
        
            # Extract and filter strings

            try {
                if (-not $Quiet) {
                    # Write-Host "[DEBUG] Extracting strings from: $sourceFile" -ForegroundColor Magenta
        
                    # Check if file is readable
                    $testBytes = [System.IO.File]::ReadAllBytes($sourceFile)
                    # Write-Host "[DEBUG] Successfully read $($testBytes.Length) bytes" -ForegroundColor Cyan
        
                    # Show first 100 bytes as hex to see if it's a valid file
                    $hexSample = ($testBytes[0..99] | ForEach-Object { $_.ToString("X2") }) -join " "
                    # Write-Host "[DEBUG] First 100 bytes (hex): $($hexSample.Substring(0, [Math]::Min(50, $hexSample.Length)))..." -ForegroundColor Gray
                }
    
                $strings = Extract-CleanStrings -FilePath $sourceFile
    
                if (-not $Quiet) {
                    # Write-Host "[DEBUG] Extracted $($strings.Count) raw strings" -ForegroundColor Cyan
                    if ($strings.Count -gt 0) {
                        # Write-Host "[DEBUG] Sample strings:" -ForegroundColor Yellow
                        #$strings[0..4] | ForEach-Object { Write-Host "  - $_" -ForegroundColor White }
                    }
                }
    
                if ($strings) {
                    $filtered = Filter-Strings -Strings $strings -UserName $UserName -BrowserName $BrowserName -EffectiveMode $EffectiveMode -Include $Search -Exclude $Exclude -Truncate $Truncate -Source "Browser" -Hostname $Hostname
        
                    if (-not $Quiet) {
                        # Write-Host "[DEBUG] Filtered to $($filtered.Count) matching strings" -ForegroundColor Green
                    }
        
                    return $filtered
                }
            }
            catch {
                if (-not $Quiet) {
                    # Write-Host "[DEBUG] String extraction failed: $($_.Exception.Message)" -ForegroundColor Red
                }
            }
        
        }
        catch {
            if (-not $Quiet) {
                # Write-Host "[DEBUG] Processing failed: $($_.Exception.Message)" -ForegroundColor Red
            }
        }
    
        return @()
    }

    function Extract-CleanStrings {
        param([string]$FilePath)
    
        try {
            # Read file as bytes
            $bytes = [System.IO.File]::ReadAllBytes($FilePath)
            if (-not $bytes -or $bytes.Length -eq 0) { return @() }
    
            # Convert to string and find printable ASCII strings
            $content = [System.Text.Encoding]::ASCII.GetString($bytes)
            if (-not $content) { return @() }
        
            # Use a simpler regex to find strings of printable characters
            $stringMatches = [regex]::Matches($content, '[ -~]{4,1000}')
        
            $cleanedStrings = @()
            $seen = @{}
        
            foreach ($match in $stringMatches) {
                $rawString = $match.Value.Trim()
                if ($rawString.Length -ge 4 -and -not $seen.ContainsKey($rawString)) {
                    $seen[$rawString] = $true
                
                    # Basic cleaning
                    $cleanString = $rawString -replace '[\x00-\x1F\x7F]+', ' '
                    $cleanString = $cleanString.Trim()
                    if ([string]::IsNullOrWhiteSpace($cleanString)) { continue }

                
                    if ($cleanString.Length -ge 4) {
                        $cleanedStrings += $cleanString
                    }
                }
            
                # Limit to prevent memory issues
                if ($cleanedStrings.Count -gt 5000) {
                    break
                }
            }
        
            return $cleanedStrings
        }
        catch {
            return @()
        }
    }

    function Filter-Strings {
        param(
            [array]$Strings,
            [string]$UserName,
            [string]$BrowserName,
            [string]$EffectiveMode,
            [string[]]$Search,
            [string[]]$Exclude,
            [int]$Truncate,
            [string]$Source = "Browser",
            [string]$Hostname
        )
    
        $results = @()
        
        if (-not $Strings -or $Strings.Count -eq 0) {
            return @()
        }

        foreach ($string in $Strings) {
            try {
                $match = $null
                $shouldInclude = $false
            
                # Apply Search/Exclude filters first if they exist
                if ($null -ne $Search -and $Search.Count -gt 0) {
                    $shouldInclude = $false
                    foreach ($includePattern in $Search) {
                        try {
                            if ($string -like "*$includePattern*") {
                                $shouldInclude = $true
                                $match = $includePattern
                                break
                            }
                        }
                        catch { continue }
                    }
                    # If we have search filters but nothing matched, skip this string
                    if (-not $shouldInclude) {
                        continue
                    }
                }
                else {
                    # No search filters, so include by default
                    $shouldInclude = $true
                }
            
                # Apply exclude filters
                if ($shouldInclude -and $Exclude.Count -gt 0) {
                    foreach ($excludePattern in $Exclude) {
                        try {
                            if ($string -like "*$excludePattern*") {
                                $shouldInclude = $false
                                break
                            }
                        }
                        catch { continue }
                    }
                }
            
                # If we failed search/exclude filters, skip
                if (-not $shouldInclude) {
                    continue
                }
            
                # Test for network indicators (always flag IPs and URLs)
                if (-not $match) {
                    try {
                        $networkIndicator = Test-NetworkIndicators -InputString $string
                        if ($networkIndicator) {
                            $match = "Network Indicator"
                        }
                    }
                    catch { }
                }
            
                # Test for filesystem paths (always flag)
                if (-not $match) {
                    try {
                        $filesystemPath = Test-FilesystemPaths -InputString $string
                        if ($filesystemPath) {
                            $match = "Filesystem Path"
                        }
                    }
                    catch { }
                }
            
                # Apply mode-based filtering
                if (-not $match) {
                    switch ($EffectiveMode) {
                        "All" {
                            # In All mode, Search everything that passed Search/exclude filters
                            $match = "All strings mode"
                        }
                        "Auto" {
                            # Check suspicious strings
                            foreach ($pattern in $script:suspiciousBrowserStrings) {
                                try {
                                    if ($string -like "*$pattern*") {
                                        $match = "[SUS_STRING] $pattern"
                                        break
                                    }
                                }
                                catch { continue }
                            }
                            # Check suspicious TLDs
                            if (-not $match) {
                                foreach ($tld in $script:suspiciousTLDs) {
                                    try {
                                        if ($string -like "*$tld*") {
                                            $match = "[SUS_TLD] $tld"
                                            break
                                        }
                                    }
                                    catch { continue }
                                }
                            }
                        }
                        "Aggressive" {
                            # Check aggressive strings first
                            foreach ($pattern in $script:aggressiveBrowserStrings) {
                                try {
                                    if ($string -like "*$pattern*") {
                                        $match = "[AGG_STRING] $pattern"
                                        break
                                    }
                                }
                                catch { continue }
                            }
                            # Also check Auto mode patterns if no aggressive match
                            if (-not $match) {
                                foreach ($pattern in $script:suspiciousBrowserStrings) {
                                    try {
                                        if ($string -like "*$pattern*") {
                                            $match = "[SUS_STRING] $pattern"
                                            break
                                        }
                                    }
                                    catch { continue }
                                }
                            }
                            # Check suspicious TLDs
                            if (-not $match) {
                                foreach ($tld in $script:suspiciousTLDs) {
                                    try {
                                        if ($string -like "*$tld*") {
                                            $match = "[SUS_TLD] $tld"
                                            break
                                        }
                                    }
                                    catch { continue }
                                }
                            }
                        }
                    }
                }
            
                # If we have a match, add the result
                if ($match) {
                    try {
                        $displayString = $string
                        if ($Truncate -gt 0 -and $string.Length -gt $Truncate) {
                            $displayString = $string.Substring(0, $Truncate) + "..."
                        }
                    
                        $results += [PSCustomObject]@{
                            User         = $UserName
                            Browser      = $BrowserName
                            String       = $displayString
                            FullString   = $string
                            MatchPattern = $match
                            Length       = $string.Length
                            Source       = $Source
                            Hostname     = $Hostname
                        }
                    }
                    catch {
                        continue
                    }
                }
            }
            catch {
                continue
            }
        }
    
        return $results
    }

    function Process-DNSLogs {
        param(
            [string]$EffectiveMode,
            [string[]]$Search,
            [string[]]$Exclude,
            [int]$Truncate,
            [string]$Hostname,
            [switch]$Quiet
        )
    
        $results = @()
        $dnsLogPaths = @(
            "$env:SystemRoot\System32\dns\dns.log",
            "$env:SystemRoot\System32\LogFiles\dns\dns.log",
            "$env:SystemRoot\System32\winevt\Logs\Microsoft-Windows-DNS-Client%4Operational.evtx"
        )
    
        foreach ($logPath in $dnsLogPaths) {
            try {
                # Validate path
                try {
                    $logPath = [System.IO.Path]::GetFullPath($logPath)
                }
                catch {
                    continue
                }
            
                if (Test-Path $logPath -ErrorAction SilentlyContinue) {
                    if (-not $Quiet) {
                        Write-Host "[DNS] Processing: $logPath" -ForegroundColor Cyan
                    }
                
                    if ($logPath -like "*.evtx") {
                        try {
                            $events = Get-WinEvent -Path $logPath -ErrorAction Stop | 
                            Where-Object { $_.Id -eq 3008 -or $_.Id -eq 3010 } | 
                            Select-Object -First 1000
                        
                            foreach ($event in $events) {
                                try {
                                    $dnsStrings = @(Sanitize-Output $event.Message)
                                    $filteredResults = Filter-Strings -Strings $dnsStrings -UserName "System" -BrowserName "DNS" -EffectiveMode $EffectiveMode -Include $Search -Exclude $Exclude -Truncate $Truncate -Source "DNS" -Hostname $Hostname
                                    if ($filteredResults) {
                                        $results += $filteredResults
                                    }
                                }
                                catch { continue }
                            }
                        }
                        catch { }
                    }
                    else {
                        try {
                            $dnsStrings = Get-Content $logPath -ErrorAction Stop | 
                            Select-Object -First 1000 | 
                            ForEach-Object { Sanitize-Output $_ }
                        
                            $filteredResults = Filter-Strings -Strings $dnsStrings -UserName "System" -BrowserName "DNS" -EffectiveMode $EffectiveMode -Include $Search -Exclude $Exclude -Truncate $Truncate -Source "DNS" -Hostname $Hostname
                            if ($filteredResults) {
                                $results += $filteredResults
                            }
                        }
                        catch { }
                    }
                }
            }
            catch { }
        }
    
        return $results
    }

    function Invoke-LoadToolMode {
        param(
            [string]$OutputPath,
            [string]$Hostname,
            [string]$ExePath,
            [string]$LoadCSVPath,
            [switch]$Quiet,
            [switch]$SkipConfirmation,
            [switch]$NoCache,
            $StartDate,
            $EndDate,
            [string[]]$Search,
            [string[]]$Exclude,
            [string]$EffectiveMode = "All"
        )

        
        # ============================================================================
        # HANDLE LOADCSVPATH - Load existing CSV into cache
        # ============================================================================
        
        if (![string]::IsNullOrWhiteSpace($LoadCSVPath)) {
            try {
                $csvPath = [System.IO.Path]::GetFullPath($LoadCSVPath)
                
                if (-not (Test-Path $csvPath -PathType Leaf)) {
                    Write-Error "LoadCSVPath file not found: $csvPath"
                    return @()
                }
                
                if (-not $Quiet) {
                    Write-Host "[LOADCSV] Loading existing CSV from: $csvPath" -ForegroundColor Cyan
                }
                
                # Import CSV
                $csvData = Import-Csv $csvPath -ErrorAction Stop
                
                if (-not $Quiet) {
                    Write-Host "[LOADCSV] Imported $($csvData.Count) records from CSV" -ForegroundColor Green
                }
                
                # Parse dates if provided (for cache metadata)
                $parsedStartDate = if ($null -ne $StartDate -and $StartDate -ne '') { 
                    ConvertTo-DateTime -InputValue $StartDate 
                }
                else { $null }
                
                $parsedEndDate = if ($null -ne $EndDate -and $EndDate -ne '') { 
                    ConvertTo-DateTime -InputValue $EndDate 
                }
                else { $null }
                
                # Add to cache if caching is enabled
                if (-not $NoCache -and $global:HuntBrowserCache_LoadTool.Enabled) {
                    Add-RecordsToLoadToolCache -NewRecords $csvData -StartDate $parsedStartDate -EndDate $parsedEndDate -SourceCSVPath $csvPath
                    
                    if (-not $Quiet) {
                        Write-Host "[CACHE] Loaded $($csvData.Count) records into cache from CSV" -ForegroundColor Green
                    }
                    
                    $global:HuntBrowserCache_LoadTool.Statistics.CacheMisses++
                    $global:HuntBrowserCache_LoadTool.Statistics.LastOperation = "Loaded from CSV file"
                }
                
                # Now filter the records
                $filteredRecords = if ($NoCache) {
                    # Manual filtering without cache
                    $csvData | Where-Object {
                        $record = $_
                        $include = $true
                        
                        # Date filtering
                        if ($null -ne $parsedStartDate -or $null -ne $parsedEndDate) {
                            try {
                                $visitTime = [datetime]::Parse($record.'Visit Time')
                                if ($null -ne $parsedStartDate -and $visitTime -lt $parsedStartDate) { $include = $false }
                                if ($null -ne $parsedEndDate -and $visitTime -gt $parsedEndDate) { $include = $false }
                            }
                            catch { }
                        }
                        
                        # Search filtering
                        if ($include -and $Search.Count -gt 0) {
                            $matchFound = $false
                            foreach ($pattern in $Search) {
                                if ($record.URL -like "*$pattern*" -or $record.Title -like "*$pattern*") {
                                    $matchFound = $true
                                    break
                                }
                            }
                            if (-not $matchFound) { $include = $false }
                        }
                        
                        # Exclude filtering
                        if ($include -and $Exclude.Count -gt 0) {
                            foreach ($pattern in $Exclude) {
                                if ($record.URL -like "*$pattern*" -or $record.Title -like "*$pattern*") {
                                    $include = $false
                                    break
                                }
                            }
                        }
                        
                        $include
                    }
                }
                else {
                    # Use cache filtering
                    Get-FilteredCachedBrowserRecords -StartDate $parsedStartDate -EndDate $parsedEndDate -Search $Search -Exclude $Exclude -Quiet:$Quiet
                }
                
                # Convert to result objects
                $results = [System.Collections.Generic.List[PSObject]]::new()
                $currentUser = if ($env:USERNAME) { $env:USERNAME } else { "Unknown" }
                
                foreach ($row in $filteredRecords) {
                    try {
                        # Apply mode-based pattern matching to LoadCSV results
                        $matchPattern = "LoadCSV"
                        $url = $row.URL
                        $title = $row.Title
                        
                        if (![string]::IsNullOrWhiteSpace($url) -or ![string]::IsNullOrWhiteSpace($title)) {
                            $testString = "$url $title"
                            
                            # Check suspicious patterns based on mode
                            if ($EffectiveMode -eq "Auto" -or $EffectiveMode -eq "Aggressive") {
                                # Check suspicious strings
                                foreach ($pattern in $script:suspiciousBrowserStrings) {
                                    try {
                                        if ($testString -like "*$pattern*") {
                                            $matchPattern = "[SUS_STRING] $pattern"
                                            break
                                        }
                                    }
                                    catch { continue }
                                }
                                
                                # Check suspicious TLDs if no match yet
                                if ($matchPattern -eq "LoadCSV") {
                                    foreach ($tld in $script:suspiciousTLDs) {
                                        try {
                                            if ($testString -like "*$tld*") {
                                                $matchPattern = "[SUS_TLD] $tld"
                                                break
                                            }
                                        }
                                        catch { continue }
                                    }
                                }
                                
                                # Check aggressive patterns if in Aggressive mode
                                if ($EffectiveMode -eq "Aggressive" -and $matchPattern -eq "LoadCSV") {
                                    foreach ($pattern in $script:aggressiveBrowserStrings) {
                                        try {
                                            if ($testString -like "*$pattern*") {
                                                $matchPattern = "[AGG_STRING] $pattern"
                                                break
                                            }
                                        }
                                        catch { continue }
                                    }
                                }
                            }
                            
                            # Skip network indicators for LoadCSV mode (only use pattern lists)
                        }
                        
                        $resultObj = [PSCustomObject]@{
                            User         = Sanitize-Output $currentUser
                            Browser      = Sanitize-Output ($row.'Web Browser')
                            String       = Sanitize-Output ($row.URL)
                            FullString   = Sanitize-Output ($row.URL)
                            MatchPattern = $matchPattern
                            Length       = if ($row.URL) { ($row.URL -replace '[^\w]', '').Length } else { 0 }
                            Source       = "LoadCSV"
                            Hostname     = Sanitize-Output $Hostname
                            Count        = 1
                            Title        = Sanitize-Output ($row.Title)
                            VisitTime    = Sanitize-Output ($row.'Visit Time')
                        }
                        $results.Add($resultObj)
                    }
                    catch {
                        Write-Warning "Failed to process CSV row: $($_.Exception.Message)"
                        continue
                    }
                }
                
                if (-not $Quiet) {
                    Write-Host "[SUCCESS] Processed $($results.Count) records from CSV" -ForegroundColor Green
                }
                
                return $results
            }
            catch {
                Write-Error "Failed to load CSV: $($_.Exception.Message)"
                return @()
            }
        }
        
        # ============================================================================
        # CHECK CACHE BEFORE RUNNING TOOL
        # ============================================================================
        
        $parsedStartDate = $null
        $parsedEndDate = $null
        
        # Parse dates for cache validation and tool execution
        if ($null -ne $StartDate -and $StartDate -ne '') {
            try {
                $parsedStartDate = ConvertTo-DateTime -InputValue $StartDate
                $parsedEndDate = if ($null -ne $EndDate -and $EndDate -ne '') { 
                    ConvertTo-DateTime -InputValue $EndDate 
                }
                else { 
                    Get-Date 
                }
            }
            catch {
                Write-Warning "Invalid date format, loading all history: $($_.Exception.Message)"
                $parsedStartDate = $null
                $parsedEndDate = $null
            }
        }
        
        # Check if we can use cache
        if (-not $NoCache -and $global:HuntBrowserCache_LoadTool.Enabled) {
            $cacheDecision = Test-LoadToolCacheValidity -RequestedStartDate $parsedStartDate -RequestedEndDate $parsedEndDate -RequestedCSVPath ""
            
            if ($cacheDecision.Valid -and $cacheDecision.UseCache) {
                if (-not $Quiet) {
                    Write-Host "[CACHE] Using cached LoadTool data ($($global:HuntBrowserCache_LoadTool.RawRecords.Count) records)" -ForegroundColor Green
                }
                
                $global:HuntBrowserCache_LoadTool.Statistics.CacheHits++
                $global:HuntBrowserCache_LoadTool.Statistics.LastOperation = "Cache hit - filtered from cache"
                
                # Filter cached records
                $filteredRecords = Get-FilteredCachedBrowserRecords -StartDate $parsedStartDate -EndDate $parsedEndDate -Search $Search -Exclude $Exclude -Quiet:$Quiet
                
                # Convert to result objects
                $results = [System.Collections.Generic.List[PSObject]]::new()
                $currentUser = if ($env:USERNAME) { $env:USERNAME } else { "Unknown" }
                
                foreach ($row in $filteredRecords) {
                    try {
                        # Apply mode-based pattern matching to cached results
                        $matchPattern = "LoadTool-Cached"
                        $url = $row.URL
                        $title = $row.Title
                        
                        if (![string]::IsNullOrWhiteSpace($url) -or ![string]::IsNullOrWhiteSpace($title)) {
                            $testString = "$url $title"
                            
                            # Check suspicious patterns based on mode
                            if ($EffectiveMode -eq "Auto" -or $EffectiveMode -eq "Aggressive") {
                                # Check suspicious strings
                                foreach ($pattern in $script:suspiciousBrowserStrings) {
                                    try {
                                        if ($testString -like "*$pattern*") {
                                            $matchPattern = "[SUS_STRING] $pattern"
                                            break
                                        }
                                    }
                                    catch { continue }
                                }
                                
                                # Check suspicious TLDs if no match yet
                                if ($matchPattern -eq "LoadTool-Cached") {
                                    foreach ($tld in $script:suspiciousTLDs) {
                                        try {
                                            if ($testString -like "*$tld*") {
                                                $matchPattern = "[SUS_TLD] $tld"
                                                break
                                            }
                                        }
                                        catch { continue }
                                    }
                                }
                                
                                # Check aggressive patterns if in Aggressive mode
                                if ($EffectiveMode -eq "Aggressive" -and $matchPattern -eq "LoadTool-Cached") {
                                    foreach ($pattern in $script:aggressiveBrowserStrings) {
                                        try {
                                            if ($testString -like "*$pattern*") {
                                                $matchPattern = "[AGG_STRING] $pattern"
                                                break
                                            }
                                        }
                                        catch { continue }
                                    }
                                }
                            }
                            
                            # Skip network indicators for cached mode (only use pattern lists)
                        }
                        
                        $resultObj = [PSCustomObject]@{
                            User         = Sanitize-Output $currentUser
                            Browser      = Sanitize-Output ($row.'Web Browser')
                            String       = Sanitize-Output ($row.URL)
                            FullString   = Sanitize-Output ($row.URL)
                            MatchPattern = $matchPattern
                            Length       = if ($row.URL) { ($row.URL -replace '[^\w]', '').Length } else { 0 }
                            Source       = "LoadTool-Cached"
                            Hostname     = Sanitize-Output $Hostname
                            Count        = 1
                            Title        = Sanitize-Output ($row.Title)
                            VisitTime    = Sanitize-Output ($row.'Visit Time')
                        }
                        $results.Add($resultObj)
                    }
                    catch {
                        continue
                    }
                }
                
                if (-not $Quiet) {
                    Write-Host "[CACHE] Returned $($results.Count) filtered records from cache" -ForegroundColor Green
                }
                
                return $results
            }
            else {
                if (-not $Quiet) {
                    Write-Verbose "Cache miss: $($cacheDecision.Reason)"
                }
                
                $global:HuntBrowserCache_LoadTool.Statistics.CacheMisses++
                $global:HuntBrowserCache_LoadTool.Statistics.LastOperation = "Cache miss - $($cacheDecision.Reason)"
            }
        }
        
        # If we have cache data and no explicit LoadTool request, use cache for search
        if ([string]::IsNullOrWhiteSpace($ExePath) -and 
            [string]::IsNullOrWhiteSpace($OutputPath) -and
            $global:HuntBrowserCache_LoadTool.RawRecords.Count -gt 0 -and
            $global:HuntBrowserCache_LoadTool.Enabled) {
            
            if (-not $Quiet) {
                Write-Host "[CACHE] Using cached data for search (no tool execution)" -ForegroundColor Green
            }
            
            $global:HuntBrowserCache_LoadTool.Statistics.CacheHits++
            $global:HuntBrowserCache_LoadTool.Statistics.LastOperation = "Cache hit - search only"
            
            # Filter cached records
            $filteredRecords = Get-FilteredCachedBrowserRecords -StartDate $parsedStartDate -EndDate $parsedEndDate -Search $Search -Exclude $Exclude -Quiet:$Quiet
            
            # Convert to result objects
            $results = [System.Collections.Generic.List[PSObject]]::new()
            $currentUser = if ($env:USERNAME) { $env:USERNAME } else { "Unknown" }
            
            foreach ($row in $filteredRecords) {
                try {
                    # Apply mode-based pattern matching to cached results
                    $matchPattern = "LoadTool-Cached"
                    $url = $row.URL
                    $title = $row.Title
                    
                    if (![string]::IsNullOrWhiteSpace($url) -or ![string]::IsNullOrWhiteSpace($title)) {
                        $testString = "$url $title"
                        
                        # Check suspicious patterns based on mode
                        if ($EffectiveMode -eq "Auto" -or $EffectiveMode -eq "Aggressive") {
                            # Check suspicious strings
                            foreach ($pattern in $script:suspiciousBrowserStrings) {
                                try {
                                    if ($testString -like "*$pattern*") {
                                        $matchPattern = "[SUS_STRING] $pattern"
                                        break
                                    }
                                }
                                catch { continue }
                            }
                            
                            # Check suspicious TLDs if no match yet
                            if ($matchPattern -eq "LoadTool-Cached") {
                                foreach ($tld in $script:suspiciousTLDs) {
                                    try {
                                        if ($testString -like "*$tld*") {
                                            $matchPattern = "[SUS_TLD] $tld"
                                            break
                                        }
                                    }
                                    catch { continue }
                                }
                            }
                            
                            # Check aggressive patterns if in Aggressive mode
                            if ($EffectiveMode -eq "Aggressive" -and $matchPattern -eq "LoadTool-Cached") {
                                foreach ($pattern in $script:aggressiveBrowserStrings) {
                                    try {
                                        if ($testString -like "*$pattern*") {
                                            $matchPattern = "[AGG_STRING] $pattern"
                                            break
                                        }
                                    }
                                    catch { continue }
                                }
                            }
                        }
                        
                        # Skip network indicators for cached mode (only use pattern lists)
                    }
                    
                    $resultObj = [PSCustomObject]@{
                        User         = Sanitize-Output $currentUser
                        Browser      = Sanitize-Output ($row.'Web Browser')
                        String       = Sanitize-Output ($row.URL)
                        FullString   = Sanitize-Output ($row.URL)
                        MatchPattern = $matchPattern
                        Length       = if ($row.URL) { ($row.URL -replace '[^\w]', '').Length } else { 0 }
                        Source       = "LoadTool-Cached"
                        Hostname     = Sanitize-Output $Hostname
                        Count        = 1
                        Title        = Sanitize-Output ($row.Title)
                        VisitTime    = Sanitize-Output ($row.'Visit Time')
                    }
                    $results.Add($resultObj)
                }
                catch {
                    continue
                }
            }
            
            if (-not $Quiet) {
                Write-Host "[CACHE] Returned $($results.Count) filtered records from cache" -ForegroundColor Green
            }
            
            return $results
        }

        # ============================================================================
        # RUN BROWSINGHISTORYVIEW TOOL
        # ============================================================================
        
        # Determine if we need to download or use local copy
        $useLocalCopy = $false
        $localExePath = ""
    
        if (![string]::IsNullOrWhiteSpace($ExePath)) {
            try {
                $testPath = [System.IO.Path]::GetFullPath($ExePath)
            
                if (Test-Path $testPath -PathType Leaf -ErrorAction SilentlyContinue) {
                    $extension = [System.IO.Path]::GetExtension($testPath)
                    if ($extension -eq ".exe") {
                        $useLocalCopy = $true
                        $localExePath = $testPath
                        if (-not $Quiet) {
                            Write-Host "[LOCAL] Using local executable: $localExePath" -ForegroundColor Green
                        }
                    }
                    else {
                        if (-not $Quiet) {
                            Write-Host "[WARN] Provided path is not an .exe file, will download from online" -ForegroundColor Yellow
                        }
                    }
                }
                else {
                    if (-not $Quiet) {
                        Write-Host "[WARN] Provided path does not exist, will download from online" -ForegroundColor Yellow
                    }
                }
            }
            catch {
                if (-not $Quiet) {
                    Write-Host "[WARN] Invalid path provided, will download from online" -ForegroundColor Yellow
                }
            }
        }
        else {
            if (-not $Quiet) {
                Write-Host "[INFO] No local path provided, will download from online" -ForegroundColor Cyan
            }
        }

        # Security confirmation for third-party executable download (only if downloading)
        if (-not $useLocalCopy -and -not $SkipConfirmation) {
            Write-Host ""
            Write-Host "[ CONFIRMATION REQUIRED ]" -ForegroundColor Red
            Write-Host ""
            Write-Host "LoadTool mode requires downloading a third-party executable:" -ForegroundColor White
            Write-Host "  Tool: BrowsingHistoryView by NirSoft" -ForegroundColor White
            Write-Host "  URL:  https://www.nirsoft.net/utils/browsinghistoryview.zip" -ForegroundColor White
            Write-Host "  Info: https://www.nirsoft.net/utils/browsing_history_view.html" -ForegroundColor White
            Write-Host ""
            Write-Host "This tool will be downloaded, extracted, and executed to extract" -ForegroundColor White
            Write-Host "browser history data from your system." -ForegroundColor White
            Write-Host ""
            Write-Host "[Options]"
            Write-Host "Load local copy with '-LoadToolPath',"
            Write-Host "Use built-in Hunt-Browser modes (-Auto, -All, -Aggressive)" -ForegroundColor DarkGray
            Write-Host "or skip this confirmation with -SkipConfirmation parameter." -ForegroundColor DarkGray
            Write-Host ""
    
            do {
                $confirmation = Read-Host "Do you want to download and execute this third-party tool? (Y/N)"
                $confirmation = $confirmation.Trim().ToUpper()
        
                if ($confirmation -eq 'N' -or $confirmation -eq 'NO') {
                    Write-Host ""
                    Write-Host "[CANCELLED] LoadTool mode cancelled by user." -ForegroundColor Yellow
                    return @()
                }
                elseif ($confirmation -eq 'Y' -or $confirmation -eq 'YES') {
                    Write-Host ""
                    Write-Host "[CONFIRMED] User confirmed download. Proceeding..." -ForegroundColor Green
                    break
                }
                else {
                    Write-Host "Please enter Y (yes) or N (no)." -ForegroundColor Red
                }
            } while ($true)
        }

        # Determine output CSV path
        $outputCsv = ""
        $userWantsCSV = ![string]::IsNullOrWhiteSpace($OutputPath)
        
        if ($userWantsCSV) {
            # User specified output path
            if (Test-Path $OutputPath -PathType Container -ErrorAction SilentlyContinue) {
                $outputCsv = Join-Path $OutputPath "BrowsingHistory_$(Get-Date -Format 'yyyyMMdd-HHmmss').csv"
            }
            elseif ($OutputPath -match '\.csv$') {
                $outputCsv = $OutputPath
            }
            else {
                $outputCsv = $OutputPath + ".csv"
            }
        }
        else {
            # No user output path - use temp file that will be deleted
            $outputCsv = Join-Path $env:TEMP "BrowsingHistory_Temp_$([guid]::NewGuid()).csv"
        }

        # Sanitize and resolve output path
        try {
            $outputCsv = Resolve-SafePath -Path $outputCsv -AllowNew -Extension ".csv"
        }
        catch {
            Write-Error "Invalid output path specified"
            return @()
        }

        # Ensure output directory exists
        try {
            $outputDir = Split-Path $outputCsv -Parent
            if (-not (Test-Path $outputDir -ErrorAction SilentlyContinue)) {
                New-Item -Path $outputDir -ItemType Directory -Force -ErrorAction Stop | Out-Null
            }
            
            # Only mark as persistent if user wants to keep it
            if ($userWantsCSV) {
                $script:PersistentFiles += $outputCsv
            }
            else {
                $script:AllFilesToCleanup += $outputCsv
            }
        }
        catch {
            Write-Error "Failed to create output directory for CSV: $($_.Exception.Message)"
            return @()
        }

        $tempDir = Join-Path -Path $env:TEMP -ChildPath ("Hunt-Browser-Tools-" + [guid]::NewGuid().ToString())
        $finalExePath = ""

        try {
            if ($useLocalCopy) {
                $finalExePath = $localExePath
            }
            else {
                # Download and extract
                New-Item -Path $tempDir -ItemType Directory -Force -ErrorAction Stop | Out-Null
                $script:AllFilesToCleanup += $tempDir
        
                $downloadUrl = "https://www.nirsoft.net/utils/browsinghistoryview.zip"
                $infoUrl = "https://www.nirsoft.net/utils/browsing_history_view.html"
                $zipPath = Join-Path -Path $tempDir -ChildPath "browsinghistoryview.zip"
        
                if (-not $Quiet) {
                    Write-Host "[DOWNLOAD] Downloading BrowsingHistoryView from NirSoft..." -ForegroundColor Yellow
                    Write-Host "[SOURCE]   Download URL: $downloadUrl" -ForegroundColor Gray
                    Write-Host "[INFO]     Tool info: $infoUrl" -ForegroundColor Gray
                    Write-Host "[STATUS]   Initiating secure download..." -ForegroundColor Cyan
                }
        
                try {
                    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
                    Invoke-WebRequest -Uri $downloadUrl -OutFile $zipPath -UseBasicParsing -ErrorAction Stop
            
                    if (-not $Quiet) {
                        $fileSize = [math]::Round((Get-Item $zipPath).Length / 1KB, 2)
                        Write-Host "[SUCCESS]  Downloaded $fileSize KB successfully" -ForegroundColor Green
                    }
                }
                catch {
                    Write-Error "Failed to download BrowsingHistoryView: $($_.Exception.Message)"
                    Write-Host "[HELP]     Check network connection and try again, or use built-in modes" -ForegroundColor Yellow
                    return @()
                }
        
                if (-not $Quiet) {
                    Write-Host "[EXTRACT]  Extracting archive..." -ForegroundColor Cyan
                }
        
                try {
                    Add-Type -AssemblyName System.IO.Compression.FileSystem
                    [System.IO.Compression.ZipFile]::ExtractToDirectory($zipPath, $tempDir)
            
                    if (-not $Quiet) {
                        Write-Host "[SUCCESS]  Archive extracted successfully" -ForegroundColor Green
                    }
                }
                catch {
                    Write-Error "Failed to extract BrowsingHistoryView: $($_.Exception.Message)"
                    return @()
                }
        
                $finalExePath = Join-Path -Path $tempDir -ChildPath "BrowsingHistoryView.exe"
        
                if (-not (Test-Path $finalExePath -ErrorAction SilentlyContinue)) {
                    Write-Error "BrowsingHistoryView.exe not found after extraction"
                    return @()
                }
            }

            # Execute the tool
            try {
                $useTimeFilter = $false
                
                if ($null -ne $parsedStartDate) {
                    # Check if start date is "all time" (1970)
                    if ($parsedStartDate.Year -gt 1970) {
                        $useTimeFilter = $true
                        
                    }
                }
                
                # Build arguments for BrowsingHistoryView
                $safeOutputPath = "`"$outputCsv`""
                
                if ($useTimeFilter) {
                    $startDateStr = $parsedStartDate.ToString("dd-MM-yyyy HH:mm:ss")
                    $endDateStr = $parsedEndDate.ToString("dd-MM-yyyy HH:mm:ss")
                    
                    $arguments = @(
                        "/HistorySource", "1",
                        "/VisitTimeFilterType", "4",
                        "/VisitTimeFrom", "`"$startDateStr`"",
                        "/VisitTimeTo", "`"$endDateStr`"",
                        "/SaveDirect",
                        "/scomma", $safeOutputPath
                    )
                    
                    if (-not $Quiet) {
                        Write-Host "[FILTER]   Time range: $startDateStr to $endDateStr" -ForegroundColor Cyan
                    }
                }
                else {
                    $arguments = @(
                        "/HistorySource", "1",
                        "/VisitTimeFilterType", "1",
                        "/SaveDirect",
                        "/scomma", $safeOutputPath
                    )
                    
                    if (-not $Quiet) {
                        Write-Host "[FILTER]   Loading all available history (no date filter)" -ForegroundColor Cyan
                    }
                }
                
                if (-not $Quiet) {
                    Write-Host "[EXEC]     Executing BrowsingHistoryView..." -ForegroundColor Green
                    if ($userWantsCSV) {
                        Write-Host "[OUTPUT]   CSV will be saved to: $outputCsv" -ForegroundColor Cyan
                    }
                    else {
                        Write-Host "[OUTPUT]   Using temporary CSV (will be deleted after processing)" -ForegroundColor Cyan
                    }
                }
        
                $proc = Start-Process -FilePath $finalExePath -ArgumentList $arguments -Wait -PassThru -NoNewWindow -ErrorAction Stop
        
                if ($proc.ExitCode -eq 0 -and (Test-Path $outputCsv -ErrorAction SilentlyContinue)) {
                    try {
                        $csvData = Import-Csv $outputCsv -ErrorAction Stop
                        
                        # Add RAW records to cache if caching is enabled
                        if (-not $NoCache -and $global:HuntBrowserCache_LoadTool.Enabled) {
                            Add-RecordsToLoadToolCache -NewRecords $csvData -StartDate $parsedStartDate -EndDate $parsedEndDate -SourceCSVPath $outputCsv
                            
                            if (-not $Quiet) {
                                Write-Host "[CACHE] Cached $($csvData.Count) RAW records from BrowsingHistoryView" -ForegroundColor Green
                            }
                        }
                        
                        # Now filter the records
                        $filteredRecords = if ($NoCache) {
                            # Manual filtering
                            $csvData | Where-Object {
                                $record = $_
                                $include = $true
                                
                                # Search filtering
                                if ($Search.Count -gt 0) {
                                    $matchFound = $false
                                    foreach ($pattern in $Search) {
                                        if ($record.URL -like "*$pattern*" -or $record.Title -like "*$pattern*") {
                                            $matchFound = $true
                                            break
                                        }
                                    }
                                    if (-not $matchFound) { $include = $false }
                                }
                                
                                # Exclude filtering
                                if ($include -and $Exclude.Count -gt 0) {
                                    foreach ($pattern in $Exclude) {
                                        if ($record.URL -like "*$pattern*" -or $record.Title -like "*$pattern*") {
                                            $include = $false
                                            break
                                        }
                                    }
                                }
                                
                                $include
                            }
                        }
                        else {
                            # Use cache filtering (even though we just cached, this applies Search/Exclude)
                            Get-FilteredCachedBrowserRecords -StartDate $parsedStartDate -EndDate $parsedEndDate -Search $Search -Exclude $Exclude -Quiet:$Quiet
                        }
                
                        $currentUser = if ($env:USERNAME) { $env:USERNAME } else { "Unknown" }
                        
                        $results = [System.Collections.Generic.List[PSObject]]::new()
                        
                        foreach ($row in $filteredRecords) {
                            try {
                                # Apply mode-based pattern matching to LoadTool results
                                $matchPattern = "LoadTool"
                                $url = $row.URL
                                $title = $row.Title
                        
                                if (![string]::IsNullOrWhiteSpace($url) -or ![string]::IsNullOrWhiteSpace($title)) {
                                    $testString = "$url $title"
                            
                                    # Check suspicious patterns based on mode
                                    if ($EffectiveMode -eq "Auto" -or $EffectiveMode -eq "Aggressive") {
                                        # Check suspicious strings
                                        foreach ($pattern in $script:suspiciousBrowserStrings) {
                                            try {
                                                if ($testString -like "*$pattern*") {
                                                    $matchPattern = "[SUS_STRING] $pattern"
                                                    break
                                                }
                                            }
                                            catch { continue }
                                        }
                                
                                        # Check suspicious TLDs if no match yet
                                        if ($matchPattern -eq "LoadTool") {
                                            foreach ($tld in $script:suspiciousTLDs) {
                                                try {
                                                    if ($testString -like "*$tld*") {
                                                        $matchPattern = "[SUS_TLD] $tld"
                                                        break
                                                    }
                                                }
                                                catch { continue }
                                            }
                                        }
                                
                                        # Check aggressive patterns if in Aggressive mode
                                        if ($EffectiveMode -eq "Aggressive" -and $matchPattern -eq "LoadTool") {
                                            foreach ($pattern in $script:aggressiveBrowserStrings) {
                                                try {
                                                    if ($testString -like "*$pattern*") {
                                                        $matchPattern = "[AGG_STRING] $pattern"
                                                        break
                                                    }
                                                }
                                                catch { continue }
                                            }
                                        }
                                    }
                            
                                    # Check for network indicators
                                    if ($matchPattern -eq "LoadTool") {
                                        try {
                                            $networkIndicator = Test-NetworkIndicators -InputString $testString
                                            if ($networkIndicator) {
                                                $matchPattern = "Network Indicator"
                                            }
                                        }
                                        catch { }
                                    }
                                }
                        
                                $resultObj = [PSCustomObject]@{
                                    User         = Sanitize-Output $currentUser
                                    Browser      = Sanitize-Output ($row.'Web Browser')
                                    String       = Sanitize-Output ($row.URL)
                                    FullString   = Sanitize-Output ($row.URL)
                                    MatchPattern = $matchPattern
                                    Length       = if ($row.URL) { ($row.URL -replace '[^\w]', '').Length } else { 0 }
                                    Source       = "LoadTool"
                                    Hostname     = Sanitize-Output $Hostname
                                    Count        = 1
                                    Title        = Sanitize-Output ($row.Title)
                                    VisitTime    = Sanitize-Output ($row.'Visit Time')
                                }
                                $results.Add($resultObj)
                            }
                            catch {
                                Write-Warning "Failed to process CSV row: $($_.Exception.Message)"
                                continue
                            }
                        }
                
                        if (-not $Quiet) {
                            Write-Host "[SUCCESS]  Extracted $($results.Count) browser history entries" -ForegroundColor Green
                            if ($userWantsCSV) {
                                Write-Host "[SAVED]    CSV file preserved at: $outputCsv" -ForegroundColor Green
                            }
                            else {
                                Write-Host "[TEMP]     Temporary CSV will be cleaned up" -ForegroundColor Yellow
                            }
                        }
                
                        return $results
                    }
                    catch {
                        Write-Error "Failed to parse CSV: $($_.Exception.Message)"
                        if ($userWantsCSV -and -not $Quiet) {
                            Write-Host "[SAVED]    CSV file preserved at: $outputCsv" -ForegroundColor Green
                        }
                        return @()
                    }
                }
                else {
                    Write-Error "BrowsingHistoryView failed to generate output (Exit Code: $($proc.ExitCode))"
                    return @()
                }
            }
            catch {
                Write-Error "Failed to execute BrowsingHistoryView: $($_.Exception.Message)"
                return @()
            }
    
        }
        catch {
            Write-Error "LoadTool mode failed: $($_.Exception.Message)"
            return @()
        }
    }

    function Get-InstalledBrowsers {
        $browsers = @()
    
        # Comprehensive browser definitions
        $browserDefinitions = @(
            # Chrome variants
            @{ Name = "Chrome"; Path = "\Google\Chrome\User Data\Default\History"; Type = "Chromium" },
            @{ Name = "Chrome Beta"; Path = "\Google\Chrome Beta\User Data\Default\History"; Type = "Chromium" },
            @{ Name = "Chrome Dev"; Path = "\Google\Chrome Dev\User Data\Default\History"; Type = "Chromium" },
            @{ Name = "Chrome Canary"; Path = "\Google\Chrome SxS\User Data\Default\History"; Type = "Chromium" },
        
            # Edge variants
            @{ Name = "Edge"; Path = "\Microsoft\Edge\User Data\Default\History"; Type = "Chromium" },
            @{ Name = "Edge Beta"; Path = "\Microsoft\Edge Beta\User Data\Default\History"; Type = "Chromium" },
            @{ Name = "Edge Dev"; Path = "\Microsoft\Edge Dev\User Data\Default\History"; Type = "Chromium" },
            @{ Name = "Edge Canary"; Path = "\Microsoft\Edge SxS\User Data\Default\History"; Type = "Chromium" },
            @{ Name = "Edge Legacy"; Path = "\Microsoft\Windows\WebCache\WebCacheV*.dat"; Type = "Edge" },
        
            # Firefox variants
            @{ Name = "Firefox"; Path = "\Mozilla\Firefox\Profiles\*\places.sqlite"; Type = "Firefox" },
            @{ Name = "Firefox ESR"; Path = "\Mozilla\Firefox\Profiles\*\places.sqlite"; Type = "Firefox" },
            @{ Name = "Firefox Developer"; Path = "\Mozilla\Firefox\Profiles\*\places.sqlite"; Type = "Firefox" },
        
            # Other browsers
            @{ Name = "Opera"; Path = "\Opera Software\Opera Stable\History"; Type = "Chromium" },
            @{ Name = "Opera GX"; Path = "\Opera Software\Opera GX Stable\History"; Type = "Chromium" },
            @{ Name = "Brave"; Path = "\BraveSoftware\Brave-Browser\User Data\Default\History"; Type = "Chromium" },
            @{ Name = "Vivaldi"; Path = "\Vivaldi\User Data\Default\History"; Type = "Chromium" },
            @{ Name = "Yandex"; Path = "\Yandex\YandexBrowser\User Data\Default\History"; Type = "Chromium" },
            @{ Name = "Tor Browser"; Path = "\Tor Browser\Browser\TorBrowser\Data\Browser\profile.default\places.sqlite"; Type = "Firefox" },
            @{ Name = "Waterfox"; Path = "\Waterfox\Profiles\*\places.sqlite"; Type = "Firefox" },
            @{ Name = "Pale Moon"; Path = "\Moonchild Productions\Pale Moon\Profiles\*\places.sqlite"; Type = "Firefox" },
            @{ Name = "SeaMonkey"; Path = "\Mozilla\SeaMonkey\Profiles\*\places.sqlite"; Type = "Firefox" },
            @{ Name = "Maxthon"; Path = "\Maxthon5\Users\*\History"; Type = "Chromium" },
            @{ Name = "UC Browser"; Path = "\UCBrowser\User Data\Default\History"; Type = "Chromium" },
            @{ Name = "Comodo Dragon"; Path = "\Comodo\Dragon\User Data\Default\History"; Type = "Chromium" }
        )
    
        # Test all browsers against all user profiles
        $userProfiles = Get-UserProfiles
        foreach ($browser in $browserDefinitions) {
            $found = $false
            foreach ($userProfile in $userProfiles) {
                try {
                    $testPath = if ($browser.Type -eq "Firefox") {
                        Join-Path $userProfile "AppData\Roaming$($browser.Path)"
                    }
                    else {
                        Join-Path $userProfile "AppData\Local$($browser.Path)"
                    }
                
                    $testPath = [System.IO.Path]::GetFullPath($testPath)
                
                    # Check if browser data exists for this user
                    if ($browser.Type -eq "Firefox" -or $browser.Path -like "*\*\*") {
                        # For Firefox and wildcard paths, check parent directory
                        $parentDir = Split-Path $testPath -Parent
                        if (Test-Path $parentDir -ErrorAction SilentlyContinue) {
                            $found = $true
                            break
                        }
                    }
                    else {
                        # For specific files, check file or parent directory
                        if ((Test-Path $testPath -ErrorAction SilentlyContinue) -or 
                            (Test-Path (Split-Path $testPath -Parent) -ErrorAction SilentlyContinue)) {
                            $found = $true
                            break
                        }
                    }
                }
                catch { continue }
            }
        
            if ($found) {
                $browsers += $browser
            }
        }
    
        return $browsers
    }

    function Get-BrowserExtensions {
        [CmdletBinding()]
        param(
            [string]$UserProfile,
            [string]$UserName,
            [string]$Hostname,
            [string[]]$Search = @(),
            [string[]]$Exclude = @(),
            [switch]$Quiet
        )
        
        $extensions = @()
        
        try {
            if (-not (Test-Path $UserProfile -PathType Container -ErrorAction SilentlyContinue)) {
                return @()
            }
            
            # Define browser extension paths
            $browserPaths = @(
                # Chrome variants
                @{
                    Browser = "Chrome"
                    Type    = "Chromium"
                    Path    = "AppData\Local\Google\Chrome\User Data\*\Extensions"
                },
                @{
                    Browser = "Chrome Beta"
                    Type    = "Chromium"
                    Path    = "AppData\Local\Google\Chrome Beta\User Data\*\Extensions"
                },
                @{
                    Browser = "Chrome Dev"
                    Type    = "Chromium"
                    Path    = "AppData\Local\Google\Chrome Dev\User Data\*\Extensions"
                },
                @{
                    Browser = "Chrome Canary"
                    Type    = "Chromium"
                    Path    = "AppData\Local\Google\Chrome SxS\User Data\*\Extensions"
                },
                # Edge variants
                @{
                    Browser = "Edge"
                    Type    = "Chromium"
                    Path    = "AppData\Local\Microsoft\Edge\User Data\*\Extensions"
                },
                @{
                    Browser = "Edge Beta"
                    Type    = "Chromium"
                    Path    = "AppData\Local\Microsoft\Edge Beta\User Data\*\Extensions"
                },
                @{
                    Browser = "Edge Dev"
                    Type    = "Chromium"
                    Path    = "AppData\Local\Microsoft\Edge Dev\User Data\*\Extensions"
                },
                # Other Chromium browsers
                @{
                    Browser = "Brave"
                    Type    = "Chromium"
                    Path    = "AppData\Local\BraveSoftware\Brave-Browser\User Data\*\Extensions"
                },
                @{
                    Browser = "Opera"
                    Type    = "Chromium"
                    Path    = "AppData\Roaming\Opera Software\Opera Stable\Extensions"
                },
                @{
                    Browser = "Opera GX"
                    Type    = "Chromium"
                    Path    = "AppData\Roaming\Opera Software\Opera GX Stable\Extensions"
                },
                @{
                    Browser = "Vivaldi"
                    Type    = "Chromium"
                    Path    = "AppData\Local\Vivaldi\User Data\*\Extensions"
                },
                @{
                    Browser = "Yandex"
                    Type    = "Chromium"
                    Path    = "AppData\Local\Yandex\YandexBrowser\User Data\*\Extensions"
                },
                # Firefox
                @{
                    Browser = "Firefox"
                    Type    = "Firefox"
                    Path    = "AppData\Roaming\Mozilla\Firefox\Profiles\*\extensions"
                }
            )
            
            foreach ($browserDef in $browserPaths) {
                try {
                    $extensionBasePath = Join-Path $UserProfile $browserDef.Path
                    
                    # Handle wildcard paths
                    if ($extensionBasePath -like "*\*\*") {
                        $parentPath = Split-Path (Split-Path $extensionBasePath -Parent) -Parent
                        if (-not (Test-Path $parentPath -ErrorAction SilentlyContinue)) {
                            continue
                        }
                        
                        $profileDirs = Get-ChildItem $parentPath -Directory -ErrorAction SilentlyContinue
                        $extensionDirs = @()
                        
                        foreach ($profileDir in $profileDirs) {
                            $extPath = Join-Path $profileDir.FullName "Extensions"
                            if (Test-Path $extPath -ErrorAction SilentlyContinue) {
                                $extensionDirs += $extPath
                            }
                        }
                    }
                    else {
                        if (-not (Test-Path $extensionBasePath -ErrorAction SilentlyContinue)) {
                            continue
                        }
                        $extensionDirs = @($extensionBasePath)
                    }
                    
                    foreach ($extDir in $extensionDirs) {
                        try {
                            if ($browserDef.Type -eq "Firefox") {
                                # Firefox extensions
                                $firefoxExtensions = Get-ChildItem $extDir -File -Filter "*.xpi" -ErrorAction SilentlyContinue
                                
                                foreach ($xpiFile in $firefoxExtensions) {
                                    try {
                                        $extId = $xpiFile.BaseName
                                        
                                        # Try to read manifest from XPI (it's a ZIP file)
                                        Add-Type -AssemblyName System.IO.Compression.FileSystem
                                        $zip = [System.IO.Compression.ZipFile]::OpenRead($xpiFile.FullName)
                                        $manifestEntry = $zip.Entries | Where-Object { $_.Name -eq "manifest.json" } | Select-Object -First 1
                                        
                                        if ($manifestEntry) {
                                            $stream = $manifestEntry.Open()
                                            $reader = New-Object System.IO.StreamReader($stream)
                                            $manifestJson = $reader.ReadToEnd()
                                            $reader.Close()
                                            $stream.Close()
                                            $zip.Dispose()
                                            
                                            $manifest = $manifestJson | ConvertFrom-Json
                                            
                                            $extName = if ($manifest.name) { $manifest.name } else { $extId }
                                            $extVersion = if ($manifest.version) { $manifest.version } else { "Unknown" }
                                            $extDescription = if ($manifest.description) { $manifest.description } else { "" }
                                            
                                            # Apply search/exclude filters
                                            if ($Search.Count -gt 0) {
                                                $matchFound = $false
                                                foreach ($pattern in $Search) {
                                                    if ($extName -like "*$pattern*" -or $extDescription -like "*$pattern*" -or $extId -like "*$pattern*") {
                                                        $matchFound = $true
                                                        break
                                                    }
                                                }
                                                if (-not $matchFound) { continue }
                                            }
                                            
                                            if ($Exclude.Count -gt 0) {
                                                $excluded = $false
                                                foreach ($pattern in $Exclude) {
                                                    if ($extName -like "*$pattern*" -or $extDescription -like "*$pattern*" -or $extId -like "*$pattern*") {
                                                        $excluded = $true
                                                        break
                                                    }
                                                }
                                                if ($excluded) { continue }
                                            }
                                            
                                            # Extract proper extension ID from manifest
                                            $finalExtId = $extId
                                            if ($manifest.browser_specific_settings.gecko.id) {
                                                $finalExtId = $manifest.browser_specific_settings.gecko.id
                                            }
                                            elseif ($manifest.applications.gecko.id) {
                                                $finalExtId = $manifest.applications.gecko.id
                                            }
                                            
                                            $extensions += [PSCustomObject]@{
                                                User        = $UserName
                                                Browser     = $browserDef.Browser
                                                ExtensionID = $finalExtId
                                                Name        = $extName
                                                Version     = $extVersion
                                                Description = $extDescription
                                                Permissions = ""
                                                InstallPath = $xpiFile.FullName
                                                Hostname    = $Hostname
                                            }
                                        }
                                        else {
                                            $zip.Dispose()
                                        }
                                    }
                                    catch {
                                        Write-Verbose "Failed to process Firefox extension: $($xpiFile.Name) - $($_.Exception.Message)"
                                        continue
                                    }
                                }
                            }
                            else {
                                # Chromium-based extensions
                                $extensionFolders = Get-ChildItem $extDir -Directory -ErrorAction SilentlyContinue
                                
                                foreach ($extFolder in $extensionFolders) {
                                    try {
                                        $extId = $extFolder.Name
                                        
                                        # Find the highest version folder
                                        $versionFolders = Get-ChildItem $extFolder.FullName -Directory -ErrorAction SilentlyContinue | 
                                        Sort-Object Name -Descending | Select-Object -First 1
                                        
                                        if (-not $versionFolders) { continue }
                                        
                                        $manifestPath = Join-Path $versionFolders.FullName "manifest.json"
                                        
                                        if (Test-Path $manifestPath -ErrorAction SilentlyContinue) {
                                            try {
                                                $manifestContent = Get-Content $manifestPath -Raw -ErrorAction Stop
                                                $manifest = $manifestContent | ConvertFrom-Json -ErrorAction Stop
                                                
                                                $extName = if ($manifest.name) { 
                                                    # Handle Chrome i18n names
                                                    if ($manifest.name -match '^__MSG_(.+)__$') {
                                                        # Try to read from _locales
                                                        $msgKey = $matches[1]
                                                        $localesPath = Join-Path $versionFolders.FullName "_locales\en\messages.json"
                                                        if (Test-Path $localesPath -ErrorAction SilentlyContinue) {
                                                            try {
                                                                $localesContent = Get-Content $localesPath -Raw -ErrorAction Stop
                                                                $locales = $localesContent | ConvertFrom-Json -ErrorAction Stop
                                                                if ($locales.$msgKey.message) {
                                                                    $locales.$msgKey.message
                                                                }
                                                                else {
                                                                    $manifest.name
                                                                }
                                                            }
                                                            catch {
                                                                $manifest.name
                                                            }
                                                        }
                                                        else {
                                                            $manifest.name
                                                        }
                                                    }
                                                    else {
                                                        $manifest.name
                                                    }
                                                }
                                                else { 
                                                    $extId 
                                                }
                                                
                                                $extVersion = if ($manifest.version) { $manifest.version } else { "Unknown" }
                                                $extDescription = if ($manifest.description) { 
                                                    if ($manifest.description -match '^__MSG_(.+)__$') {
                                                        ""
                                                    }
                                                    else {
                                                        $manifest.description
                                                    }
                                                }
                                                else { "" }
                                                
                                                # Extract permissions
                                                $permissions = @()
                                                if ($manifest.permissions) {
                                                    $permissions += $manifest.permissions
                                                }
                                                if ($manifest.host_permissions) {
                                                    $permissions += $manifest.host_permissions
                                                }
                                                $permissionsStr = ($permissions | Sort-Object -Unique) -join ", "
                                                
                                                # Apply search/exclude filters
                                                if ($Search.Count -gt 0) {
                                                    $matchFound = $false
                                                    foreach ($pattern in $Search) {
                                                        if ($extName -like "*$pattern*" -or $extDescription -like "*$pattern*" -or 
                                                            $extId -like "*$pattern*" -or $permissionsStr -like "*$pattern*") {
                                                            $matchFound = $true
                                                            break
                                                        }
                                                    }
                                                    if (-not $matchFound) { continue }
                                                }
                                                
                                                if ($Exclude.Count -gt 0) {
                                                    $excluded = $false
                                                    foreach ($pattern in $Exclude) {
                                                        if ($extName -like "*$pattern*" -or $extDescription -like "*$pattern*" -or 
                                                            $extId -like "*$pattern*" -or $permissionsStr -like "*$pattern*") {
                                                            $excluded = $true
                                                            break
                                                        }
                                                    }
                                                    if ($excluded) { continue }
                                                }
                                                
                                                $extensions += [PSCustomObject]@{
                                                    User        = $UserName
                                                    Browser     = $browserDef.Browser
                                                    ExtensionID = $extId
                                                    Name        = $extName
                                                    Version     = $extVersion
                                                    Description = $extDescription
                                                    Permissions = $permissionsStr
                                                    InstallPath = $versionFolders.FullName
                                                    Hostname    = $Hostname
                                                }
                                            }
                                            catch {
                                                Write-Verbose "Failed to parse manifest for $extId`: $($_.Exception.Message)"
                                                continue
                                            }
                                        }
                                    }
                                    catch {
                                        Write-Verbose "Failed to process extension folder: $($extFolder.Name) - $($_.Exception.Message)"
                                        continue
                                    }
                                }
                            }
                        }
                        catch {
                            Write-Verbose "Failed to process extension directory: $extDir - $($_.Exception.Message)"
                            continue
                        }
                    }
                }
                catch {
                    Write-Verbose "Failed to process browser: $($browserDef.Browser) - $($_.Exception.Message)"
                    continue
                }
            }
            
            return $extensions
        }
        catch {
            Write-Verbose "Failed to enumerate extensions for user $UserName`: $($_.Exception.Message)"
            return @()
        }
    }

    function Get-UserProfiles {
        $profiles = @()
    
        try {
            # Method 1: Direct enumeration of C:\Users (most reliable)
            if (Test-Path "C:\Users" -ErrorAction SilentlyContinue) {
                $userDirs = Get-ChildItem "C:\Users" -Directory -Force -ErrorAction SilentlyContinue | 
                Where-Object { 
                    $_.Name -notin @("Default", "Public", "All Users", "Default User") -and
                    $_.Name -notlike ".*" -and
                    $_.FullName -and
                    (Test-Path (Join-Path $_.FullName "AppData") -ErrorAction SilentlyContinue)
                }
            
                foreach ($dir in $userDirs) {
                    if ($dir.FullName -and (Test-Path $dir.FullName -ErrorAction SilentlyContinue)) {
                        $profiles += $dir.FullName
                    }
                }
            }
        
            # Method 2: Current user (always Search)
            if ($env:USERPROFILE -and (Test-Path $env:USERPROFILE -ErrorAction SilentlyContinue)) {
                if ($profiles -notcontains $env:USERPROFILE) {
                    $profiles += $env:USERPROFILE
                }
            }
        
            # Method 3: WMI as backup
            try {
                $wmiProfiles = Get-WmiObject -Class Win32_UserProfile -ErrorAction SilentlyContinue | 
                Where-Object {
                    $_.LocalPath -and
                    $_.LocalPath -like "C:\Users\*" -and
                    $_.LocalPath -notlike "*\Default*" -and
                    $_.LocalPath -notlike "*\Public*" -and
                    (Test-Path $_.LocalPath -ErrorAction SilentlyContinue)
                } | Select-Object -ExpandProperty LocalPath
            
                foreach ($profile in $wmiProfiles) {
                    if ($profile -and $profiles -notcontains $profile) {
                        $profiles += $profile
                    }
                }
            }
            catch { }
        
            # Filter and validate all profiles
            $validProfiles = @()
            foreach ($profile in $profiles) {
                if ($profile -and (Test-Path $profile -ErrorAction SilentlyContinue)) {
                    $validProfiles += $profile
                }
            }
        
            return ($validProfiles | Sort-Object -Unique)
        }
        catch {
            # Absolute fallback
            if ($env:USERPROFILE) {
                return @($env:USERPROFILE)
            }
            else {
                return @()
            }
        }
    }

    function Test-NetworkIndicators {
        param([Parameter(Mandatory = $true)][string]$InputString)

        if ([string]::IsNullOrWhiteSpace($InputString)) { return $null }

        try {
            $cleanString = $InputString.Trim()
        
            # Check for IP addresses first (higher priority)
            # IPv4 - enhanced validation
            if ($cleanString -match '\b(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\b') {
                # Additional validation - exclude obviously invalid IPs
                if ($cleanString -notmatch '^0\.0\.0\.0$|^255\.255\.255\.255$') {
                    return Sanitize-Output $cleanString
                }
            }
        
            # IPv6 - basic validation
            if ($cleanString -match '\b(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}\b|(?:[0-9a-fA-F]{1,4}:)*::(?:[0-9a-fA-F]{1,4}:)*[0-9a-fA-F]{1,4}') {
                return Sanitize-Output $cleanString
            }

            # URL detection with validation - more permissive
            if ($cleanString -match '\b(?:https?|ftp|ftps)://[^\s<>"\\]{2,2000}\b') {
                return Sanitize-Output $cleanString
            }
        
            # Domain detection with enhanced validation - more permissive
            foreach ($tld in $script:PossibleTLDs) {
                if ($cleanString -like "*$tld*" -and $cleanString -match '\b[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)*[a-zA-Z]{2,}\b') {
                    $matches = [regex]::Matches($cleanString, '\b[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)*[a-zA-Z]{2,}\b')
                    foreach ($match in $matches) {
                        $domain = $match.Value
                        $parts = $domain.Split('.')
                    
                        if ($parts.Count -ge 2 -and $domain.Length -ge 4 -and $domain.Length -lt 255 -and -not ($domain -match '^\d+\.\d+')) {
                            if ($domain -like "*$tld*") {
                                return Sanitize-Output $domain
                            }
                        }
                    }
                }
            }

            return $null
        }
        catch {
            return $null
        }
    }

    function Test-FilesystemPaths {
        param([Parameter(Mandatory = $true)][string]$InputString)

        if ([string]::IsNullOrWhiteSpace($InputString)) { return $null }

        try {
            $cleanString = $InputString.Trim().Trim('"', "'", '(', ')', '[', ']')
        
            if ($cleanString.Length -lt 3 -or $cleanString.Length -gt 32767) { return $null }
        
            # Exclude patterns that aren't filesystem paths - more permissive
            $excludePatterns = @(
                '^\d+\.\d+\.\d+\.\d+',  # IP addresses
                '^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$',  # Simple domains only
                '@'  # Email addresses
            )
        
            foreach ($pattern in $excludePatterns) {
                if ($cleanString -match $pattern) {
                    return $null
                }
            }
        
            # Windows paths with validation - more permissive
            if ($cleanString -match '\b[A-Za-z]:\\') {
                # Look for drive letter pattern anywhere in string
                if ($cleanString -notmatch '\.\.' -and $cleanString.Length -gt 3) {
                    return Sanitize-Output $cleanString
                }
            }
        
            # UNC paths with validation - more permissive
            if ($cleanString -match '\\\\[^\\]{2,}\\[^\\]{1,}' -and $cleanString -notmatch '\.\.') {
                return Sanitize-Output $cleanString
            }
        
            # Registry paths - more permissive
            if ($cleanString -match '\bHKEY_(LOCAL_MACHINE|CURRENT_USER|CLASSES_ROOT|USERS|CURRENT_CONFIG)\\') {
                return Sanitize-Output $cleanString
            }
        
            # Executable patterns - more permissive
            if ($cleanString -match '\.(exe|bat|cmd|ps1|vbs|scr|com|pif|dll|sys|msi)' -and 
                ($cleanString -match '\\' -or $cleanString -match '/') -and 
                $cleanString -notmatch '\.\.' -and
                $cleanString.Length -gt 5) {
                return Sanitize-Output $cleanString
            }
        
            # Unix paths with validation - more permissive
            if ($cleanString -match '\b/[^/\s]+/[^/\s]+' -and 
                $cleanString -notmatch '\.\.' -and
                $cleanString.Length -gt 3) {
                return Sanitize-Output $cleanString
            }
        
            return $null
        }
        catch {
            return $null
        }
    }

    function Get-UniqueResults {
        param([array]$Results)
    
        try {
            if (-not $Results -or $Results.Count -eq 0) {
                return @()
            }
        
            $uniqueResults = @()
            $stringCounts = @{}
        
            # Group by full string content
            foreach ($result in $Results) {
                try {
                    $key = $result.FullString
                    if ($stringCounts.ContainsKey($key)) {
                        $stringCounts[$key].Count++
                    }
                    else {
                        $stringCounts[$key] = @{
                            Count  = 1
                            Result = $result
                        }
                    }
                }
                catch {
                    continue
                }
            }
        
            # Create unique results with counts
            foreach ($key in $stringCounts.Keys) {
                try {
                    $item = $stringCounts[$key]
                    $uniqueResult = $item.Result.PSObject.Copy()
                    $uniqueResult | Add-Member -MemberType NoteProperty -Name "Count" -Value $item.Count -Force
                    $uniqueResults += $uniqueResult
                }
                catch {
                    continue
                }
            }
        
            return $uniqueResults | Sort-Object Count -Descending
        }
        catch {
            return @()
        }
    }

    function Write-ColoredBrowserResult {
        param($BrowserResult)
    
        try {
            Write-Host ""
            Write-Host "----------------------------------------" -ForegroundColor Gray
            Write-Host "User             : " -NoNewline -ForegroundColor Yellow
            Write-Host $BrowserResult.User -ForegroundColor DarkYellow
        
            Write-Host "Source           : " -NoNewline -ForegroundColor Yellow
            Write-Host "$($BrowserResult.Source) ($($BrowserResult.Browser))" -ForegroundColor White

            Write-Host "String           : " -NoNewline -ForegroundColor Yellow
            Write-Host $BrowserResult.String -ForegroundColor Cyan
        
            Write-Host "Match            : " -NoNewline -ForegroundColor Yellow
            Write-Host $BrowserResult.MatchPattern -ForegroundColor Red
        
            Write-Host "Length           : " -NoNewline -ForegroundColor Yellow
            Write-Host $BrowserResult.Length -ForegroundColor DarkGray
        
            Write-Host "Count            : " -NoNewline -ForegroundColor Yellow
            Write-Host $BrowserResult.Count -ForegroundColor DarkGray
        }
        catch { }
    }

    function Write-HighlightedMessage {
        param(
            [string]$Message,
            [string[]]$SearchStrings,
            [string]$NormalColor = "Cyan",
            [string]$HighlightColor = "Red"
        )
        
        if ([string]::IsNullOrWhiteSpace($Message) -or $SearchStrings.Count -eq 0) {
            Write-Host $Message -ForegroundColor $NormalColor
            return
        }
        
        try {
            # Build a list of all match positions for all search strings
            $allMatches = @()
            
            foreach ($searchStr in $SearchStrings) {
                if ([string]::IsNullOrWhiteSpace($searchStr)) { continue }
                
                # Find all occurrences of this search string (case-insensitive)
                $position = 0
                while ($position -lt $Message.Length) {
                    $foundIndex = $Message.IndexOf($searchStr, $position, [StringComparison]::OrdinalIgnoreCase)
                    
                    if ($foundIndex -ge 0) {
                        $allMatches += [PSCustomObject]@{
                            Start = $foundIndex
                            End   = $foundIndex + $searchStr.Length
                            Text  = $Message.Substring($foundIndex, $searchStr.Length)
                        }
                        $position = $foundIndex + 1
                    }
                    else {
                        break
                    }
                }
            }
            
            if ($allMatches.Count -eq 0) {
                Write-Host $Message -ForegroundColor $NormalColor
                return
            }
            
            # Sort matches by start position and merge overlapping matches
            $sortedMatches = $allMatches | Sort-Object Start
            $mergedMatches = @()
            $currentMatch = $null
            
            foreach ($match in $sortedMatches) {
                if ($null -eq $currentMatch) {
                    $currentMatch = $match
                }
                elseif ($match.Start -le $currentMatch.End) {
                    # Overlapping or adjacent - extend current match
                    if ($match.End -gt $currentMatch.End) {
                        $currentMatch.End = $match.End
                        $currentMatch.Text = $Message.Substring($currentMatch.Start, $currentMatch.End - $currentMatch.Start)
                    }
                }
                else {
                    # Non-overlapping - save current and start new
                    $mergedMatches += $currentMatch
                    $currentMatch = $match
                }
            }
            # Add the last match
            if ($null -ne $currentMatch) {
                $mergedMatches += $currentMatch
            }
            
            # Print the message with highlights
            $lastEnd = 0
            foreach ($match in $mergedMatches) {
                # Print text before match (normal color)
                if ($match.Start -gt $lastEnd) {
                    $beforeText = $Message.Substring($lastEnd, $match.Start - $lastEnd)
                    Write-Host $beforeText -NoNewline -ForegroundColor $NormalColor
                }
                
                # Print matched text (highlighted color)
                Write-Host $match.Text -NoNewline -ForegroundColor $HighlightColor
                
                $lastEnd = $match.End
            }
            
            # Print remaining text after last match
            if ($lastEnd -lt $Message.Length) {
                $afterText = $Message.Substring($lastEnd)
                Write-Host $afterText -NoNewline -ForegroundColor $NormalColor
            }
            
            # End the line
            Write-Host ""
        }
        catch {
            Write-Verbose "Error highlighting message: $($_.Exception.Message)"
            Write-Host $Message -ForegroundColor $NormalColor
        }
    }

    function Write-ExtensionResult {
        param($Extension)
        
        try {
            Write-Host ""
            Write-Host "----------------------------------------" -ForegroundColor Gray
            
            Write-Host "Name         : " -NoNewline -ForegroundColor Yellow
            Write-Host $Extension.Name -ForegroundColor Cyan
            
            Write-Host "Extension ID : " -NoNewline -ForegroundColor Yellow
            Write-Host $Extension.ExtensionID -ForegroundColor White
            
            Write-Host "Version      : " -NoNewline -ForegroundColor Yellow
            Write-Host $Extension.Version -ForegroundColor White
            
            Write-Host "Browser      : " -NoNewline -ForegroundColor Yellow
            Write-Host $Extension.Browser -ForegroundColor White
            
            Write-Host "User         : " -NoNewline -ForegroundColor Yellow
            Write-Host $Extension.User -ForegroundColor DarkYellow
            
            if (![string]::IsNullOrWhiteSpace($Extension.Description)) {
                Write-Host "Description  : " -NoNewline -ForegroundColor Yellow
                Write-Host $Extension.Description -ForegroundColor Gray
            }
            
            if (![string]::IsNullOrWhiteSpace($Extension.Permissions)) {
                Write-Host "Permissions  : " -NoNewline -ForegroundColor Yellow
                Write-Host $Extension.Permissions -ForegroundColor Red
            }
            
            Write-Host "Install Path : " -NoNewline -ForegroundColor Yellow
            Write-Host $Extension.InstallPath -ForegroundColor DarkGray
        }
        catch {
            Write-Verbose "Error displaying extension result: $($_.Exception.Message)"
        }
    }

    function Write-LoadToolBrowserResult {
        param(
            $BrowserRecord,
            [string[]]$SearchStrings = @()
        )
    
        try {
            Write-Host ""
            Write-Host "----------------------------------------" -ForegroundColor Gray
            
            # IMPORTANT FIELDS FIRST (Top Section)
            
            # Visit Time (always show first if present)
            if (![string]::IsNullOrWhiteSpace($BrowserRecord.'Visit Time')) {
                Write-Host "Time     : " -NoNewline -ForegroundColor Yellow
                Write-Host $BrowserRecord.'Visit Time' -ForegroundColor White
            }
            
            # URL (always show if present) - with highlighting
            if (![string]::IsNullOrWhiteSpace($BrowserRecord.URL)) {
                Write-Host "URL      : " -NoNewline -ForegroundColor Yellow
                if ($SearchStrings.Count -gt 0) {
                    Write-HighlightedMessage -Message $BrowserRecord.URL -SearchStrings $SearchStrings -NormalColor "Cyan" -HighlightColor "Red"
                }
                else {
                    Write-Host $BrowserRecord.URL -ForegroundColor Cyan
                }
            }
            
            # MatchPattern (show if it indicates a suspicious pattern)
            if ($null -ne $BrowserRecord.MatchPattern -and 
                $BrowserRecord.MatchPattern -ne "LoadTool" -and
                $BrowserRecord.MatchPattern -ne "LoadCSV" -and
                $BrowserRecord.MatchPattern -ne "LoadTool-Cached") {
                Write-Host "Match    : " -NoNewline -ForegroundColor Yellow
                Write-Host $BrowserRecord.MatchPattern -ForegroundColor Red
            }
            
            # Title - with highlighting
            if (![string]::IsNullOrWhiteSpace($BrowserRecord.Title)) {
                Write-Host "Title    : " -NoNewline -ForegroundColor Yellow
                if ($SearchStrings.Count -gt 0) {
                    Write-HighlightedMessage -Message $BrowserRecord.Title -SearchStrings $SearchStrings -NormalColor "White" -HighlightColor "Red"
                }
                else {
                    Write-Host $BrowserRecord.Title -ForegroundColor White
                }
            }
            
            # Web Browser
            if (![string]::IsNullOrWhiteSpace($BrowserRecord.'Web Browser')) {
                Write-Host "Browser  : " -NoNewline -ForegroundColor Yellow
                Write-Host $BrowserRecord.'Web Browser' -ForegroundColor White
            }
            
            # User Profile - DARK YELLOW/ORANGE
            if (![string]::IsNullOrWhiteSpace($BrowserRecord.'User Profile')) {
                Write-Host "User     : " -NoNewline -ForegroundColor Yellow
                Write-Host $BrowserRecord.'User Profile' -ForegroundColor DarkYellow
            }
            
            # METADATA FIELDS AT BOTTOM (Less Important) - DARK GRAY
            
            # Visit Count - DARK GRAY
            if ($null -ne $BrowserRecord.'Visit Count' -and $BrowserRecord.'Visit Count' -ne '' -and $BrowserRecord.'Visit Count' -ne '0') {
                Write-Host "Count    : " -NoNewline -ForegroundColor Yellow
                Write-Host $BrowserRecord.'Visit Count' -ForegroundColor DarkGray
            }
            
            # Visit Type - DARK GRAY
            if (![string]::IsNullOrWhiteSpace($BrowserRecord.'Visit Type')) {
                Write-Host "Type     : " -NoNewline -ForegroundColor Yellow
                Write-Host $BrowserRecord.'Visit Type' -ForegroundColor DarkGray
            }
            
            # Visit Duration - DARK GRAY
            if (![string]::IsNullOrWhiteSpace($BrowserRecord.'Visit Duration')) {
                Write-Host "Duration : " -NoNewline -ForegroundColor Yellow
                Write-Host $BrowserRecord.'Visit Duration' -ForegroundColor DarkGray
            }
            
            # Browser Profile - DARK GRAY
            if (![string]::IsNullOrWhiteSpace($BrowserRecord.'Browser Profile')) {
                Write-Host "Profile  : " -NoNewline -ForegroundColor Yellow
                Write-Host $BrowserRecord.'Browser Profile' -ForegroundColor DarkGray
            }
            
            # History File - DARK GRAY
            if (![string]::IsNullOrWhiteSpace($BrowserRecord.'History File')) {
                Write-Host "File     : " -NoNewline -ForegroundColor Yellow
                Write-Host $BrowserRecord.'History File' -ForegroundColor DarkGray
            }
            
            # Record ID - DARK GRAY
            if ($null -ne $BrowserRecord.'Record ID' -and $BrowserRecord.'Record ID' -ne '') {
                Write-Host "ID       : " -NoNewline -ForegroundColor Yellow
                Write-Host $BrowserRecord.'Record ID' -ForegroundColor DarkGray
            }
            
        }
        catch { 
            Write-Verbose "Error displaying LoadTool result: $($_.Exception.Message)"
        }
    }


    function Complete-Cleanup {
        param([switch]$Quiet)
    
        $cleanupReport = @{
            FilesRemoved        = @()
            FilesSkipped        = @()
            DirectoriesRemoved  = @()
            DirectoriesSkipped  = @()
            PersistentFilesKept = @()
            Errors              = @()
        }
    
        try {
            # Remove all tracked files (except persistent ones)
            foreach ($file in $script:AllFilesToCleanup) {
                try {
                    if ($file -in $script:PersistentFiles) {
                        $cleanupReport.PersistentFilesKept += $file
                        continue
                    }
                
                    if (Test-Path $file -ErrorAction SilentlyContinue) {
                        if (Test-Path $file -PathType Container) {
                            # It's a directory - use -Recurse and -Force
                            Remove-Item $file -Recurse -Force -ErrorAction Stop
                            $cleanupReport.DirectoriesRemoved += $file
                        }
                        else {
                            # It's a file
                            Remove-Item $file -Force -ErrorAction Stop
                            $cleanupReport.FilesRemoved += $file
                        }
                    }
                    else {
                        $cleanupReport.FilesSkipped += "$file (not found)"
                    }
                }
                catch {
                    $cleanupReport.Errors += "Failed to remove $file`: $($_.Exception.Message)"
                }
            }
        
            # Remove created directories if empty (check this after file cleanup)
            foreach ($dir in $script:CreatedDirectories) {
                try {
                    if (Test-Path $dir -ErrorAction SilentlyContinue) {
                        $items = Get-ChildItem $dir -Force -ErrorAction SilentlyContinue
                        $containsPersistent = $false
                        foreach ($item in $items) {
                            if ($item.FullName -in $script:PersistentFiles) {
                                $containsPersistent = $true
                                break
                            }
                        }
                        if (-not $items -or -not $containsPersistent) {
                            Remove-Item $dir -Recurse -Force -ErrorAction Stop
                            $cleanupReport.DirectoriesRemoved += $dir
                        }
                        else {
                            $cleanupReport.DirectoriesSkipped += "$dir (contains persistent files)"
                        }
                    }
                    else {
                        $cleanupReport.DirectoriesSkipped += "$dir (not found)"
                    }
                }
                catch {
                    $cleanupReport.Errors += "Failed to remove directory $dir`: $($_.Exception.Message)"
                }
            }
        
            # Display cleanup report
            if (-not $Quiet) {
                write-host""
                # if ($cleanupReport.FilesRemoved.Count -gt 0) {
                #     Write-Host "[REMOVED] $($cleanupReport.FilesRemoved.Count) temporary files:" -ForegroundColor Green
                #     $cleanupReport.FilesRemoved | ForEach-Object { Write-Host "  - $_" -ForegroundColor Gray }
                # }
            
                # if ($cleanupReport.DirectoriesRemoved.Count -gt 0) {
                #     Write-Host "[REMOVED] $($cleanupReport.DirectoriesRemoved.Count) temporary directories:" -ForegroundColor Green
                #     $cleanupReport.DirectoriesRemoved | ForEach-Object { Write-Host "  - $_" -ForegroundColor Gray }
                # }
            
                if ($cleanupReport.PersistentFilesKept.Count -gt 0) {
                    Write-Host "[KEPT] $($cleanupReport.PersistentFilesKept.Count) persistent files:" -ForegroundColor Yellow
                    $cleanupReport.PersistentFilesKept | ForEach-Object { Write-Host "  - $_" -ForegroundColor Gray }
                }
            
                if ($cleanupReport.FilesSkipped.Count -gt 0 -or $cleanupReport.DirectoriesSkipped.Count -gt 0) {
                    $skippedTotal = $cleanupReport.FilesSkipped.Count + $cleanupReport.DirectoriesSkipped.Count
                    Write-Host "[SKIPPED] $skippedTotal items already removed or not found:" -ForegroundColor DarkYellow
                    ($cleanupReport.FilesSkipped + $cleanupReport.DirectoriesSkipped) | ForEach-Object { Write-Host "  - $_" -ForegroundColor DarkGray }
                }
            
                if ($cleanupReport.Errors.Count -gt 0) {
                    Write-Host "[ERRORS] $($cleanupReport.Errors.Count) cleanup errors:" -ForegroundColor Red
                    $cleanupReport.Errors | ForEach-Object { Write-Host "  - $_" -ForegroundColor Red }
                }
            
                if ($cleanupReport.FilesRemoved.Count -gt 0 -or $cleanupReport.DirectoriesRemoved.Count -gt 0) {
                    Write-Host "[COMPLETE] Cleanup finished successfully" -ForegroundColor Green
                }
            
            }
        
            $script:AllFilesToCleanup = @()
            $script:CreatedDirectories = @()
            write-host ""
            return $cleanupReport
        }
        catch {
            if (-not $Quiet) {
                Write-Host "[ERROR] Cleanup failed: $($_.Exception.Message)`n" -ForegroundColor Red
            }
            return $cleanupReport
        }
    }


    # Initialize progress tracking
    $progressId = Get-Random
    #Write-Progress -Id $progressId -Activity "Hunt-Browser Analysis" -Status "Initializing..." -PercentComplete 0
    
    # Input validation and sanitization
    if ($null -ne $Search -and $Search.Count -gt 0) {
        $Search = $Search | ForEach-Object { Sanitize-SearchPattern $_ }
    }
    if ($null -ne $Exclude -and $Exclude.Count -gt 0) {
        $Exclude = $Exclude | ForEach-Object { Sanitize-SearchPattern $_ }
    }
    
    # Validate and sanitize paths
    $OutputDir = Resolve-SafePath -Path $OutputDir -DefaultPath "$env:TEMP\ForensicHunter\Hunt-Browser"
    if ($OutputCSV) {
        $OutputCSV = Resolve-SafePath -Path $OutputCSV -AllowNew -Extension ".csv"
    }
    if ($LoadToolPath) {
        $LoadToolPath = Resolve-SafePath -Path $LoadToolPath -AllowNew
    }
    
    # Handle Extensions mode early
    if ($Extensions) {
        if (-not $Quiet) {
            Write-Host "[MODE] Extensions enumeration mode" -ForegroundColor Cyan
        }
        
        try {
            $userProfiles = Get-UserProfiles
            $allExtensions = @()
            $fullhostname = ([Net.Dns]::GetHostByName($env:computerName)).HostName
            $hostname = if ($fullhostname) { $fullhostname } else { "Unknown" }
            
            foreach ($userProfile in $userProfiles) {
                try {
                    $userName = "Unknown"
                    if ($userProfile -and ![string]::IsNullOrWhiteSpace($userProfile)) {
                        try {
                            $leafName = Split-Path $userProfile.Trim() -Leaf
                            if (![string]::IsNullOrWhiteSpace($leafName)) {
                                $userName = $leafName
                            }
                        }
                        catch {
                            if ($userProfile -like "*\*") {
                                $lastSlash = $userProfile.LastIndexOf('\')
                                if ($lastSlash -ge 0 -and $lastSlash -lt ($userProfile.Length - 1)) {
                                    $userName = $userProfile.Substring($lastSlash + 1)
                                }
                            }
                        }
                    }
                    
                    if (-not $Quiet) {
                        Write-Host "[USER] Scanning extensions for: $userName" -ForegroundColor Yellow
                    }
                    
                    $userExtensions = Get-BrowserExtensions -UserProfile $userProfile -UserName $userName -Hostname $hostname -Search $Search -Exclude $Exclude -Quiet:$Quiet
                    
                    if ($userExtensions -and $userExtensions.Count -gt 0) {
                        if (-not $Quiet) {
                            Write-Host "[FOUND] $($userExtensions.Count) extensions for $userName" -ForegroundColor Green
                        }
                        $allExtensions += $userExtensions
                    }
                }
                catch {
                    Write-Verbose "Failed to process user profile: $userProfile - $($_.Exception.Message)"
                    continue
                }
            }
            
            if ($allExtensions.Count -gt 0) {
                if (-not $Quiet) {
                    Write-Host "[RESULTS] Found $($allExtensions.Count) browser extensions" -ForegroundColor Green
                    
                    # Group by User -> Browser
                    $groupedByUser = $allExtensions | Group-Object User | Sort-Object Name
                    
                    foreach ($userGroup in $groupedByUser) {
                        $groupedByBrowser = $userGroup.Group | Group-Object Browser | Sort-Object Name
                        
                        foreach ($browserGroup in $groupedByBrowser) {
                            $sortedExtensions = $browserGroup.Group | Sort-Object Name
                            
                            foreach ($ext in $sortedExtensions) {
                                Write-ExtensionResult $ext
                            }
                        }
                    }
                }
                
                # Export to CSV if requested
                if ($OutputCSV) {
                    try {
                        if (Test-Path $OutputCSV -PathType Container -ErrorAction SilentlyContinue) {
                            $timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
                            $OutputCSV = Join-Path $OutputCSV "Hunt-Browser-Extensions-$timestamp.csv"
                        }
                        
                        $parentDir = Split-Path $OutputCSV -Parent
                        if ($null -ne $parentDir -and -not (Test-Path $parentDir -ErrorAction SilentlyContinue)) {
                            New-Item -Path $parentDir -ItemType Directory -Force -ErrorAction Stop | Out-Null
                        }
                        
                        $allExtensions | Export-Csv -Path $OutputCSV -NoTypeInformation -Encoding UTF8 -ErrorAction Stop
                        
                        if (-not $Quiet) {
                            Write-Host "[CSV] Exported $($allExtensions.Count) extensions to: $OutputCSV" -ForegroundColor Green
                        }
                    }
                    catch {
                        Write-Error "Failed to export CSV: $($_.Exception.Message)"
                    }
                }
                
                if ($PassThru) {
                    return $allExtensions
                }
            }
            else {
                if (-not $Quiet) {
                    Write-Host "[INFO] No browser extensions found" -ForegroundColor Yellow
                }
                
                if ($PassThru) {
                    return @()
                }
            }
        }
        catch {
            Write-Error "Extensions enumeration failed: $($_.Exception.Message)"
            if ($PassThru) {
                return @()
            }
        }
        
        return
    }
    
    # Determine mode logic
    $effectiveMode = $null
    $modeCount = @($Auto, $Aggressive, $All).Where({ $_ }).Count
    
    if ($modeCount -gt 1) {
        Write-Error "Cannot use multiple modes simultaneously. Choose only one: -Auto, -Aggressive, or -All"
        if ($PassThru) { return @() }
        return
    }
    
    # Check if LoadTool switch was specified
    $isLoadToolMode = $LoadTool.IsPresent
    
    if ($Search.Count -gt 0 -or $Exclude.Count -gt 0) {
        $effectiveMode = if ($modeCount -eq 0) { "All" } else {
            switch ($true) {
                $Auto { "Auto" }
                $Aggressive { "Aggressive" }
                $All { "All" }
            }
        }
    }
    elseif ($modeCount -eq 0 -and -not $LoadTool) {
        $effectiveMode = "All"
    }
    else {
        $effectiveMode = switch ($true) {
            $Auto { "Auto" }
            $Aggressive { "Aggressive" }
            $All { "All" }
            default { "All" }
        }
    }
    
    if (-not $effectiveMode -and -not $LoadTool) {
        Write-Error "Unable to determine operation mode"
        if ($PassThru) { return @() }
        return
    }
    
    # Initialize cleanup tracking
    $script:AllFilesToCleanup = @()
    $script:CreatedDirectories = @()
    $script:PersistentFiles = @()
    $fullhostname = ([Net.Dns]::GetHostByName($env:computerName)).HostName
    $hostname = if ($fullhostname) { $fullhostname } else { "Unknown" }
    
    # Display date filter info (LoadTool/LoadCSV mode only, not for cache searches)
    if ($isLoadToolMode -and $null -ne $StartDate -and $StartDate -ne '') {
        try {
            $parsedStartDate = ConvertTo-DateTime -InputValue $StartDate
            $parsedEndDate = if ($null -ne $EndDate -and $EndDate -ne '') { 
                ConvertTo-DateTime -InputValue $EndDate 
            }
            else { 
                Get-Date 
            }
            
            # Only show date message if not "all time"
            if ($parsedStartDate.Year -gt 1970) {
                if (-not $Quiet) {
                    Write-Host "[DATE] Filtering from $($parsedStartDate.ToString('yyyy-MM-dd HH:mm:ss')) to $($parsedEndDate.ToString('yyyy-MM-dd HH:mm:ss'))" -ForegroundColor Cyan
                }
            }
            else {
                if (-not $Quiet) {
                    Write-Host "[DATE] Loading all available history (no date filter)" -ForegroundColor Cyan
                }
            }
        }
        catch {
            Write-Warning "Date parsing failed, defaulting to all history: $($_.Exception.Message)"
        }
    }
    
    try {
        # ALWAYS use cache if available (unless explicitly using LoadTool/LoadCSV to refresh)
        $useCacheForSearch = $false
        if (-not $isLoadToolMode -and 
            [string]::IsNullOrWhiteSpace($LoadCSVPath) -and 
            $global:HuntBrowserCache_LoadTool.RawRecords.Count -gt 0 -and
            $global:HuntBrowserCache_LoadTool.Enabled) {
            $useCacheForSearch = $true
            if (-not $Quiet) {
                Write-Host "[CACHE] Using cached browser history ($($global:HuntBrowserCache_LoadTool.RawRecords.Count) records)" -ForegroundColor Green
            }
        }
        
        # Handle LoadTool mode or cache search
        if ($isLoadToolMode -or ![string]::IsNullOrWhiteSpace($LoadCSVPath) -or $useCacheForSearch) {
            $results = Invoke-LoadToolMode -OutputPath $LoadToolPath -ExePath $LoadToolPath -LoadCSVPath $LoadCSVPath -Hostname $hostname -Quiet:$Quiet -SkipConfirmation:$SkipConfirmation -NoCache:$NoCache -StartDate $StartDate -EndDate $EndDate -Search $Search -Exclude $Exclude -EffectiveMode $effectiveMode
            
            # Display LoadTool results (no uniqueness grouping - show all records sorted by visit time)
            if ($results -and $results.Count -gt 0) {
                if (-not $Quiet) {
                    Write-Host "[RESULTS] Found $($results.Count) browser history entries" -ForegroundColor Green
                    
                    # Parse dates for display filtering if specified
                    $displayStartDate = $null
                    $displayEndDate = $null
                    
                    if ($null -ne $StartDate -and $StartDate -ne '') {
                        try {
                            $displayStartDate = ConvertTo-DateTime -InputValue $StartDate
                            $displayEndDate = if ($null -ne $EndDate -and $EndDate -ne '') { 
                                ConvertTo-DateTime -InputValue $EndDate 
                            }
                            else { 
                                Get-Date 
                            }
                        }
                        catch {
                            Write-Verbose "Could not parse dates for display filtering: $($_.Exception.Message)"
                        }
                    }
                    
                    # Use Get-FilteredCachedBrowserRecords for consistent filtering
                    $displayRecords = Get-FilteredCachedBrowserRecords -StartDate $displayStartDate -EndDate $displayEndDate -Search $Search -Exclude $Exclude -Quiet:$Quiet
                    
                    # Sort by Visit Time (most recent first)
                    $sortedRecords = $displayRecords | Sort-Object {
                        try {
                            [datetime]::Parse($_.'Visit Time')
                        }
                        catch {
                            [datetime]::MinValue
                        }
                    } -Descending
                    
                    # Display each record with search highlighting
                    # First, we need to convert the display records to include MatchPattern
                    $displayResults = [System.Collections.Generic.List[PSObject]]::new()
                    
                    foreach ($record in $sortedRecords) {
                        try {
                            # Apply pattern matching to each record for display
                            $matchPattern = "LoadTool"
                            $url = $record.URL
                            $title = $record.Title
                            
                            if (![string]::IsNullOrWhiteSpace($url) -or ![string]::IsNullOrWhiteSpace($title)) {
                                $testString = "$url $title"
                                
                                # Check suspicious patterns based on effective mode
                                if ($effectiveMode -eq "Auto" -or $effectiveMode -eq "Aggressive") {
                                    # Check suspicious strings
                                    foreach ($pattern in $script:suspiciousBrowserStrings) {
                                        try {
                                            if ($testString -like "*$pattern*") {
                                                $matchPattern = "[SUS_STRING] $pattern"
                                                break
                                            }
                                        }
                                        catch { continue }
                                    }
                                    
                                    # Check suspicious TLDs if no match yet
                                    if ($matchPattern -eq "LoadTool") {
                                        foreach ($tld in $script:suspiciousTLDs) {
                                            try {
                                                if ($testString -like "*$tld*") {
                                                    $matchPattern = "[SUS_TLD] $tld"
                                                    break
                                                }
                                            }
                                            catch { continue }
                                        }
                                    }
                                    
                                    # Check aggressive patterns if in Aggressive mode
                                    if ($effectiveMode -eq "Aggressive" -and $matchPattern -eq "LoadTool") {
                                        foreach ($pattern in $script:aggressiveBrowserStrings) {
                                            try {
                                                if ($testString -like "*$pattern*") {
                                                    $matchPattern = "[AGG_STRING] $pattern"
                                                    break
                                                }
                                            }
                                            catch { continue }
                                        }
                                    }
                                }
                                
                                # Skip network indicators for LoadTool mode (only use pattern lists)
                            }
                            
                            # Add MatchPattern to the record
                            $displayRecord = $record.PSObject.Copy()
                            $displayRecord | Add-Member -MemberType NoteProperty -Name "MatchPattern" -Value $matchPattern -Force
                            
                            # Only show records that match patterns in Auto/Aggressive mode
                            if ($effectiveMode -eq "All" -or $matchPattern -ne "LoadTool") {
                                Write-LoadToolBrowserResult -BrowserRecord $displayRecord -SearchStrings $Search
                            }
                        }
                        catch {
                            Write-Verbose "Failed to display record: $($_.Exception.Message)"
                        }
                    }
                }
                
                # Export to CSV if requested (use converted results for CSV)
                if ($OutputCSV) {
                    Export-ResultsToCSV -Results $results -Path $OutputCSV -Quiet:$Quiet
                }
                
                # Return objects based on PassThru parameter
                if ($PassThru) {
                    # Return raw cached records instead of converted results
                    if ($global:HuntBrowserCache_LoadTool.RawRecords.Count -gt 0) {
                        return $displayRecords
                    }
                    else {
                        return $results
                    }
                }
            }
            else {
                if (-not $Quiet) {
                    Write-Host "`n[INFO] No matching browser history detected" -ForegroundColor Green
                }
                
                if ($PassThru) {
                    return @()
                }
            }
            
            return
        }
        
        # Create output directory safely
        $timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
        if (-not (Test-Path $OutputDir -ErrorAction SilentlyContinue)) {
            try {
                New-Item -Path $OutputDir -ItemType Directory -Force -ErrorAction Stop | Out-Null
                $script:CreatedDirectories += $OutputDir
            }
            catch {
                Write-Error "Failed to create output directory: $($_.Exception.Message)"
                if ($PassThru) { return @() }
                return
            }
        }

        # Inform user that native mode is running (no cache available)
        if (-not $Quiet) {
            Write-Host "[INFO] Running in Native mode (string extraction from browser databases)" -ForegroundColor Cyan
            Write-Host "[TIP] Use 'Hunt-Browser -LoadTool -SkipConfirmation' to cache history for faster future searches" -ForegroundColor Yellow
        }
               
        # Auto-detect browsers
        try {
            $browsers = Get-InstalledBrowsers
            $userProfiles = Get-UserProfiles
            $allResults = @()

            if (-not $userProfiles -or $userProfiles.Count -eq 0) {
                throw "No user profiles found"
            }

            # Initialize progress tracking variables AFTER userProfiles is defined
            $totalUsers = $userProfiles.Count
            $currentUserIndex = 0
        }
        catch {
            if (-not $Quiet) {
                Write-Warning "Error detecting browsers: $($_.Exception.Message)"
            }
            if ($PassThru) { return @() }
            return
        }
        
        # Process browser histories
        foreach ($userProfile in $userProfiles) {
            $currentUserIndex++
            $percentComplete = [math]::Round(($currentUserIndex / $totalUsers) * 80, 0)
            Write-Progress -Id $progressId -Activity "Hunt-Browser Analysis" -Status "Processing user $currentUserIndex of $totalUsers" -PercentComplete $percentComplete
    
            try {
                # Extract username from profile path - handle different path formats
                $userName = "Unknown"
                if ($userProfile -and ![string]::IsNullOrWhiteSpace($userProfile)) {
                    try {
                        $leafName = Split-Path $userProfile.Trim() -Leaf
                        if (![string]::IsNullOrWhiteSpace($leafName)) {
                            $userName = $leafName
                        }
                    }
                    catch {
                        # If Split-Path fails, try manual extraction
                        if ($userProfile -like "*\*") {
                            $lastSlash = $userProfile.LastIndexOf('\')
                            if ($lastSlash -ge 0 -and $lastSlash -lt ($userProfile.Length - 1)) {
                                $userName = $userProfile.Substring($lastSlash + 1)
                            }
                        }
                    }
                }
        
                # Don't sanitize the username too aggressively
                if (![string]::IsNullOrWhiteSpace($userName)) {
                    $userName = $userName.Trim()
                }
                else {
                    $userName = "Unknown"
                }
        
                if (-not $Quiet) {
                    Write-Host "[USER] Processing: $userName" -ForegroundColor Yellow
                }

                foreach ($browser in $browsers) {
                    try {
                        $browserResults = Process-BrowserData -UserProfile $userProfile -UserName $userName -Browser $browser -OutputDir $OutputDir -Timestamp $timestamp -EffectiveMode $effectiveMode -Include $Search -Exclude $Exclude -Truncate $Truncate -Hostname $hostname -Quiet:$Quiet
                
                        if ($browserResults) {
                            if (-not $Quiet) {
                                Write-Host "[FOUND] $($browserResults.Count) entries from $($browser.Name) for $userName" -ForegroundColor Green
                            }
                            $allResults += $browserResults
                        }
                    }
                    catch {
                        if (-not $Quiet) {
                            Write-Warning "Failed $($browser.Name) for $userName (Access Denied - Normal)"
                        }
                        continue
                    }
                }
            }
            catch {
                if (-not $Quiet) {
                    Write-Warning "Failed to process user profile: $userProfile (Access Denied - Normal)"
                }
                continue
            }
        }
        
        # Process DNS logs
        try {
            $dnsResults = Process-DNSLogs -EffectiveMode $effectiveMode -Include $Search -Exclude $Exclude -Truncate $Truncate -Hostname $hostname -Quiet:$Quiet
            if ($dnsResults) {
                $allResults += $dnsResults
            }
        }
        catch {
            if (-not $Quiet) {
                Write-Warning "DNS processing failed: $($_.Exception.Message)"
            }
        }
        
        # Process and display results
        try {
            $uniqueResults = Get-UniqueResults -Results $allResults
            
            if ($uniqueResults -and $uniqueResults.Count -gt 0) {
                # Always show colored output unless -Quiet is specified
                if (-not $Quiet) {
                    Write-Host "[RESULTS] Found $($uniqueResults.Count) unique browser and DNS artifacts" -ForegroundColor Green
        
                    # Group and sort results: User -> Browser -> Count (highest first)
                    $groupedByUser = $uniqueResults | Group-Object User | Sort-Object Name
        
                    foreach ($userGroup in $groupedByUser) {
                        $groupedByBrowser = $userGroup.Group | Group-Object Browser | Sort-Object Name
            
                        foreach ($browserGroup in $groupedByBrowser) {
                            $sortedResults = $browserGroup.Group | Sort-Object Count -Descending
                
                            $sortedResults | ForEach-Object {
                                try {
                                    Write-ColoredBrowserResult $_
                                }
                                catch {
                                    Write-Warning "Failed to display result: $($_.Exception.Message)"
                                }
                            }
                        }
                    }
                }
                
                # Export to CSV if requested
                if ($OutputCSV) {
                    Export-ResultsToCSV -Results $uniqueResults -Path $OutputCSV -Quiet:$Quiet
                }
                
                # Complete progress
                Write-Progress -Id $progressId -Activity "Hunt-Browser Analysis" -Status "Complete" -PercentComplete 100 -Completed
                
                # Return objects based on PassThru parameter
                if ($PassThru) {
                    return $uniqueResults
                }
            }
            else {
                if (-not $Quiet) {
                    Write-Host "`n[INFO] No matching browser or DNS activity detected" -ForegroundColor Green
                }
                
                # Complete progress
                Write-Progress -Id $progressId -Activity "Hunt-Browser Analysis" -Status "Complete - No Results" -PercentComplete 100 -Completed
                
                # Return empty array only if PassThru is specified
                if ($PassThru) {
                    return @()
                }
            }
        }
        catch {
            Write-Error "Failed to process results: $($_.Exception.Message)"
            if ($PassThru) {
                return @()
            }
        }
        
    }
    catch {
        Write-Error "Hunt-Browser failed: $($_.Exception.Message)"
        if ($PassThru) {
            return @()
        }
    }
    finally {
        try {
            Complete-Cleanup -Quiet:$Quiet | out-null
        }
        catch {
            if (-not $Quiet) {
                Write-Warning "Cleanup failed: $($_.Exception.Message)"
            }
        }
    }
}


Function Hunt-Files {
    <#
.SYNOPSIS
Hunt for files and directories on the filesystem based on multiple criteria including timestamps, content, hashes, Search, extensions, and file attributes.

.DESCRIPTION
Hunt-Files is a comprehensive DFIR tool for searching and analyzing files across Windows systems. It supports searching by creation/modification dates, file content, cryptographic hashes, filenames, extensions, alternate data streams, and special attributes like hidden or deleted files. Results can be exported to CSV for further analysis.

.PARAMETER StartDate
Start date for timestamp filtering. Accepts datetime objects, strings, or relative formats (e.g., "3D" for 3 days ago).

.PARAMETER EndDate
End date for timestamp filtering. Defaults to "Now". Accepts same formats as StartDate.

.PARAMETER Extensions
Array of file extensions to search for (e.g., @(".exe", ".dll", ".ps1")).

.PARAMETER Content
Array of content strings to search for within files and alternate data streams.

.PARAMETER Search
Array of filename patterns to search for. Supports wildcards (* and ?).

.PARAMETER Hashes
Array of file hashes (MD5, SHA1, SHA256) to search for.

.PARAMETER MaxSizeMB
Maximum file size in MB to process for content searching. Default is 30MB.

.PARAMETER Timezone
Target timezone for date conversions. Supports common abbreviations (UTC, EST, PST, etc.).

.PARAMETER Path
Specific path to search. If not specified, searches current drive or all drives with -AllDrives.

.PARAMETER AllDrives
Search all available drives instead of just the current drive.

.PARAMETER IncludeSystemFolders
Include Windows system folders (Windows, Program Files) in search.

.PARAMETER Hidden
Search for hidden files and folders.

.PARAMETER Recycled
Search in recycle bin folders exclusively. When specified, only recycle bins are searched regardless of -Path parameter.

.PARAMETER Streams
Search for files with alternate data streams (ADS).

.PARAMETER MaxPrint
Maximum characters to output to console. Use 0 for unlimited.

.PARAMETER Auto
Predefined search modes: 1=Recent executables (3 days), 2=Suspicious files (7 days), 3=Comprehensive (30 days).

.PARAMETER Type
Filter results by type: FILE/F for files only, DIR/DIRECTORY/D for directories only.

.PARAMETER VerboseOutput
Show detailed error messages during processing.

.PARAMETER OutputCSV
Export results to CSV file. Can specify file path or directory (auto-generates filename).

.PARAMETER PassThru
Return PowerShell objects instead of just displaying results.

.PARAMETER Quiet
Suppress console output (useful with -PassThru and -OutputCSV).

.EXAMPLE
Hunt-Files -Search @("malware", "*.exe") -StartDate "2024-01-01"
Search for files containing "malware" in name or with .exe extension since January 1, 2024.

.EXAMPLE
Hunt-Files -Content @("password", "secret") -Hidden -OutputCSV "C:\investigation"
Search hidden files containing "password" or "secret" and export to CSV.

.EXAMPLE
Hunt-Files -Auto 2 -AllDrives -OutputCSV "results.csv" -PassThru | Where-Object {$_.SizeMB -gt 10}
Run predefined suspicious file search across all drives, export to CSV, and return objects for files larger than 10MB.

.EXAMPLE
Hunt-Files -Hashes @("d41d8cd98f00b204e9800998ecf8427e") -Streams -Quiet -PassThru
Silently search for specific hash and files with alternate data streams, returning objects only.

.NOTES
Requires PowerShell 5.0 or later. Administrator privileges recommended for complete filesystem access and system folder searches.
#>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        $StartDate,
    
        [Parameter(Mandatory = $false)]
        $EndDate = "Now",
    
        [Parameter(Mandatory = $false)]
        [string[]]$Extensions = @(),
    
        [Parameter(Mandatory = $false)]
        [string[]]$Content = @(),
    
        [Parameter(Mandatory = $false)]
        [string[]]$Search = @(),
    
        [Parameter(Mandatory = $false)]
        [string[]]$Hashes = @(),
    
        [Parameter(Mandatory = $false)]
        [int]$MaxSizeMB = 30,
    
        [Parameter(Mandatory = $false)]
        [string]$Timezone = "",
    
        [Parameter(Mandatory = $false)]
        [string]$Path = "",
    
        [Parameter(Mandatory = $false)]
        [switch]$AllDrives,
    
        [Parameter(Mandatory = $false)]
        [switch]$IncludeSystemFolders,
    
        [Parameter(Mandatory = $false)]
        [switch]$Hidden,
    
        [Parameter(Mandatory = $false)]
        [switch]$Recycled,
    
        [Parameter(Mandatory = $false)]
        [switch]$Streams,
    
        [Parameter(Mandatory = $false)]
        [int]$MaxPrint = 0,
    
        [Parameter(Mandatory = $false)]
        [switch]$Auto,
    
        [Parameter(Mandatory = $false)]
        [string]$Type = "",
    
        [Parameter(Mandatory = $false)]
        [switch]$VerboseOutput,
    
        [Parameter(Mandatory = $false)]
        [string]$OutputCSV = "",
    
        [Parameter(Mandatory = $false)]
        [switch]$PassThru,
    
        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )

    Write-Progress -Activity "Hunt-Files" -Status "Initializing..." -PercentComplete 0

    # Check for administrator privileges
    $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
    if (-not $isAdmin) {
        Write-Warning "Not running as Administrator, insufficient privileges may cause detection issues..."
    }

    # Auto mode configurations
    if ($Auto) {
        $suspiciousExtensions = @(
            '.exe', '.dll', '.sys', '.scr', '.ocx', '.drv', '.com', '.pif', '.cpl',
            '.ps1', '.psm1', '.ps1xml', '.psc1', '.psd1',
            '.bat', '.cmd', '.vbs', '.vbe', '.js', '.jse', '.wsf', '.wsh', '.hta',
            '.py', '.pyc', '.pyo', '.rb', '.pl', '.php', '.asp', '.aspx', '.jsp',
            '.zip', '.rar', '.7z', '.iso', '.img', '.cab', '.gz', '.tar', '.bz2',
            '.doc', '.docx', '.docm', '.dot', '.dotm', '.xls', '.xlsx', '.xlsm', 
            '.xlt', '.xltm', '.xlam', '.ppt', '.pptx', '.pptm', '.pot', '.potm',
            '.rtf', '.pub', '.one', '.odt', '.ods', '.odp',
            '.jar', '.class', '.war', '.ear',
            '.lnk', '.url', '.website',
            '.inf', '.reg', '.ini', '.xml', '.cfg', '.conf', '.config',
            '.msi', '.msp', '.mst',
            '.tmp', '.temp', '.bin', '.dat', '.log', '.dmp',
            '.db', '.sqlite', '.mdb', '.accdb',
            '.cer', '.crt', '.pem', '.p12', '.pfx', '.key',
            '.application', '.gadget', '.msc', '.ws'
        )
        
        switch ($Auto) {
            1 {
                if (!$StartDate -and $EndDate -eq "Now") {
                    $StartDate = (Get-Date).AddDays(-3)
                    $EndDate = Get-Date
                }
                $Extensions = @('.exe', '.dll', '.ps1', '.js', '.vbs', '.bat', '.cmd', '.scr')
            }
            2 {
                if (!$StartDate -and $EndDate -eq "Now") {
                    $StartDate = (Get-Date).AddDays(-7)
                    $EndDate = Get-Date
                }
                $Extensions = $suspiciousExtensions
                $IncludeSystemFolders = $true
            }
            3 {
                if (!$StartDate -and $EndDate -eq "Now") {
                    $StartDate = (Get-Date).AddDays(-30)
                    $EndDate = Get-Date
                }
                $Extensions = $suspiciousExtensions
                $IncludeSystemFolders = $true
            }
        }
    }

    # Timezone handling
    $systemTimeZone = [System.TimeZoneInfo]::Local
    
    function Get-TimezoneInfo {
        param($TimezoneName)
        
        $timezoneMap = @{
            'UTC' = 'UTC'; 'GMT' = 'GMT Standard Time'
            'EST' = 'Eastern Standard Time'; 'CST' = 'Central Standard Time'
            'MST' = 'Mountain Standard Time'; 'PST' = 'Pacific Standard Time'
            'EDT' = 'Eastern Standard Time'; 'CDT' = 'Central Standard Time'
            'MDT' = 'Mountain Standard Time'; 'PDT' = 'Pacific Standard Time'
        }
        
        $mappedName = if ($timezoneMap.ContainsKey($TimezoneName.ToUpper())) { 
            $timezoneMap[$TimezoneName.ToUpper()] 
        }
        else { 
            $TimezoneName 
        }
        
        try {
            if ($mappedName -eq 'UTC') {
                return [System.TimeZoneInfo]::Utc
            }
            else {
                return [System.TimeZoneInfo]::FindSystemTimeZoneById($mappedName)
            }
        }
        catch {
            throw "Invalid timezone: $TimezoneName"
        }
    }

    $targetTimeZone = if ([string]::IsNullOrWhiteSpace($Timezone)) { 
        $systemTimeZone 
    }
    else { 
        Get-TimezoneInfo -TimezoneName $Timezone 
    }

    # Date conversion function
    function ConvertTo-DateTime {
        param($InputValue, $TargetTimeZone)
        
        if ($InputValue -is [datetime]) {
            if ($TargetTimeZone.Id -ne $systemTimeZone.Id) {
                return [System.TimeZoneInfo]::ConvertTime($InputValue, $TargetTimeZone, $systemTimeZone)
            }
            return $InputValue
        }
        
        if ($InputValue -is [string]) {
            $InputValue = $InputValue.Trim()
            
            if ($InputValue.ToLower() -eq 'now') {
                return Get-Date
            }
            
            # Handle relative time formats (1D, 4H, 10M)
            if ($InputValue -match '^(\d+)([DHMdhm])$') {
                $number = [int]$matches[1]
                $unit = $matches[2].ToUpper()
                
                $currentTime = Get-Date
                switch ($unit) {
                    'D' { return $currentTime.AddDays(-$number) }
                    'H' { return $currentTime.AddHours(-$number) }
                    'M' { return $currentTime.AddMinutes(-$number) }
                }
            }
            
            # Parse regular datetime strings
            try {
                $parsedDate = [datetime]$InputValue
                if ($TargetTimeZone.Id -ne $systemTimeZone.Id) {
                    return [System.TimeZoneInfo]::ConvertTime($parsedDate, $TargetTimeZone, $systemTimeZone)
                }
                return $parsedDate
            }
            catch {
                throw "Invalid date format: $InputValue"
            }
        }
        
        throw "Invalid date input: $InputValue"
    }

    # Datetime formatting function
    function Format-DateTimeWithTimeZone {
        param($DateTime, $TargetTimeZone)
        
        if ($TargetTimeZone.Id -eq $systemTimeZone.Id) {
            $convertedTime = $DateTime
            $tzAbbrev = Get-TimezoneAbbreviation -TimeZone $systemTimeZone -DateTime $DateTime
        }
        else {
            $convertedTime = [System.TimeZoneInfo]::ConvertTime($DateTime, $systemTimeZone, $TargetTimeZone)
            $tzAbbrev = Get-TimezoneAbbreviation -TimeZone $TargetTimeZone -DateTime $convertedTime
        }
        
        return $convertedTime.ToString("yyyy-MM-dd HH:mm:ss") + " $tzAbbrev"
    }

    # Timezone abbreviation function
    function Get-TimezoneAbbreviation {
        param($TimeZone, $DateTime)
        
        if ($TimeZone.Id -eq 'UTC') { 
            return 'UTC' 
        }
        
        $isDST = $TimeZone.IsDaylightSavingTime($DateTime)
        
        if ($TimeZone.StandardName -like "*Eastern*") { 
            if ($isDST) { return 'EDT' } else { return 'EST' }
        }
        elseif ($TimeZone.StandardName -like "*Central*") { 
            if ($isDST) { return 'CDT' } else { return 'CST' }
        }
        elseif ($TimeZone.StandardName -like "*Mountain*") { 
            if ($isDST) { return 'MDT' } else { return 'MST' }
        }
        elseif ($TimeZone.StandardName -like "*Pacific*") { 
            if ($isDST) { return 'PDT' } else { return 'PST' }
        }
        else { 
            return $TimeZone.StandardName.Split(' ')[0] 
        }
    }


    # CSV sanitization function
    function Sanitize-CSVValue {
        param($Value)

        if ($null -eq $Value) { return "" }

        $stringValue = $Value.ToString()

        # Truncate if too long for Excel (32,767 character limit per cell)
        if ($stringValue.Length -gt 32000) {
            $stringValue = $stringValue.Substring(0, 32000) + "...[TRUNCATED]"
        }

        # Remove or escape problematic characters
        $stringValue = $stringValue -replace '"', '""'  # Escape quotes
        $stringValue = $stringValue -replace '^=', "'="  # Prevent formula injection
        $stringValue = $stringValue -replace '^@', "'@"  # Prevent formula injection
        $stringValue = $stringValue -replace '^\+', "'+"  # Prevent formula injection
        $stringValue = $stringValue -replace '^-', "'-"  # Prevent formula injection
        $stringValue = $stringValue -replace '\r\n|\r|\n', ' '  # Replace line breaks
        $stringValue = $stringValue -replace '\t', ' '  # Replace tabs

        return $stringValue
    }

    # Stream handling function - optimized for PS5+
    function Get-FileStreams {
        param($FilePath)
        
        $streams = @()
        try {
            if ($PSVersionTable.PSVersion.Major -ge 5) {
                $allStreams = @(Get-Item -Path $FilePath -Stream * -ErrorAction SilentlyContinue)
                foreach ($stream in $allStreams) {
                    if ($stream.Stream -ne ':$DATA') {
                        $streams += [PSCustomObject]@{
                            StreamName = $stream.Stream
                            Size       = $stream.Length
                        }
                    }
                }
            }
        }
        catch {
            # Return empty if we can't get streams
        }
        return $streams
    }

    # Content matching function - optimized
    function Get-ContentFromFile {
        param($FilePath, $StreamName = '', $MaxSize)
        
        try {
            $streamPath = if ([string]::IsNullOrEmpty($StreamName) -or $StreamName -eq ':$DATA') {
                $FilePath
            }
            else {
                "${FilePath}:${StreamName}"
            }
            
            $fileInfo = Get-Item -Path $FilePath -Force -ErrorAction Stop
            if ($fileInfo.Length -gt $MaxSize -or $fileInfo.Length -eq 0) { 
                return '' 
            }
            
            $content = Get-Content -Path $streamPath -Raw -Encoding UTF8 -ErrorAction Stop
            return $content
        }
        catch {
            return ''
        }
    }

    # Hash computation function - optimized
    function Get-FileHashCustom {
        param($FilePath, $StreamName = '', $Algorithm)
        
        try {
            $streamPath = if ([string]::IsNullOrEmpty($StreamName) -or $StreamName -eq ':$DATA') {
                $FilePath
            }
            else {
                "${FilePath}:${StreamName}"
            }
            
            $hash = Get-FileHash -Path $streamPath -Algorithm $Algorithm -ErrorAction Stop
            return $hash.Hash.ToLower()
        }
        catch {
            return ""
        }
    }

    # LNK shortcut resolution function
    function Get-LnkTarget {
        param($LnkPath)
        
        try {
            $shell = New-Object -ComObject WScript.Shell
            $shortcut = $shell.CreateShortcut($LnkPath)
            $targetPath = $shortcut.TargetPath
            
            # Release COM object
            [System.Runtime.Interopservices.Marshal]::ReleaseComObject($shell) | Out-Null
            
            if (![string]::IsNullOrWhiteSpace($targetPath) -and (Test-Path $targetPath -ErrorAction SilentlyContinue)) {
                return $targetPath
            }
            return ""
        }
        catch {
            return ""
        }
    }

    # Signature verification function
    function Get-FileSignatureInfo {
        param($FilePath)
        
        try {
            # Get signature for all files - let Get-AuthenticodeSignature determine if applicable
            $signature = Get-AuthenticodeSignature -FilePath $FilePath -ErrorAction Stop
            
            if ($null -eq $signature) {
                return ""
            }
            
            # Check signature status
            switch ($signature.Status) {
                'NotSigned' {
                    return "[NOT_SIGNED]"
                }
                'Valid' {
                    if ($null -ne $signature.SignerCertificate) {
                        $subject = $signature.SignerCertificate.Subject -replace 'CN=', '' -replace ',.*$', ''
                        $issuer = $signature.SignerCertificate.Issuer -replace 'CN=', '' -replace ',.*$', ''
                        $expires = $signature.SignerCertificate.NotAfter.ToString("MM-dd-yyyy")
                        
                        # Check if expired
                        if ($signature.SignerCertificate.NotAfter -lt (Get-Date)) {
                            return "[VALID_EXPIRED] Subject: $subject, Issuer: $issuer, Expires: $expires"
                        }
                        else {
                            return "[VALID] Subject: $subject, Issuer: $issuer, Expires: $expires"
                        }
                    }
                    else {
                        return "[VALID] No certificate details available"
                    }
                }
                'UnknownError' {
                    return "[UNKNOWN_ERROR] Unable to verify signature"
                }
                'NotSupportedFileFormat' {
                    # Return empty string for unsupported formats - won't display
                    return ""
                }
                'HashMismatch' {
                    return "[INVALID] Hash mismatch - file may be tampered"
                }
                'NotTrusted' {
                    if ($null -ne $signature.SignerCertificate) {
                        $subject = $signature.SignerCertificate.Subject -replace 'CN=', '' -replace ',.*$', ''
                        $issuer = $signature.SignerCertificate.Issuer -replace 'CN=', '' -replace ',.*$', ''
                        $expires = $signature.SignerCertificate.NotAfter.ToString("MM-dd-yyyy")
                        return "[NOT_TRUSTED] Subject: $subject, Issuer: $issuer, Expires: $expires"
                    }
                    else {
                        return "[NOT_TRUSTED] Certificate not trusted"
                    }
                }
                'Incompatible' {
                    return "[INCOMPATIBLE] Signature incompatible with this system"
                }
                default {
                    # For any other status, return empty (won't display)
                    return ""
                }
            }
        }
        catch {
            # Silently handle errors - return empty string
            return ""
        }
    }

    Write-Progress -Activity "Hunt-Files" -Status "Validating parameters..." -PercentComplete 10

    # Parameter validation
    if ($MaxSizeMB -le 0) {
        Write-Error "MaxSizeMB must be greater than 0"
        return
    }

    # Normalize Type parameter - now case insensitive
    $filterType = ""
    if (![string]::IsNullOrWhiteSpace($Type)) {
        switch ($Type.ToUpper()) {
            { $_ -in @("FILE", "F") } { $filterType = "FILE" }
            { $_ -in @("DIR", "DIRECTORY", "D") } { $filterType = "DIR" }
            default { 
                Write-Error "Invalid Type parameter. Valid values: FILE, F, DIR, DIRECTORY, D (case insensitive)"
                return
            }
        }
    }

    # Determine search paths
    if ([string]::IsNullOrWhiteSpace($Path)) {
        if ($AllDrives) {
            try {
                $searchPaths = @(Get-PSDrive -PSProvider FileSystem -ErrorAction Stop | Where-Object { $_.Used -ge 0 } | ForEach-Object { $_.Root })
            }
            catch {
                Write-Error "Failed to get drive information: $($_.Exception.Message)"
                return
            }
        }
        else {
            $searchPaths = @("$((Get-Location).Drive.Name):\")
        }
    }
    else {
        $searchPath = $Path.TrimEnd('\')
        if (-not (Test-Path $searchPath)) {
            Write-Error "Specified path does not exist: $searchPath"
            return
        }
        $searchPaths = @($searchPath)
    }

    # Date range handling - simplified logic
    $hasDateRange = $null -ne $StartDate -or $EndDate -ne "Now"
    $hasOtherCriteria = $Extensions.Count -gt 0 -or $Content.Count -gt 0 -or $Search.Count -gt 0 -or $Hashes.Count -gt 0 -or $Hidden -or $Recycled -or $Streams -or $Auto

    # Only enforce date requirements in Auto mode
    if ($Auto -and !$hasDateRange) {
        # Auto mode sets its own dates, this is already handled above
    }
    elseif ($null -ne $StartDate -and $EndDate -eq "Now") {
        $EndDate = Get-Date
    }
    elseif ($null -eq $StartDate -and $EndDate -ne "Now") {
        throw "EndDate specified but StartDate is missing. Please provide both dates or neither."
    }

    # Convert dates
    $parsedStartDate = $null
    $parsedEndDate = $null

    if ($hasDateRange) {
        try {
            $parsedStartDate = if ($null -ne $StartDate) { ConvertTo-DateTime -InputValue $StartDate -TargetTimeZone $targetTimeZone } else { $null }
            $parsedEndDate = if ($EndDate -ne "Now") { ConvertTo-DateTime -InputValue $EndDate -TargetTimeZone $targetTimeZone } else { ConvertTo-DateTime -InputValue $EndDate -TargetTimeZone $targetTimeZone }
        }
        catch {
            throw "Date parsing error: $($_.Exception.Message)"
        }
    }
    
    # If no criteria specified, treat as "return all files"
    $hasSearchCriteria = $null -ne $parsedStartDate -or $null -ne $parsedEndDate -or $Extensions.Count -gt 0 -or $Content.Count -gt 0 -or $Search.Count -gt 0 -or $Hashes.Count -gt 0 -or $Auto -or $Hidden -or $Recycled -or $Streams
    
    # Set a flag for "match everything" mode
    $matchEverything = -not $hasSearchCriteria

    Write-Progress -Activity "Hunt-Files" -Status "Processing criteria..." -PercentComplete 20

    # Normalize search criteria
    $normalizedHashes = @{}
    foreach ($hash in $Hashes) {
        try {
            $cleanHash = $hash.Trim().ToLower() -replace '[^a-f0-9]', ''
            $hashType = switch ($cleanHash.Length) {
                32 { 'MD5' }
                40 { 'SHA1' }
                64 { 'SHA256' }
                default { 
                    Write-Warning "Invalid hash format: $hash"
                    continue 
                }
            }
            $normalizedHashes[$cleanHash] = $hashType
        }
        catch {
            Write-Warning "Error processing hash '$hash': $($_.Exception.Message)"
        }
    }

    # Normalize extensions and Search - use HashSet for faster lookups
    $extensionSet = $null
    if ($Extensions.Count -gt 0) {
        $Extensions = @($Extensions | ForEach-Object { 
                $ext = $_.ToLower().Trim()
                if (-not $ext.StartsWith('.')) { ".$ext" } else { $ext }
            })
        $extensionSet = [System.Collections.Generic.HashSet[string]]::new([StringComparer]::OrdinalIgnoreCase)
        foreach ($ext in $Extensions) {
            [void]$extensionSet.Add($ext)
        }
    }

    if ($Search.Count -gt 0) {
        $Search = @($Search | ForEach-Object { $_.Trim() })
    }

    $maxSizeBytes = [long]$MaxSizeMB * 1MB
    $systemFolders = @("$env:windir", "$env:ProgramFiles", "${env:ProgramFiles(x86)}")

    # Initialize counters and pre-allocate results collection for performance
    $filesMatched = 0
    $foldersMatched = 0
    $streamMatches = 0
    $totalStreamsFound = 0
    $results = [System.Collections.ArrayList]::new()
    $totalOutputChars = 0

    Write-Progress -Activity "Hunt-Files" -Status "Scanning filesystem..." -PercentComplete 50

    # Main scanning loop - optimized
    foreach ($currentSearchPath in $searchPaths) {
        try {
            $searchSubPaths = @()
            
            # If -Recycled is specified, ONLY search recycle bin paths
            if ($Recycled) {
                $driveLetter = $currentSearchPath.Substring(0, 1)
                $recycleBinPaths = @("${driveLetter}:\`$Recycle.Bin", "${driveLetter}:\RECYCLER")
                $searchSubPaths = @($recycleBinPaths | Where-Object { Test-Path $_ })
            
                if ($searchSubPaths.Count -eq 0) {
                    Write-Warning "No recycle bin found on drive ${driveLetter}:"
                    continue
                }
            }
            else {
                # Normal search path
                $searchSubPaths = @($currentSearchPath)
            }

            foreach ($subPath in $searchSubPaths) {
                try {
                    # Optimized file enumeration - use Filter parameter when possible
                    try {
                        # Get all items first (fastest approach - no pipeline filtering)
                        $pathItems = @(Get-ChildItem -Path $subPath -Recurse -Force -ErrorAction SilentlyContinue)
                        
                        # Apply date filter in memory if specified (faster than pipeline Where-Object)
                        if ($null -ne $parsedStartDate -and $null -ne $parsedEndDate) {
                            $filteredItems = [System.Collections.ArrayList]::new($pathItems.Count)
                            foreach ($item in $pathItems) {
                                if (($item.LastWriteTime -ge $parsedStartDate -and $item.LastWriteTime -le $parsedEndDate) -or
                                    ($item.CreationTime -ge $parsedStartDate -and $item.CreationTime -le $parsedEndDate) -or
                                    ($item.LastAccessTime -ge $parsedStartDate -and $item.LastAccessTime -le $parsedEndDate)) {
                                    [void]$filteredItems.Add($item)
                                }
                            }
                            $pathItems = $filteredItems.ToArray()
                        }
                    }
                    catch {
                        if ($VerboseOutput) {
                            Write-Warning "Error enumerating path $subPath : $($_.Exception.Message)"
                        }
                        continue
                    }
                    # Skip recycle bin metadata files ($I files) - we only need $R files
                    if ($Recycled) {
                        $pathItems = @($pathItems | Where-Object { $_.Name -notlike '$I*' })
                    }
                        
                    # Filter out system folders if not included - optimized check
                    if (-not $IncludeSystemFolders -and -not $Recycled) {
                        $filteredItems = [System.Collections.ArrayList]::new($pathItems.Count)
                        foreach ($item in $pathItems) {
                            $itemPath = $item.FullName
                            $isSystemFolder = $false
                            foreach ($sysFolder in $systemFolders) {
                                if ($itemPath.StartsWith($sysFolder, [System.StringComparison]::OrdinalIgnoreCase)) {
                                    $isSystemFolder = $true
                                    break
                                }
                            }
                            if (-not $isSystemFolder) {
                                [void]$filteredItems.Add($item)
                            }
                        }
                        $pathItems = $filteredItems.ToArray()
                    }

                    foreach ($item in $pathItems) {
                        try {
                            $isDirectory = $item.PSIsContainer
                            $itemMatchReasons = @()
                            $matchedContent = @()
                            $matchedNames = @()
                            $sha256 = ""
                            $streamInfo = ""
                            $alternateStreams = @()

                            # Check attributes - optimized
                            $itemIsHidden = ($item.Attributes -band [System.IO.FileAttributes]::Hidden) -ne 0
                            $itemIsRecycleBin = ($item.FullName -like "*`$Recycle.Bin*" -or $item.FullName -like "*RECYCLER*")

                            # Get streams only when needed
                            if (-not $isDirectory -and ($Streams -or $Content.Count -gt 0)) {
                                try {
                                    $alternateStreams = @(Get-FileStreams -FilePath $item.FullName)
                                    $totalStreamsFound += $alternateStreams.Count
                                }
                                catch {
                                    # Continue if we can't get stream info
                                }
                            }

                            # Special switches - additive logic
                            $specialSwitchMatch = $false

                            if ($Hidden -and $itemIsHidden) {
                                $itemMatchReasons += "Hidden"
                                $specialSwitchMatch = $true
                            }

                            if ($Recycled -and $itemIsRecycleBin) {
                                $itemMatchReasons += "Deleted"
                                $specialSwitchMatch = $true
                            }

                            if ($Streams -and -not $isDirectory -and $alternateStreams.Count -gt 0) {
                                $streamNames = ($alternateStreams | ForEach-Object { $_.StreamName }) -join ','
                                $itemMatchReasons += "ADS:$streamNames"
                                $streamMatches++
                                $specialSwitchMatch = $true
                                    
                                $streamDetails = @()
                                foreach ($stream in $alternateStreams) {
                                    $streamDetails += "$($stream.StreamName)($($stream.Size) bytes)"
                                }
                                $streamInfo = $streamDetails -join ';'
                            }

                            # Regular search criteria
                            # Date range matching - optimized with null checks
                            if ($null -ne $parsedStartDate -and $null -ne $parsedEndDate) {
                                $dateMatches = @()
                                
                                try {
                                    if ($null -ne $item.CreationTime -and $item.CreationTime -ge $parsedStartDate -and $item.CreationTime -le $parsedEndDate) {
                                        $dateMatches += "Created"
                                    }
                                    if ($null -ne $item.LastWriteTime -and $item.LastWriteTime -ge $parsedStartDate -and $item.LastWriteTime -le $parsedEndDate) {
                                        $dateMatches += "Modified"
                                    }
                                    if ($null -ne $item.LastAccessTime -and $item.LastAccessTime -ge $parsedStartDate -and $item.LastAccessTime -le $parsedEndDate) {
                                        $dateMatches += "Accessed"
                                    }
                                }
                                catch {
                                    # Skip items with invalid datetime properties
                                }
                                        
                                if ($dateMatches.Count -gt 0) {
                                    $itemMatchReasons += "Date:$($dateMatches -join '/')"
                                }
                            }

                            # Name matching - fixed wildcard support
                            if ($Search.Count -gt 0) {
                                $fileName = $item.Name
                                $matchedNames = @()
    
                                foreach ($pattern in $Search) {
                                    # If pattern contains wildcards, use as-is, otherwise add implicit wildcards
                                    $searchPattern = if ($pattern -match '[*?]') { 
                                        $pattern 
                                    }
                                    else { 
                                        "*$pattern*" 
                                    }
        
                                    if ($fileName -like $searchPattern) {
                                        $matchedNames += $pattern
                                    }
                                }
    
                                if ($matchedNames.Count -gt 0) {
                                    $itemMatchReasons += "Name:$($matchedNames -join ',')"
                                    $matchedNames = $matchedNames  # Store for potential separate display
                                }
                            }

                            # Extension matching - optimized with HashSet
                            if ($null -ne $extensionSet -and -not $isDirectory) {
                                $itemExt = $item.Extension.ToLower()
                                if ($extensionSet.Contains($itemExt)) {
                                    $itemMatchReasons += "Ext:$itemExt"
                                }
                            }

                            # Content matching - check file size first for performance
                            if ($Content.Count -gt 0 -and -not $isDirectory -and $null -ne $item.Length -and $item.Length -le $maxSizeBytes -and $item.Length -gt 0) {
                                $allStreamMatches = @()
    
                                try {
                                    # Check main stream
                                    $fileContent = Get-ContentFromFile -FilePath $item.FullName -MaxSize $maxSizeBytes
                                    if (![string]::IsNullOrEmpty($fileContent)) {
                                        $mainStreamMatches = @($Content | Where-Object { 
                                                try { $fileContent -like "*$_*" } catch { $false }
                                            })
                                        if ($mainStreamMatches.Count -gt 0) {
                                            $allStreamMatches += $mainStreamMatches | ForEach-Object { "$_(:DATA)" }
                                        }
                                    }
        
                                    # Check alternate streams
                                    foreach ($stream in $alternateStreams) {
                                        if ($stream.Size -le $maxSizeBytes -and $stream.Size -gt 0) {
                                            try {
                                                $streamContent = Get-ContentFromFile -FilePath $item.FullName -StreamName $stream.StreamName -MaxSize $maxSizeBytes
                                                if (![string]::IsNullOrEmpty($streamContent)) {
                                                    $streamContentMatches = @($Content | Where-Object { 
                                                            try { $streamContent -like "*$_*" } catch { $false }
                                                        })
                                                    if ($streamContentMatches.Count -gt 0) {
                                                        $allStreamMatches += $streamContentMatches | ForEach-Object { "$_($($stream.StreamName))" }
                                                    }
                                                }
                                            }
                                            catch {
                                                if ($VerboseOutput) {
                                                    Write-Warning "Error reading stream $($stream.StreamName) from $($item.FullName): $($_.Exception.Message)"
                                                }
                                            }
                                        }
                                    }
        
                                    if ($allStreamMatches.Count -gt 0) {
                                        $itemMatchReasons += "Content:$($allStreamMatches -join ',')"
                                        $matchedContent = $allStreamMatches
                                    }
                                }
                                catch {
                                    if ($VerboseOutput) {
                                        Write-Warning "Error during content search for $($item.FullName): $($_.Exception.Message)"
                                    }
                                }
                            }

                            # Hash matching - optimized
                            if ($normalizedHashes.Count -gt 0 -and -not $isDirectory) {
                                $hashMatches = @()
                                        
                                try {
                                    # Check main stream
                                    foreach ($hashEntry in $normalizedHashes.GetEnumerator()) {
                                        $targetHash = $hashEntry.Key
                                        $algo = $hashEntry.Value
                
                                        $computedHash = Get-FileHashCustom -FilePath $item.FullName -Algorithm $algo
                                        if (![string]::IsNullOrEmpty($computedHash) -and $computedHash -eq $targetHash) {
                                            $hashMatches += "$algo($targetHash):DATA"
                                            # If we computed SHA256, save it
                                            if ($algo -eq 'SHA256') {
                                                $sha256 = $computedHash
                                            }
                                        }
                                    }
                                            
                                    # Check alternate streams
                                    foreach ($stream in $alternateStreams) {
                                        foreach ($hashEntry in $normalizedHashes.GetEnumerator()) {
                                            $targetHash = $hashEntry.Key
                                            $algo = $hashEntry.Value
                                                    
                                            $computedHash = Get-FileHashCustom -FilePath $item.FullName -StreamName $stream.StreamName -Algorithm $algo
                                            if (![string]::IsNullOrEmpty($computedHash) -and $computedHash -eq $targetHash) {
                                                $hashMatches += "$algo($targetHash):$($stream.StreamName)"
                                            }
                                        }
                                    }
                                            
                                    if ($hashMatches.Count -gt 0) {
                                        $itemMatchReasons += "Hash:$($hashMatches -join ',')"
                                    }
                                }
                                catch {
                                    # Skip files we can't hash
                                }
                            }                            

                            # Include item if any criteria matched OR if in match-everything mode
                            if ($itemMatchReasons.Count -gt 0 -or $specialSwitchMatch -or $matchEverything) {
                                if ($isDirectory) {
                                    $foldersMatched++
                                }
                                else {
                                    $filesMatched++
                                    # Compute SHA256 for files if not done yet (only once) - skip files over 100MB for performance
                                    if ([string]::IsNullOrEmpty($sha256) -and $null -ne $item.Length -and $item.Length -le 100MB) {
                                        try {
                                            $sha256 = Get-FileHashCustom -FilePath $item.FullName -Algorithm 'SHA256'
                                        }
                                        catch {
                                            # Skip if can't compute hash
                                        }
                                    }
                                }                                    
                                # Handle LNK files
                                $lnkTarget = ""
                                $lnkTargetHash = ""
                                if (-not $isDirectory -and $item.Extension.ToLower() -eq '.lnk') {
                                    try {
                                        $lnkTarget = Get-LnkTarget -LnkPath $item.FullName
                                        if (![string]::IsNullOrWhiteSpace($lnkTarget)) {
                                            $lnkTargetHash = Get-FileHashCustom -FilePath $lnkTarget -Algorithm 'SHA256'
                                        }
                                    }
                                    catch {
                                        # Continue if LNK resolution fails
                                    }
                                }
                                
                                # Get signature information for files only
                                $signatureInfo = ""
                                if (-not $isDirectory) {
                                    try {
                                        $signatureInfo = Get-FileSignatureInfo -FilePath $item.FullName
                                    }
                                    catch {
                                        $signatureInfo = "[UNKNOWN_ERROR] Unable to check signature"
                                    }
                                }
                                
                                $result = [PSCustomObject]@{
                                    FullPath             = $item.FullName
                                    Name                 = $item.Name
                                    IsDirectory          = $isDirectory
                                    SizeMB               = if ($isDirectory) { 0 } elseif ($null -eq $item.Length) { 0 } else { [math]::Round($item.Length / 1MB, 4) }
                                    CreationTime         = $item.CreationTime
                                    LastWriteTime        = $item.LastWriteTime
                                    LastAccessTime       = $item.LastAccessTime
                                    SHA256               = $sha256
                                    Signature            = $signatureInfo
                                    MatchReason          = ($itemMatchReasons -join " | ")
                                    MatchedContent       = ($matchedContent -join ', ')
                                    MatchedNames         = ($matchedNames -join ', ')
                                    IsHidden             = $itemIsHidden
                                    IsRecycleBin         = $itemIsRecycleBin
                                    StreamInfo           = $streamInfo
                                    AlternateStreamCount = $alternateStreams.Count
                                    LnkTarget            = $lnkTarget
                                    LnkTargetSHA256      = $lnkTargetHash
                                }

                                [void]$results.Add($result)
                            }
                        }
                        catch {
                            if ($VerboseOutput) {
                                Write-Warning "Error processing item $($item.FullName): $($_.Exception.Message)"
                            }
                        }
                    }
                }
                catch {
                    if ($VerboseOutput) {
                        Write-Warning "Error accessing path $subPath : $($_.Exception.Message)"
                    }
                }
            }
        }
        catch {
            if ($VerboseOutput) {
                Write-Warning "Error accessing path $currentSearchPath : $($_.Exception.Message)"
            }
        }
    }
    

    Write-Progress -Activity "Hunt-Files" -Status "Displaying results..." -PercentComplete 80

    # Convert ArrayList to array and sort results
    $resultsArray = if ($results.Count -gt 0) { $results.ToArray() } else { @() }
    $sortedResults = @($resultsArray | Sort-Object LastWriteTime -Descending)

    # Apply Type filter before displaying results
    if (![string]::IsNullOrWhiteSpace($filterType)) {
        if ($filterType -eq "FILE") {
            $sortedResults = @($sortedResults | Where-Object { -not $_.IsDirectory })
        }
        elseif ($filterType -eq "DIR") {
            $sortedResults = @($sortedResults | Where-Object { $_.IsDirectory })
        }
    }

    # Display results only if not -Quiet
    if (-not $Quiet) {
        foreach ($result in $sortedResults) {
            $streamInfoSize = if (![string]::IsNullOrEmpty($result.StreamInfo)) { $result.StreamInfo.Length } else { 0 }
            $eventOutputSize = 500 + $result.FullPath.Length + $result.MatchReason.Length + $result.MatchedContent.Length + $streamInfoSize
        
            if ($MaxPrint -gt 0 -and ($totalOutputChars + $eventOutputSize -gt $MaxPrint)) {
                $remainingResults = $sortedResults.Count - ([array]::IndexOf($sortedResults, $result))
                Write-Host ""
                Write-Host "Output truncated: MaxPrint limit ($MaxPrint characters) reached. $remainingResults more items available." -ForegroundColor DarkRed
                break
            }

            $totalOutputChars += $eventOutputSize

            $itemType = if ($result.IsDirectory) { "[DIR]" } else { "[FILE]" }

            Write-Host ""
            Write-Host "----------------------------------------" -ForegroundColor Gray
            Write-Host "Type         : " -ForegroundColor Yellow -NoNewline
            Write-Host "$itemType" -ForegroundColor DarkYellow
            Write-Host "Path         : " -ForegroundColor Yellow -NoNewline
            Write-Host "$($result.FullPath)" -ForegroundColor Cyan
            Write-Host "Name         : " -ForegroundColor Yellow -NoNewline
            Write-Host "$($result.Name)" -ForegroundColor White
        
            if (-not $result.IsDirectory) {
                Write-Host "Size         : " -ForegroundColor Yellow -NoNewline
                Write-Host "$($result.SizeMB) MB" -ForegroundColor White
            }
        
            Write-Host "Created      : " -ForegroundColor Yellow -NoNewline
            try {
                Write-Host "$(Format-DateTimeWithTimeZone -DateTime $result.CreationTime -TargetTimeZone $targetTimeZone)" -ForegroundColor White
            }
            catch {
                Write-Host "[Invalid DateTime]" -ForegroundColor DarkRed
            }
            Write-Host "Modified     : " -ForegroundColor Yellow -NoNewline
            try {
                Write-Host "$(Format-DateTimeWithTimeZone -DateTime $result.LastWriteTime -TargetTimeZone $targetTimeZone)" -ForegroundColor White
            }
            catch {
                Write-Host "[Invalid DateTime]" -ForegroundColor DarkRed
            }
            Write-Host "Accessed     : " -ForegroundColor Yellow -NoNewline
            try {
                Write-Host "$(Format-DateTimeWithTimeZone -DateTime $result.LastAccessTime -TargetTimeZone $targetTimeZone)" -ForegroundColor White
            }
            catch {
                Write-Host "[Invalid DateTime]" -ForegroundColor DarkRed
            }
        
            if (-not $result.IsDirectory -and ![string]::IsNullOrWhiteSpace($result.SHA256)) {
                Write-Host "SHA256       : " -ForegroundColor Yellow -NoNewline
                Write-Host "$($result.SHA256)" -ForegroundColor Gray
            }

            # Display signature information
            if (-not $result.IsDirectory -and ![string]::IsNullOrWhiteSpace($result.Signature)) {
                $sigValue = $result.Signature
                $sigColor = "Gray"  # Default color
                
                # Determine color based on signature status
                if ($sigValue.StartsWith("[VALID_EXPIRED]")) {
                    $sigColor = "DarkYellow"
                }
                elseif ($sigValue.StartsWith("[VALID]")) {
                    $sigColor = "Green"
                }
                elseif ($sigValue.StartsWith("[NOT_SIGNED]")) {
                    $sigColor = "DarkYellow"
                }
                elseif ($sigValue.StartsWith("[INVALID]")) {
                    $sigColor = "Red"
                }
                elseif ($sigValue.StartsWith("[NOT_TRUSTED]")) {
                    $sigColor = "DarkYellow"
                }
                elseif ($sigValue.StartsWith("[UNKNOWN")) {
                    $sigColor = "Gray"
                }
                elseif ($sigValue.StartsWith("[INCOMPATIBLE]")) {
                    $sigColor = "DarkRed"
                }
                
                # Print with colors
                Write-Host "Signature    : " -ForegroundColor Yellow -NoNewline
                Write-Host $sigValue -ForegroundColor $sigColor
            }

            if (![string]::IsNullOrWhiteSpace($result.LnkTarget)) {
                Write-Host "LNK Target   : " -ForegroundColor Yellow -NoNewline
                Write-Host "$($result.LnkTarget)" -ForegroundColor Magenta
                if (![string]::IsNullOrWhiteSpace($result.LnkTargetSHA256)) {
                    Write-Host "Target SHA256: " -ForegroundColor Yellow -NoNewline
                    Write-Host "$($result.LnkTargetSHA256)" -ForegroundColor Gray
                }
            }
            
            if (![string]::IsNullOrWhiteSpace($result.MatchReason)) {
                Write-Host "Match        : " -ForegroundColor Yellow -NoNewline
                Write-Host "$($result.MatchReason)" -ForegroundColor Red
            }
        
            if (![string]::IsNullOrWhiteSpace($result.MatchedContent)) {
                Write-Host "Content Match: " -ForegroundColor Yellow -NoNewline
                Write-Host "$($result.MatchedContent)" -ForegroundColor Green
            }
        
            # In the display section, only show "Name Match" if there are other match reasons too
            if (![string]::IsNullOrWhiteSpace($result.MatchedNames)) {
                # Only show separate Name Match if there are other match reasons besides name
                $matchReasons = $result.MatchReason -split ' \| '
                $hasOtherReasons = $matchReasons | Where-Object { $_ -notlike 'Name:*' }
                if ($hasOtherReasons) {
                    Write-Host "Name Match   : " -ForegroundColor Yellow -NoNewline
                    Write-Host "$($result.MatchedNames)" -ForegroundColor Green
                }
            }
        
            # Show stream information
            if ($result.AlternateStreamCount -gt 0) {
                Write-Host "Streams [$($result.AlternateStreamCount)]  : " -ForegroundColor Yellow -NoNewline
                Write-Host "$($result.StreamInfo)" -ForegroundColor Green
            }
        
            # Show special attributes
            $attributes = @()
            if ($result.IsHidden) { $attributes += "Hidden" }
            if ($result.IsRecycleBin) { $attributes += "Recycle Bin" }
            if ($attributes.Count -gt 0) {
                Write-Host "Attributes   : " -ForegroundColor Yellow -NoNewline
                Write-Host "$($attributes -join ', ')" -ForegroundColor DarkYellow
            }
        }
    }    
    
    Write-Progress -Activity "Hunt-Files" -Status "Complete" -PercentComplete 100

    if (-not $Quiet) {
        Write-Progress -Activity "Hunt-Files" -Status "Complete" -PercentComplete 100
    }

    # CSV Export
    if (![string]::IsNullOrWhiteSpace($OutputCSV)) {
        try {
            # Determine CSV path first
            $csvPath = ""
            if (Test-Path $OutputCSV -PathType Container -ErrorAction SilentlyContinue) {
                $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
                $csvPath = Join-Path $OutputCSV "Hunt-Files_Results_$timestamp.csv"
            }
            elseif ($OutputCSV.EndsWith('.csv')) {
                $csvPath = $OutputCSV
            }
            else {
                $csvPath = "$OutputCSV.csv"
            }

            # Ensure we have a valid path
            if ([string]::IsNullOrWhiteSpace($csvPath)) {
                throw "Unable to determine CSV output path"
            }

            # Create directory if it doesn't exist
            try {
                $csvDirectory = Split-Path $csvPath -Parent
                if (![string]::IsNullOrEmpty($csvDirectory) -and !(Test-Path $csvDirectory)) {
                    New-Item -Path $csvDirectory -ItemType Directory -Force | Out-Null
                }
            }
            catch {
                throw "Unable to create CSV output directory: $($_.Exception.Message)"
            }
        
            # Prepare CSV data with defensive datetime handling
            $csvData = @()
            foreach ($result in $sortedResults) {
                # Safely format datetime fields
                $createdTime = try { 
                    Format-DateTimeWithTimeZone -DateTime $result.CreationTime -TargetTimeZone $targetTimeZone 
                }
                catch { 
                    "[Invalid DateTime]" 
                }
                $modifiedTime = try { 
                    Format-DateTimeWithTimeZone -DateTime $result.LastWriteTime -TargetTimeZone $targetTimeZone 
                }
                catch { 
                    "[Invalid DateTime]" 
                }
                $accessedTime = try { 
                    Format-DateTimeWithTimeZone -DateTime $result.LastAccessTime -TargetTimeZone $targetTimeZone 
                }
                catch { 
                    "[Invalid DateTime]" 
                }
                
                $csvData += [PSCustomObject]@{
                    Type                 = if ($result.IsDirectory) { "Directory" } else { "File" }
                    FullPath             = Sanitize-CSVValue $result.FullPath
                    Name                 = Sanitize-CSVValue $result.Name
                    SizeMB               = $result.SizeMB
                    CreationTime         = $createdTime
                    LastWriteTime        = $modifiedTime
                    LastAccessTime       = $accessedTime
                    SHA256               = Sanitize-CSVValue $result.SHA256
                    Signature            = Sanitize-CSVValue $result.Signature
                    MatchReason          = Sanitize-CSVValue $result.MatchReason
                    MatchedContent       = Sanitize-CSVValue $result.MatchedContent
                    MatchedNames         = Sanitize-CSVValue $result.MatchedNames
                    IsHidden             = $result.IsHidden
                    IsRecycleBin         = $result.IsRecycleBin
                    StreamInfo           = Sanitize-CSVValue $result.StreamInfo
                    AlternateStreamCount = $result.AlternateStreamCount
                    LnkTarget            = Sanitize-CSVValue $result.LnkTarget
                    LnkTargetSHA256      = Sanitize-CSVValue $result.LnkTargetSHA256
                }
            }
        
            $csvData | Export-Csv -Path $csvPath -NoTypeInformation -Encoding UTF8
        
            if (-not $Quiet) {
                Write-Host "`n[+] Results exported to: $csvPath" -ForegroundColor Green
            }
        }
        catch {
            Write-Warning "`nFailed to export CSV: $($_.Exception.Message)"
        }
    }

    # Summary - only display if not Quiet
    if (-not $Quiet) {
        if ($results.Count -eq 0) {
            Write-Host "[!] No items found matching the specified criteria." -ForegroundColor Yellow
        }
        else {
            $totalMatched = $filesMatched + $foldersMatched
            $displayedCount = $sortedResults.Count
            write-host "----------------------------------------"
            $summaryParts = @()
    
            if (![string]::IsNullOrWhiteSpace($filterType)) {
                $filterDescription = if ($filterType -eq "FILE") { "files" } else { "directories" }
                $summaryParts += "[+] Search completed. Found $totalMatched total items ($filesMatched files, $foldersMatched folders). Showing $displayedCount $filterDescription."
            }
            else {
                $summaryParts += "[+] Search completed. Found $totalMatched matching items ($filesMatched files, $foldersMatched folders)."
            }
    
            if ($Streams -and $streamMatches -gt 0) {
                $summaryParts += "Files with ADS: $streamMatches. Total ADS discovered: $totalStreamsFound"
            }
    
            Write-Host "$($summaryParts -join ' ')" -ForegroundColor Green
        }

        Write-Progress -Completed -Activity "Hunt-Files"
        Write-Host ""
    }

    # Return objects only if PassThru is specified
    if ($PassThru) {
        return $sortedResults
    }
}


function Hunt-Tasks {
    <#
    .SYNOPSIS
    Comprehensive enumeration and analysis of Windows scheduled tasks for DFIR investigations.
    
    .DESCRIPTION
    Hunt-Tasks provides deep forensic analysis of all scheduled tasks on a Windows system, including:
    - Complete task metadata (name, path, state, author, description)
    - Task file analysis with SHA256 hashes and timestamps  
    - Executable and script file identification with full path resolution
    - Working directory analysis
    - Trigger type enumeration
    - Runtime information (last run, next run times)
    - Support for search filtering with wildcards
    - CSV export with Excel-compatible sanitization
    - Silent operation mode for automation
    - Concise display by default, expandable with -More switch
    
    This function is designed for digital forensics, incident response, threat hunting, 
    and security auditing activities where comprehensive scheduled task analysis is required.
    
    .PARAMETER Search
    Filter results using wildcard patterns. Searches across task names, paths, descriptions, 
    executables, arguments, and trigger types. Case-insensitive matching.

    .PARAMETER Path
    Filter tasks by their Task Path. Supports wildcard matching. Use "\" to show only root-level tasks.
    Example: -Path "Microsoft" returns all tasks with "Microsoft" in the path.
    Example: -Path "\" returns only root-level tasks (no subdirectories).

    .PARAMETER StartDate
    Filter tasks by creation or modification date (start of range). Accepts multiple formats:
    - Relative: "7D" (days), "24H" (hours), "30M" (minutes)
    - Absolute: "2024-01-01" or any valid datetime string
    - Special: "now" for current time
    Filters based on task file modified date, task file created date, or last run time.
    When used, displays Modified date in output for reference.
    
    .PARAMETER EndDate
    Filter tasks by creation or modification date (end of range). Accepts multiple formats:
    - Relative: "7D" (days), "24H" (hours), "30M" (minutes)
    - Absolute: "2024-01-01" or any valid datetime string
    - Special: "now" for current time (default if not specified)
    Use with -StartDate to create a date range filter.
    
    .PARAMETER IncludeDisabled  
    Include disabled tasks in the analysis. By default, disabled tasks are excluded.

    .PARAMETER SortOrder
    Sort tasks by task file creation date. Options: NewestFirst (default) or OldestFirst.
    Tasks without creation dates appear last in NewestFirst, first in OldestFirst.

    .PARAMETER More
    Display all available fields including author, description, timestamps, task file details,
    script files, working directory, and trigger information. Default output shows only core fields.

    .PARAMETER PassThru
    Return PowerShell objects for further processing instead of just displaying results.
    All fields are included in objects regardless of -More switch.

    .PARAMETER Quiet
    Suppress console output except for errors and warnings. Designed for use with -PassThru
    and -OutputCSV for silent operation.

    .PARAMETER OutputCSV
    Export results to CSV format. Accepts either:
    - Full file path: "C:\Analysis\tasks.csv"  
    - Directory path: "C:\Analysis\" (auto-generates filename with timestamp)
    All fields are exported regardless of -More switch.

    .EXAMPLE
    Hunt-Tasks
    Display all enabled scheduled tasks with concise output (core fields only).

    .EXAMPLE
    Hunt-Tasks -More
    Display all enabled scheduled tasks with full details including timestamps and hashes.

    .EXAMPLE  
    Hunt-Tasks -Search "*malware*" -IncludeDisabled -More
    Search for tasks containing "malware" with full field display, including disabled tasks.

    .EXAMPLE
    Hunt-Tasks -OutputCSV "C:\DFIR\Analysis\"
    Export all task analysis to auto-generated CSV file with all fields.

    .EXAMPLE
    $suspiciousTasks = Hunt-Tasks -Search "*persist*" -PassThru -Quiet
    Silently collect tasks with "persist" in any field, return as objects with all fields.

    .EXAMPLE
    Hunt-Tasks -Search "*powershell*" -More -OutputCSV ".\ps_tasks.csv" -IncludeDisabled
    Find all PowerShell-related tasks with full details and export to CSV.

    .EXAMPLE
    Hunt-Tasks -Path "Microsoft" -StartDate "7D" -More
    Show all tasks in Microsoft-related paths modified in the last 7 days with full details.

    .EXAMPLE
    Hunt-Tasks -Path "\" -Quiet -PassThru
    Get only root-level tasks as PowerShell objects without console output.

    .EXAMPLE
    Hunt-Tasks -StartDate "2024-12-01" -Search "*update*"
    Find tasks containing "update" modified after December 1, 2024 with concise output.

    .EXAMPLE
    Hunt-Tasks -StartDate "7D" -EndDate "now"
    Display tasks modified in the last 7 days with Modified date shown.

    .EXAMPLE
    Hunt-Tasks -StartDate "2024-12-01" -EndDate "2024-12-07" -More
    Show tasks modified between December 1-7, 2024 with full details.

    .EXAMPLE
    Hunt-Tasks -SortOrder OldestFirst -More
    Display all tasks sorted by oldest task file creation date first with full details.

    .EXAMPLE
    Hunt-Tasks -Path "\" -SortOrder NewestFirst
    Display root-level tasks sorted by newest creation date first.

    .NOTES
    Requirements: PowerShell 5.0+, Windows
    Privileges: Administrator recommended for complete task enumeration
    Output: Displays forensic analysis or returns PSCustomObjects via -PassThru
    Date Filtering: Uses task file modified date (priority), created date, or last run time
    Path Filtering: Use "\" for root-level only, or wildcards like "*Microsoft*" for pattern matching
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [string]$Search = "",

        [Parameter(Mandatory = $false)]
        [string]$Path = "",

        [Parameter(Mandatory = $false)]
        [string]$StartDate = "",

        [Parameter(Mandatory = $false)]
        [string]$EndDate = "",

        [Parameter(Mandatory = $false)]
        [switch]$IncludeDisabled,

        [Parameter(Mandatory = $false)]
        [ValidateSet('NewestFirst', 'OldestFirst')]
        [string]$SortOrder = 'NewestFirst',

        [Parameter(Mandatory = $false)]
        [switch]$More,

        [Parameter(Mandatory = $false)]
        [switch]$PassThru,

        [Parameter(Mandatory = $false)]
        [switch]$Quiet,

        [Parameter(Mandatory = $false)]
        [string]$OutputCSV = ""        
    )

    begin {
        # Check for administrator privileges
        $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
        if (-not $isAdmin) {
            Write-Warning "Not running as Administrator, insufficient privileges may cause detection issues..."
        }
        Write-Verbose "[INFO]: Starting scheduled task enumeration..."
        
        # Progress tracking
        $script:TotalTasks = 0
        $script:ProcessedTasks = 0
        $script:TaskResults = [System.Collections.Generic.List[PSObject]]::new()

        # Helper function to convert date input to DateTime
        function ConvertTo-DateTime {
            param($InputValue)
        
            if ($InputValue -is [datetime]) {
                return $InputValue
            }
        
            if ($InputValue -is [string]) {
                $InputValue = $InputValue.Trim()
            
                if ($InputValue.ToLower() -eq 'now') {
                    return Get-Date
                }
            
                if ($InputValue -match '^(\d+)([DHMdhm])$') {
                    $number = [int]$matches[1]
                    $unit = $matches[2].ToUpper()
                
                    $currentTime = Get-Date
                    switch ($unit) {
                        'D' { return $currentTime.AddDays(-$number) }
                        'H' { return $currentTime.AddHours(-$number) }
                        'M' { return $currentTime.AddMinutes(-$number) }
                    }
                }
                else {
                    try {
                        return [datetime]$InputValue
                    }
                    catch {
                        throw "Invalid date format: $InputValue. Use datetime, 'now', or relative format like '7D', '24H', or '30M'"
                    }
                }
            }
        
            throw "Invalid date input: $InputValue"
        }

        # Helper function to create task result object
        function New-TaskResult {
            param(
                $Task,
                $TaskFileDetails,
                $ExecutableDetails,
                $ScriptFileDetails,
                $WorkingDirDetails,
                $ResolvedExecutable,
                $ScriptFile,
                $Arguments,
                $TriggerTypes,
                $TriggerObjects,
                $TaskInfo,
                $RunAsUser,
                $LogonType,
                $RunLevel
            )
    
            return [PSCustomObject]@{
                TaskName           = $Task.TaskName
                TaskPath           = $Task.TaskPath
                State              = $Task.State
                RunAsUser          = $RunAsUser
                LogonType          = $LogonType
                RunLevel           = $RunLevel
                Author             = $Task.Author
                Description        = $Task.Description
                LastRunTime        = if ($TaskInfo -and $TaskInfo.LastRunTime -ne [DateTime]::MinValue) { $TaskInfo.LastRunTime } else { $null }
                NextRunTime        = if ($TaskInfo -and $TaskInfo.NextRunTime -ne [DateTime]::MinValue) { $TaskInfo.NextRunTime } else { $null }
                TaskFilePath       = $TaskFileDetails.Path
                TaskFileExists     = $TaskFileDetails.Exists
                TaskFileSHA256     = $TaskFileDetails.SHA256
                TaskFileCreated    = $TaskFileDetails.Created
                TaskFileModified   = $TaskFileDetails.Modified
                ExecutablePath     = $ResolvedExecutable
                ExecutableExists   = if ($ExecutableDetails) { $ExecutableDetails.Exists } else { $false }
                ExecutableSHA256   = if ($ExecutableDetails) { $ExecutableDetails.SHA256 } else { 'N/A' }
                ExecutableModified = if ($ExecutableDetails) { $ExecutableDetails.Modified } else { 'N/A' }
                Arguments          = $Arguments
                ScriptFilePath     = $ScriptFile
                ScriptFileExists   = if ($ScriptFileDetails) { $ScriptFileDetails.Exists } else { $false }
                ScriptFileSHA256   = if ($ScriptFileDetails) { $ScriptFileDetails.SHA256 } else { 'N/A' }
                WorkingDirectory   = if ($WorkingDirDetails) { $WorkingDirDetails.Path } else { $null }
                TriggerTypes       = $TriggerTypes -join ', '
                Triggers           = $TriggerObjects
                Hostname           = $env:COMPUTERNAME
            }
        }


        # Helper function to sanitize CSV values for Excel compatibility
        function Sanitize-CSVValue {
            param([string]$Value)
    
            if ([string]::IsNullOrWhiteSpace($Value)) {
                return ""
            }
    
            try {
                # Remove control characters and replace with spaces
                $sanitized = $Value -replace '[\x00-\x1F\x7F]', ' '
        
                # Remove or replace problematic characters
                $sanitized = $sanitized -replace '["\r\n]', ' '
                $sanitized = $sanitized -replace '\t', ' '
        
                # Prevent Excel formula injection - prepend with single quote if starts with dangerous char
                if ($sanitized -match '^[=+\-@]') {
                    $sanitized = "'" + $sanitized
                }
        
                # Trim whitespace and limit length for Excel (32767 character limit per cell)
                $sanitized = $sanitized.Trim()
                if ($sanitized.Length -gt 32000) {
                    $sanitized = $sanitized.Substring(0, 32000) + "...[TRUNCATED]"
                }
        
                return $sanitized
            }
            catch {
                Write-Verbose "CSV sanitization error: $($_.Exception.Message)"
                return ""
            }
        }

        # Helper function to generate CSV filename
        function Get-CSVFileName {
            param([string]$OutputPath)
    
            try {
                if ([string]::IsNullOrWhiteSpace($OutputPath)) {
                    return $null
                }
        
                # Check if path is a directory
                if (Test-Path $OutputPath -PathType Container -ErrorAction SilentlyContinue) {
                    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
                    $filename = "Hunt-Tasks_Results_$($env:COMPUTERNAME)_$timestamp.csv"
                    return Join-Path $OutputPath $filename
                }
                # Check if parent directory exists for file path
                elseif ($OutputPath -match '\.csv$') {
                    $parentDir = Split-Path $OutputPath -Parent
                    if ([string]::IsNullOrWhiteSpace($parentDir) -or (Test-Path $parentDir -PathType Container -ErrorAction SilentlyContinue)) {
                        return $OutputPath
                    }
                    else {
                        # Try to create parent directory
                        try {
                            New-Item -ItemType Directory -Path $parentDir -Force -ErrorAction Stop | Out-Null
                            Write-Verbose "[INFO]: Created directory: $parentDir"
                            return $OutputPath
                        }
                        catch {
                            Write-Warning "Could not create directory: $parentDir"
                            return $null
                        }
                    }
                }
        
                Write-Warning "Invalid OutputCSV path specified: $OutputPath"
                return $null
            }
            catch {
                Write-Warning "Error processing OutputCSV path: $($_.Exception.Message)"
                return $null
            }
        }

        function Find-ExecutableInSystemPaths {
            param([string]$FileName)
    
            if ([string]::IsNullOrWhiteSpace($FileName)) { 
                return $FileName 
            }
    
            # Define search paths in order of priority
            $searchPaths = @(
                "C:\Windows\System32",
                "C:\Windows\SysWOW64", 
                "C:\Windows",
                "C:\Program Files\Windows NT\Accessories",
                "C:\Program Files\Common Files\Microsoft Shared",
                "C:\Windows\System32\WindowsPowerShell\v1.0",
                "C:\Windows\SysWOW64\WindowsPowerShell\v1.0",
                "C:\Program Files\PowerShell\7"
            )
    
            foreach ($searchPath in $searchPaths) {
                $fullPath = Join-Path $searchPath $FileName
                if (Test-Path $fullPath -ErrorAction SilentlyContinue) {
                    return $fullPath
                }
            }
    
            # If not found, return the original filename
            return $FileName
        }

        # Helper function to validate Windows paths
        function Test-ValidWindowsPath {
            param([string]$Path)
            
            if ([string]::IsNullOrWhiteSpace($Path)) {
                return $false
            }
            
            try {
                # Check for valid path characters and structure
                if ($Path.Length -gt 32767) {
                    return $false
                }
                
                # Basic Windows path validation
                if ($Path -match '^[A-Za-z]:\\' -or $Path -match '^\\\\') {
                    # Remove common invalid path characters
                    if ($Path -match '[\<\>\|\?\*]') {
                        return $false
                    }
                    return $true
                }
                
                # Allow relative paths and filenames
                if ($Path -match '\.(exe|dll|bat|cmd|ps1|vbs|js|msi|com|scr|lnk|cpl|hta|wsf)$') {
                    return $true
                }
                
                return $false
            }
            catch {
                return $false
            }
        }

        # Helper function to check if a string matches search criteria (case insensitive with wildcards)
        function Test-SearchMatch {
            param(
                [string]$Text,
                [string]$SearchPattern
            )
            
            # Handle null or empty inputs
            if ([string]::IsNullOrWhiteSpace($Text) -or [string]::IsNullOrWhiteSpace($SearchPattern)) {
                return $false
            }
            
            try {
                # Ensure pattern has wildcards for flexible matching
                $pattern = if ($SearchPattern -notlike '*`**' -and $SearchPattern -notlike '*`?*') {
                    "*$SearchPattern*"
                }
                else {
                    $SearchPattern
                }
                
                return $Text -like $pattern
            }
            catch {
                # Fallback to simple contains check if wildcard pattern fails
                try {
                    return $Text.ToLower().Contains($SearchPattern.ToLower().Replace('*', '').Replace('?', ''))
                }
                catch {
                    Write-Verbose "Search match failed for text '$Text' with pattern '$SearchPattern'"
                    return $false
                }
            }
        }
        
        # Helper function to calculate SHA256
        function Get-FileSHA256 {
            param([string]$FilePath)
            
            if ([string]::IsNullOrWhiteSpace($FilePath)) {
                return 'N/A'
            }
            
            try {
                if (Test-Path $FilePath -PathType Leaf -ErrorAction SilentlyContinue) {
                    $fileInfo = Get-Item $FilePath -Force -ErrorAction Stop
                    
                    # Skip files larger than 500MB to prevent memory issues
                    if ($fileInfo.Length -gt 524288000) {
                        Write-Verbose "File too large for hash calculation: $FilePath ($([math]::Round($fileInfo.Length / 1MB, 2)) MB)"
                        return 'File Too Large'
                    }
                    
                    $hash = $null
                    try {
                        $hash = [System.Security.Cryptography.SHA256]::Create()
                        $fileBytes = [System.IO.File]::ReadAllBytes($FilePath)
                        $hashBytes = $hash.ComputeHash($fileBytes)
                        return [BitConverter]::ToString($hashBytes).Replace('-', '').ToLower()
                    }
                    finally {
                        if ($null -ne $hash) {
                            $hash.Dispose()
                        }
                    }
                }
                return 'N/A'
            }
            catch [System.UnauthorizedAccessException] {
                Write-Verbose "Access denied for hash calculation: $FilePath"
                return 'Access Denied'
            }
            catch [System.IO.IOException] {
                Write-Verbose "File locked or IO error: $FilePath"
                return 'File Locked'
            }
            catch {
                Write-Verbose "Hash calculation error for $FilePath - $($_.Exception.Message)"
                return 'N/A'
            }
        }
        
        # Helper function to get file information
        function Get-FileDetails {
            param([string]$FilePath)
            
            if ([string]::IsNullOrWhiteSpace($FilePath)) {
                return @{
                    Path     = $FilePath
                    Created  = 'N/A'
                    Modified = 'N/A'
                    Accessed = 'N/A'
                    Size     = 'N/A'
                    SHA256   = 'N/A'
                    Exists   = $false
                }
            }
            
            # Check path length (Windows limit is 260 for most APIs, 32767 for Unicode)
            if ($FilePath.Length -gt 32767) {
                Write-Verbose "Path too long: $($FilePath.Length) characters"
                return @{
                    Path     = $FilePath.Substring(0, 200) + "...[TRUNCATED]"
                    Created  = 'N/A'
                    Modified = 'N/A'
                    Accessed = 'N/A'
                    Size     = 'N/A'
                    SHA256   = 'Path Too Long'
                    Exists   = $false
                }
            }
            
            try {
                if (Test-Path $FilePath -ErrorAction SilentlyContinue) {
                    $file = $null
                    try {
                        $file = Get-Item $FilePath -Force -ErrorAction Stop
                    }
                    catch [System.UnauthorizedAccessException] {
                        Write-Verbose "Access denied: $FilePath"
                        return @{
                            Path     = $FilePath
                            Created  = 'N/A'
                            Modified = 'N/A'
                            Accessed = 'N/A'
                            Size     = 'N/A'
                            SHA256   = 'Access Denied'
                            Exists   = $true
                        }
                    }
                    
                    if ($file) {
                        $fileSize = 'N/A'
                        $sha256Hash = 'N/A'
                        
                        if (-not $file.PSIsContainer) {
                            try {
                                $fileSize = [math]::Round($file.Length / 1MB, 2)
                            }
                            catch {
                                $fileSize = 'N/A'
                            }
                            
                            # Get hash (with built-in size and access checks)
                            $sha256Hash = Get-FileSHA256 -FilePath $file.FullName
                        }
                        
                        return @{
                            Path     = $file.FullName
                            Created  = $file.CreationTime
                            Modified = $file.LastWriteTime
                            Accessed = $file.LastAccessTime
                            Size     = $fileSize
                            SHA256   = $sha256Hash
                            Exists   = $true
                        }
                    }
                }
                
                return @{
                    Path     = $FilePath
                    Created  = 'N/A'
                    Modified = 'N/A'
                    Accessed = 'N/A'
                    Size     = 'N/A'
                    SHA256   = 'N/A'
                    Exists   = $false
                }
            }
            catch {
                Write-Verbose "Error getting file details for '$FilePath': $($_.Exception.Message)"
                return @{
                    Path     = $FilePath
                    Created  = 'N/A'
                    Modified = 'N/A'
                    Accessed = 'N/A'
                    Size     = 'N/A'
                    SHA256   = 'N/A'
                    Exists   = $false
                }
            }
        }
        
        # Helper function to format datetime
        function Format-DateTime {
            param($DateTime)
            if ($DateTime -and $DateTime -ne 'N/A' -and $DateTime -is [DateTime]) {
                return $DateTime.ToString("yyyy-MM-dd HH:mm:ss")
            }
            return 'N/A'
        }

        # Helper function to resolve executable path with quote and argument handling
        function Resolve-ExecutablePath {
            param([string]$ExecutablePath, [string]$Arguments = "")
            
            if ([string]::IsNullOrWhiteSpace($ExecutablePath)) {
                return $null
            }
            
            # Remove surrounding quotes if present
            $cleanPath = $ExecutablePath.Trim().Trim('"').Trim("'")
            
            # If we have arguments, try Get-FileFromCommandLine with full command
            if (-not [string]::IsNullOrWhiteSpace($Arguments)) {
                try {
                    $fullCommandLine = "$ExecutablePath $Arguments"
                    $extractedPath = Get-FileFromCommandLine -CommandLine $fullCommandLine
                    
                    if ($extractedPath) {
                        $cleanExtracted = $extractedPath.Trim().Trim('"').Trim("'")
                        
                        # Expand environment variables
                        $expandedPath = [Environment]::ExpandEnvironmentVariables($cleanExtracted)
                        
                        # Test if file exists
                        if (Test-Path $expandedPath -PathType Leaf -ErrorAction SilentlyContinue) {
                            return $expandedPath
                        }
                    }
                }
                catch {
                    Write-Verbose "Get-FileFromCommandLine failed: $($_.Exception.Message)"
                }
            }
            
            # Expand environment variables in the clean path
            $expandedClean = [Environment]::ExpandEnvironmentVariables($cleanPath)
            
            # Test if it's a valid file path
            if (Test-Path $expandedClean -PathType Leaf -ErrorAction SilentlyContinue) {
                return $expandedClean
            }
            
            # If it's already a full path structure but file doesn't exist, return it anyway
            if ($expandedClean -match '^[A-Za-z]:' -or $expandedClean.StartsWith('\\')) {
                return $expandedClean
            }
            
            # Try to find in system paths
            $foundPath = Find-ExecutableInSystemPaths $expandedClean
            
            # Verify found path exists
            if ($foundPath -and (Test-Path $foundPath -PathType Leaf -ErrorAction SilentlyContinue)) {
                return $foundPath
            }
            
            # Return the expanded clean path as fallback
            return $expandedClean
        }
    }
    
    process {
        try {
            # Get all scheduled tasks
            $tasks = Get-ScheduledTask -ErrorAction SilentlyContinue
            
            if ($null -eq $tasks) {
                Write-Host "[ERROR]: Unable to retrieve scheduled tasks. Administrative privileges may be required." -ForegroundColor Red
                return
            }
            
            # Filter tasks based on parameters - apply search filter after processing each task
            if (-not $IncludeDisabled) {
                $tasks = $tasks | Where-Object { $_.State -ne 'Disabled' }
            }

            # Apply Path filter if specified
            if (-not [string]::IsNullOrWhiteSpace($Path)) {
                if ($Path -eq '\') {
                    # Special case: root folder only (no subdirectories)
                    $tasks = $tasks | Where-Object { $_.TaskPath -eq '\' }
                    Write-Verbose "[INFO]: Filtering for root-level tasks only"
                }
                else {
                    # Wildcard matching on task path
                    $pathPattern = if ($Path -notlike '*`**' -and $Path -notlike '*`?*') { "*$Path*" } else { $Path }
                    $tasks = $tasks | Where-Object { $_.TaskPath -like $pathPattern }
                    Write-Verbose "[INFO]: Filtering tasks by path pattern: $pathPattern"
                }
            }

            # Parse StartDate filter if specified
            $startDateFilter = $null
            $endDateFilter = $null
            $dateFilterActive = $false
            
            if (-not [string]::IsNullOrWhiteSpace($StartDate)) {
                try {
                    $startDateFilter = ConvertTo-DateTime -InputValue $StartDate
                    $dateFilterActive = $true
                    Write-Verbose "[INFO]: Filtering tasks modified/created after: $($startDateFilter.ToString('yyyy-MM-dd HH:mm:ss'))"
                }
                catch {
                    Write-Warning "Invalid StartDate format: $StartDate. Ignoring date filter."
                    Write-Verbose "[ERROR]: $($_.Exception.Message)"
                }
            }
            
            # Parse EndDate filter if specified (defaults to now if StartDate provided but EndDate not)
            if ($dateFilterActive) {
                if (-not [string]::IsNullOrWhiteSpace($EndDate)) {
                    try {
                        $endDateFilter = ConvertTo-DateTime -InputValue $EndDate
                        Write-Verbose "[INFO]: Filtering tasks modified/created before: $($endDateFilter.ToString('yyyy-MM-dd HH:mm:ss'))"
                    }
                    catch {
                        Write-Warning "Invalid EndDate format: $EndDate. Using current time as end date."
                        $endDateFilter = Get-Date
                    }
                }
                else {
                    # Default to now if StartDate specified but EndDate not
                    $endDateFilter = Get-Date
                    Write-Verbose "[INFO]: EndDate not specified, using current time: $($endDateFilter.ToString('yyyy-MM-dd HH:mm:ss'))"
                }
            }
            elseif (-not [string]::IsNullOrWhiteSpace($EndDate)) {
                # EndDate specified without StartDate
                Write-Warning "EndDate specified without StartDate. EndDate will be ignored."
            }
            
            # Sort tasks by TaskPath alphabetically (like Get-ScheduledTask), then by TaskName
            $sortedTasks = $tasks | Sort-Object TaskPath, TaskName
            
            $taskCount = 0
            $matchCount = 0
            
            # Get total count for progress
            $script:TotalTasks = $sortedTasks.Count
            Write-Progress -Activity "Enumerating Scheduled Tasks" -Status "Processing $($script:TotalTasks) tasks..." -PercentComplete 0
            
            foreach ($task in $sortedTasks) {
                $taskCount++
                $script:ProcessedTasks = $taskCount
                
                # Update progress every 10 tasks or for small datasets
                if (($taskCount % 10 -eq 0) -or ($script:TotalTasks -lt 50)) {
                    $percentComplete = [math]::Min(100, [math]::Round(($taskCount / $script:TotalTasks) * 100, 0))
                    Write-Progress -Activity "Enumerating Scheduled Tasks" -Status "Processing task $taskCount of $($script:TotalTasks)..." -PercentComplete $percentComplete
                }
                
                try {
                    # Get task file path and details
                    $taskFilePath = Join-Path $env:windir "System32\Tasks\$($task.TaskPath.TrimStart('\'))\$($task.TaskName)"
                    $taskFileDetails = Get-FileDetails -FilePath $taskFilePath
                    
                    # Get task information
                    $taskInfo = $null
                    try {
                        $taskInfo = Get-ScheduledTaskInfo -TaskName $task.TaskName -TaskPath $task.TaskPath -ErrorAction SilentlyContinue
                    }
                    catch {
                        # Continue without task info if it fails
                    }
                    
                    # Get principal information (run as account)
                    $principal = $null
                    $runAsUser = 'N/A'
                    $logonType = 'N/A'
                    $runLevel = 'N/A'
                    try {
                        $principal = $task.Principal
                        if ($principal) {
                            # Get UserId - could be in UserId, GroupId, or Id property
                            if ($principal.UserId) {
                                $runAsUser = $principal.UserId
                            }
                            elseif ($principal.GroupId) {
                                $runAsUser = $principal.GroupId
                            }
                            elseif ($principal.Id) {
                                $runAsUser = $principal.Id
                            }
                            
                            # Get LogonType
                            if ($principal.LogonType) {
                                $logonType = $principal.LogonType
                            }
                            
                            # Get RunLevel
                            if ($principal.RunLevel) {
                                $runLevel = $principal.RunLevel
                            }
                        }
                    }
                    catch {
                        Write-Verbose "Error retrieving principal information for task '$($task.TaskName)': $($_.Exception.Message)"
                    }

                    # Apply StartDate/EndDate filter if specified
                    if ($dateFilterActive) {
                        $taskDate = $null
                        
                        # Priority 1: Task file modified date
                        if ($taskFileDetails.Modified -is [DateTime]) {
                            $taskDate = $taskFileDetails.Modified
                        }
                        # Priority 2: Task file created date
                        elseif ($taskFileDetails.Created -is [DateTime]) {
                            $taskDate = $taskFileDetails.Created
                        }
                        # Priority 3: Last run time
                        elseif ($taskInfo -and $taskInfo.LastRunTime -and $taskInfo.LastRunTime -ne [DateTime]::MinValue) {
                            $taskDate = $taskInfo.LastRunTime
                        }
                        
                        # Skip if no valid date found
                        if ($null -eq $taskDate) {
                            Write-Verbose "[FILTER]: Skipping task '$($task.TaskName)' - no valid date found for comparison"
                            continue
                        }
                        
                        # Skip if outside date range
                        if ($taskDate -lt $startDateFilter) {
                            Write-Verbose "[FILTER]: Skipping task '$($task.TaskName)' - date $($taskDate.ToString('yyyy-MM-dd HH:mm:ss')) is before start date"
                            continue
                        }
                        
                        if ($null -ne $endDateFilter -and $taskDate -gt $endDateFilter) {
                            Write-Verbose "[FILTER]: Skipping task '$($task.TaskName)' - date $($taskDate.ToString('yyyy-MM-dd HH:mm:ss')) is after end date"
                            continue
                        }
                    }
                    
                    # Validate task has actions
                    if (-not $task.Actions -or $task.Actions.Count -eq 0) {
                        Write-Verbose "Task '$($task.TaskName)' has no actions"
                        continue
                    }
                    
                    foreach ($action in $task.Actions) {
                        try {
                            # Get raw values from action
                            $executable = $action.Execute
                            $arguments = $action.Arguments
                            $workingDir = if ($action.WorkingDirectory) { $action.WorkingDirectory } else { $null }
                            
                            # Resolve executable path with arguments for better parsing
                            $resolvedExecutable = Resolve-ExecutablePath -ExecutablePath $executable -Arguments $arguments
                            
                            # Expand environment variables in working directory
                            $expandedWorkingDir = if ($workingDir) { [Environment]::ExpandEnvironmentVariables($workingDir) } else { $null }
                            
                            # Get file details for executable and working directory
                            $executableDetails = if ($resolvedExecutable) { Get-FileDetails -FilePath $resolvedExecutable } else { $null }
                            $workingDirDetails = if ($expandedWorkingDir) { Get-FileDetails -FilePath $expandedWorkingDir } else { $null }
                            
                            # Try to extract script file from command line
                            $scriptFile = $null
                            $scriptFileDetails = $null
                            
                            if ($null -ne $arguments -and -not [string]::IsNullOrWhiteSpace($arguments)) {
                                try {
                                    # Build full command line with raw executable value
                                    $fullCommandLine = "$executable $arguments"
                                    $extractedFile = Get-FileFromCommandLine -CommandLine $fullCommandLine
                                    
                                    # Clean extracted file path
                                    if ($extractedFile) {
                                        $cleanExtractedFile = $extractedFile.Trim().Trim('"').Trim("'")
                                        $expandedExtracted = [Environment]::ExpandEnvironmentVariables($cleanExtractedFile)
                                        
                                        # Only treat as script file if it's different from executable AND has valid file extension
                                        if ($expandedExtracted -ne $resolvedExecutable -and
                                            $expandedExtracted -match '\.(ps1|vbs|js|bat|cmd|py|rb|pl)$') {
                                            
                                            # Verify it's actually a file path
                                            if (Test-ValidWindowsPath $expandedExtracted) {
                                                $scriptFile = $expandedExtracted
                                                $scriptFileDetails = Get-FileDetails -FilePath $scriptFile
                                            }
                                        }
                                    }
                                }
                                catch {
                                    Write-Verbose "Error extracting script file from command line: $($_.Exception.Message)"
                                    $scriptFile = $null
                                    $scriptFileDetails = $null
                                }
                            }
                            
                            # Get trigger types for search and storage
                            $triggerTypes = @()
                            $triggerObjects = @()
                            if ($task.Triggers) {
                                foreach ($trigger in $task.Triggers) {
                                    try {
                                        $triggerType = $trigger.CimClass.CimClassName -replace 'MSFT_Task', '' -replace 'Trigger', ''
                                        # Only add non-empty trigger types
                                        if (-not [string]::IsNullOrWhiteSpace($triggerType)) {
                                            $triggerTypes += $triggerType
                                            $triggerObjects += $trigger
                                        }
                                    }
                                    catch {
                                        # Continue if trigger parsing fails
                                    }
                                }
                            }
                            
                            # Apply search filter if specified - check all relevant fields
                            $includeTask = $true
                            if (-not [string]::IsNullOrWhiteSpace($Search)) {
                                $includeTask = $false
                                
                                # Check all relevant fields
                                $searchFields = @(
                                    $task.TaskName,
                                    $task.TaskPath,
                                    $task.Author,
                                    $task.Description,
                                    $arguments,
                                    $action.Execute,
                                    $resolvedExecutable,
                                    $scriptFile
                                )
                                
                                # Add trigger types to search
                                $searchFields += $triggerTypes
                                
                                foreach ($field in $searchFields) {
                                    if (Test-SearchMatch -Text $field -SearchPattern $Search) {
                                        $includeTask = $true
                                        break
                                    }
                                }
                            }
                            
                            # Skip this task if it doesn't match search criteria
                            if (-not $includeTask) {
                                continue
                            }
                            
                            $matchCount++
                            
                            # Always create result object - needed for display, PassThru, and CSV
                            $taskResult = New-TaskResult -Task $task -TaskFileDetails $taskFileDetails -ExecutableDetails $executableDetails -ScriptFileDetails $scriptFileDetails -WorkingDirDetails $workingDirDetails -ResolvedExecutable $resolvedExecutable -ScriptFile $scriptFile -Arguments $arguments -TriggerTypes $triggerTypes -TriggerObjects $triggerObjects -TaskInfo $taskInfo -RunAsUser $runAsUser -LogonType $logonType -RunLevel $runLevel
                            $script:TaskResults.Add($taskResult)
                        }
                        catch {
                            Write-Verbose "Error processing action for task '$($task.TaskName)': $($_.Exception.Message)"
                            continue
                        }
                    }
                }
                catch {
                    Write-Verbose "Error processing task '$($task.TaskName)': $($_.Exception.Message)"
                    continue
                }
            }

            # Sort results by task file creation date
            if ($script:TaskResults.Count -gt 0) {
                try {
                    if ($SortOrder -eq 'NewestFirst') {
                        # Sort descending - newest first, nulls/N/A last
                        $script:TaskResults = [System.Collections.Generic.List[PSObject]]::new(
                            ($script:TaskResults | Sort-Object { 
                                if ($_.TaskFileCreated -is [DateTime]) { 
                                    $_.TaskFileCreated
                                } 
                                else { 
                                    [DateTime]::MinValue 
                                }
                            } -Descending)
                        )
                    }
                    else {
                        # Sort ascending - oldest first, nulls/N/A first
                        $script:TaskResults = [System.Collections.Generic.List[PSObject]]::new(
                            ($script:TaskResults | Sort-Object { 
                                if ($_.TaskFileCreated -is [DateTime]) { 
                                    $_.TaskFileCreated
                                } 
                                else { 
                                    [DateTime]::MaxValue 
                                }
                            })
                        )
                    }
                }
                catch {
                    Write-Verbose "Error sorting results: $($_.Exception.Message)"
                    # Continue with unsorted results
                }
            }

            # Display sorted results
            if (-not $Quiet -and $script:TaskResults.Count -gt 0) {
                Write-Host ""
                Write-Host "[+] Displaying $($script:TaskResults.Count) task matches (sorted by $SortOrder)..." -ForegroundColor Cyan
                
                foreach ($result in $script:TaskResults) {
                    try {
                        Write-Host ""
                        Write-Host "----------------------------------------" -ForegroundColor Gray
                        
                        # Core fields - always displayed
                        Write-Host "Task Name    : " -NoNewline -ForegroundColor Yellow
                        Write-Host $result.TaskName -ForegroundColor Cyan

                        if ($result.TaskPath) {
                            Write-Host "Task Path    : " -NoNewline -ForegroundColor Yellow
                            Write-Host $result.TaskPath -ForegroundColor White
                        }

                        if ($result.State) {
                            Write-Host "State        : " -NoNewline -ForegroundColor Yellow
                            Write-Host $result.State -ForegroundColor DarkGray
                        }
                        
                        # Display principal information - always shown
                        if ($result.RunAsUser -ne 'N/A') {
                            Write-Host "Run As       : " -NoNewline -ForegroundColor Yellow
                            # Highlight privileged accounts
                            if ($result.RunAsUser -eq 'SYSTEM' -or $result.RunAsUser -eq 'NT AUTHORITY\SYSTEM') {
                                Write-Host $result.RunAsUser -ForegroundColor White
                            }
                            elseif ($result.RunLevel -eq 'Highest') {
                                Write-Host "$($result.RunAsUser) " -NoNewline -ForegroundColor White
                                Write-Host "(Elevated)" -ForegroundColor White
                            }
                            else {
                                Write-Host $result.RunAsUser -ForegroundColor White
                            }
                        }

                        # Display Execute, Arguments, SHA256, Created only when NOT using -More
                        if (-not $More) {
                            if ($result.ExecutablePath) {
                                Write-Host "Execute      : " -NoNewline -ForegroundColor Yellow
                                Write-Host $result.ExecutablePath -ForegroundColor Red
                            }

                            if ($result.Arguments) {
                                Write-Host "Arguments    : " -NoNewline -ForegroundColor Yellow
                                Write-Host $result.Arguments -ForegroundColor DarkYellow
                            }

                            if ($result.ExecutableSHA256 -and $result.ExecutableSHA256 -ne 'N/A') {
                                Write-Host "SHA256       : " -NoNewline -ForegroundColor Yellow
                                Write-Host $result.ExecutableSHA256 -ForegroundColor DarkGray
                            }
                            
                            if ($result.TaskFileCreated -and $result.TaskFileCreated -ne 'N/A') {
                                Write-Host "Created      : " -NoNewline -ForegroundColor Yellow
                                if ($result.TaskFileCreated -is [DateTime]) {
                                    Write-Host $result.TaskFileCreated.ToString("yyyy-MM-dd HH:mm:ss") -ForegroundColor DarkGray
                                }
                                else {
                                    Write-Host (Format-DateTime -DateTime $result.TaskFileCreated) -ForegroundColor DarkGray
                                }
                            }
                            
                            # Show Modified date when date filtering is active
                            if ($dateFilterActive -and $result.TaskFileModified -and $result.TaskFileModified -ne 'N/A') {
                                Write-Host "Modified     : " -NoNewline -ForegroundColor Yellow
                                if ($result.TaskFileModified -is [DateTime]) {
                                    Write-Host $result.TaskFileModified.ToString("yyyy-MM-dd HH:mm:ss") -ForegroundColor DarkGray
                                }
                                else {
                                    Write-Host (Format-DateTime -DateTime $result.TaskFileModified) -ForegroundColor DarkGray
                                }
                            }
                        }

                        # Additional fields - only with -More switch
                        if ($More) {
                            # Extended principal information
                            if ($result.LogonType -ne 'N/A') {
                                Write-Host "Logon Type   : " -NoNewline -ForegroundColor Yellow
                                Write-Host $result.LogonType -ForegroundColor DarkGray
                            }
                            if ($result.RunLevel -ne 'N/A') {
                                Write-Host "Run Level    : " -NoNewline -ForegroundColor Yellow
                                if ($result.RunLevel -eq 'Highest') {
                                    Write-Host $result.RunLevel -ForegroundColor Red
                                }
                                else {
                                    Write-Host $result.RunLevel -ForegroundColor DarkGray
                                }
                            }
                            
                            if ($result.Author) {
                                Write-Host "Author       : " -NoNewline -ForegroundColor Yellow
                                Write-Host $result.Author -ForegroundColor White
                            }

                            if ($result.Description) {
                                Write-Host "Description  : " -NoNewline -ForegroundColor Yellow
                                Write-Host $result.Description -ForegroundColor DarkGray
                            }

                            if ($result.LastRunTime -and $result.LastRunTime -is [DateTime] -and $result.LastRunTime -ne [DateTime]::MinValue) {
                                Write-Host "Last Run     : " -NoNewline -ForegroundColor Yellow
                                Write-Host $result.LastRunTime.ToString("yyyy-MM-dd HH:mm:ss") -ForegroundColor DarkGray
                            }
                            if ($result.NextRunTime -and $result.NextRunTime -is [DateTime] -and $result.NextRunTime -ne [DateTime]::MinValue) {
                                Write-Host "Next Run     : " -NoNewline -ForegroundColor Yellow
                                Write-Host $result.NextRunTime.ToString("yyyy-MM-dd HH:mm:ss") -ForegroundColor DarkGray
                            }

                            # Task file information
                            Write-Host ""
                            Write-Host "--- Task File ---" -ForegroundColor DarkCyan
                            if ($result.TaskFileExists) {
                                Write-Host "Path         : " -NoNewline -ForegroundColor Yellow
                                Write-Host $result.TaskFilePath -ForegroundColor White

                                if ($result.TaskFileCreated -and $result.TaskFileCreated -ne 'N/A') {
                                    Write-Host "Created      : " -NoNewline -ForegroundColor Yellow
                                    if ($result.TaskFileCreated -is [DateTime]) {
                                        Write-Host $result.TaskFileCreated.ToString("yyyy-MM-dd HH:mm:ss") -ForegroundColor DarkGray
                                    }
                                    else {
                                        Write-Host (Format-DateTime -DateTime $result.TaskFileCreated) -ForegroundColor DarkGray
                                    }
                                }
                                if ($result.TaskFileModified -and $result.TaskFileModified -ne 'N/A') {
                                    Write-Host "Modified     : " -NoNewline -ForegroundColor Yellow
                                    if ($result.TaskFileModified -is [DateTime]) {
                                        Write-Host $result.TaskFileModified.ToString("yyyy-MM-dd HH:mm:ss") -ForegroundColor DarkGray
                                    }
                                    else {
                                        Write-Host (Format-DateTime -DateTime $result.TaskFileModified) -ForegroundColor DarkGray
                                    }
                                }
                                if ($result.TaskFileSHA256 -and $result.TaskFileSHA256 -ne 'N/A') {
                                    Write-Host "SHA256       : " -NoNewline -ForegroundColor Yellow
                                    Write-Host $result.TaskFileSHA256 -ForegroundColor Gray
                                }
                            }
                            else {
                                Write-Host "Status       : " -NoNewline -ForegroundColor Yellow
                                Write-Host "Task File Not Found" -ForegroundColor Red
                            }

                            # Executable information - always display header
                            Write-Host ""
                            Write-Host "--- Executable ---" -ForegroundColor DarkCyan
                            if ($result.ExecutablePath) {
                                Write-Host "Execute      : " -NoNewline -ForegroundColor Yellow
                                Write-Host $result.ExecutablePath -ForegroundColor Red
                                
                                if ($result.Arguments) {
                                    Write-Host "Arguments    : " -NoNewline -ForegroundColor Yellow
                                    Write-Host $result.Arguments -ForegroundColor DarkYellow
                                }
                                
                                if ($result.ExecutableExists) {
                                    if ($result.ExecutableSHA256 -and $result.ExecutableSHA256 -ne 'N/A') {
                                        Write-Host "SHA256       : " -NoNewline -ForegroundColor Yellow
                                        Write-Host $result.ExecutableSHA256 -ForegroundColor Gray
                                    }
                                    if ($result.ExecutableModified -and $result.ExecutableModified -ne 'N/A') {
                                        Write-Host "Modified     : " -NoNewline -ForegroundColor Yellow
                                        if ($result.ExecutableModified -is [DateTime]) {
                                            Write-Host $result.ExecutableModified.ToString("yyyy-MM-dd HH:mm:ss") -ForegroundColor DarkGray
                                        }
                                        else {
                                            Write-Host (Format-DateTime -DateTime $result.ExecutableModified) -ForegroundColor DarkGray
                                        }
                                    }
                                }
                                else {
                                    Write-Host "Status       : " -NoNewline -ForegroundColor Yellow
                                    Write-Host "Executable Not Found" -ForegroundColor Red
                                }
                            }
                            else {
                                Write-Host "Status       : " -NoNewline -ForegroundColor Yellow
                                Write-Host "No Executable Information Available" -ForegroundColor DarkGray
                            }

                            # Script file information
                            if ($result.ScriptFilePath -and $result.ScriptFileExists) {
                                Write-Host ""
                                Write-Host "--- Exec File ---" -ForegroundColor DarkCyan
                                Write-Host "Exec File    : " -NoNewline -ForegroundColor Yellow
                                Write-Host $result.ScriptFilePath -ForegroundColor Red

                                if ($result.ScriptFileSHA256 -and $result.ScriptFileSHA256 -ne 'N/A') {
                                    Write-Host "Exec SHA256  : " -NoNewline -ForegroundColor Yellow
                                    Write-Host $result.ScriptFileSHA256 -ForegroundColor Gray
                                }
                            }

                            # Working directory information
                            if ($result.WorkingDirectory) {
                                Write-Host ""
                                Write-Host "--- Working Directory ---" -ForegroundColor DarkCyan
                                Write-Host "Path         : " -NoNewline -ForegroundColor Yellow
                                Write-Host $result.WorkingDirectory -ForegroundColor Cyan
                            }

                            # Triggers with full details
                            Write-Host ""
                            Write-Host "--- Triggers ---" -ForegroundColor DarkCyan
                            if ($result.Triggers -and $result.Triggers.Count -gt 0) {
                                $triggerCount = 0
                                foreach ($trigger in $result.Triggers) {
                                    try {
                                        $triggerCount++
                                        
                                        $triggerProperties = $trigger | Get-Member -MemberType Property | Select-Object -ExpandProperty Name
                                        
                                        if ($result.Triggers.Count -gt 1) {
                                            Write-Host ""
                                            Write-Host "Trigger #$triggerCount" -ForegroundColor Cyan
                                        }
                                        
                                        # First pass - collect and display non-Repetition properties
                                        $repetitionValue = $null
                                        $propertiesDisplayed = $false
                                        foreach ($prop in $triggerProperties) {
                                            try {
                                                $value = $trigger.$prop
                                                
                                                if ($null -ne $value -and $value -ne '') {
                                                    # Store Repetition for second pass
                                                    if ($prop -eq 'Repetition' -and $value.GetType().Name -eq 'CimInstance') {
                                                        $repetitionValue = $value
                                                        continue
                                                    }
                                                    
                                                    # Skip PSComputerName, CimInstanceProperties, and other internal properties
                                                    if ($prop -in @('PSComputerName', 'CimInstanceProperties', 'CimSystemProperties')) {
                                                        continue
                                                    }
                                                    
                                                    # Display all other properties normally
                                                    $propName = $prop.PadRight(18)
                                                    Write-Host "$propName : " -NoNewline -ForegroundColor Yellow
                                                    
                                                    if ($prop -eq 'Enabled' -and $value -eq $false) {
                                                        Write-Host $value -ForegroundColor Red
                                                    }
                                                    elseif ($prop -eq 'CimClass') {
                                                        Write-Host $value.CimClassName -ForegroundColor DarkGray
                                                    }
                                                    else {
                                                        Write-Host $value -ForegroundColor DarkGray
                                                    }
                                                    
                                                    $propertiesDisplayed = $true
                                                }
                                            }
                                            catch {
                                                # Skip properties that can't be accessed
                                            }
                                        }
                                        
                                        # Second pass - display Repetition and its expanded properties
                                        if ($null -ne $repetitionValue) {
                                            try {
                                                Write-Host "Repetition         : " -NoNewline -ForegroundColor Yellow
                                                Write-Host $repetitionValue.CimClass.CimClassName -ForegroundColor DarkGray
                                                $propertiesDisplayed = $true
                                                
                                                # Expand repetition properties on separate indented lines
                                                if ($repetitionValue.Interval) {
                                                    Write-Host "Interval           : " -NoNewline -ForegroundColor Yellow
                                                    Write-Host $repetitionValue.Interval -ForegroundColor DarkGray
                                                }
                                                if ($repetitionValue.Duration) {
                                                    Write-Host "Duration           : " -NoNewline -ForegroundColor Yellow
                                                    Write-Host $repetitionValue.Duration -ForegroundColor DarkGray
                                                }
                                                if ($null -ne $repetitionValue.StopAtDurationEnd) {
                                                    Write-Host "StopAtDurationEnd  : " -NoNewline -ForegroundColor Yellow
                                                    Write-Host $repetitionValue.StopAtDurationEnd -ForegroundColor DarkGray
                                                }
                                            }
                                            catch {
                                                # Continue if repetition properties can't be accessed
                                            }
                                        }
                                        # If no properties were displayed, show a message
                                        if (-not $propertiesDisplayed) {
                                            Write-Host "Status       : " -NoNewline -ForegroundColor Yellow
                                            Write-Host "No displayable properties" -ForegroundColor DarkGray
                                        }
                                    }
                                    catch {
                                        Write-Host "Trigger #$triggerCount : " -NoNewline -ForegroundColor Yellow
                                        Write-Host "Parse error" -ForegroundColor Red
                                    }
                                }
                            }
                            elseif ($result.TriggerTypes) {
                                Write-Host "Types        : " -NoNewline -ForegroundColor Yellow
                                Write-Host $result.TriggerTypes -ForegroundColor DarkGray
                            }
                            else {
                                Write-Host "Status       : " -NoNewline -ForegroundColor Yellow
                                Write-Host "No Triggers Found" -ForegroundColor DarkGray
                            }
                        }
                    }
                    catch {
                        Write-Verbose "Error displaying result for task '$($result.TaskName)': $($_.Exception.Message)"
                        continue
                    }
                }
            }
            elseif (-not $Quiet) {
                Write-Host ""
                Write-Host "[!] No tasks matched the specified criteria." -ForegroundColor Yellow
            }

            # Export to CSV if requested
            if (-not [string]::IsNullOrWhiteSpace($OutputCSV) -and $script:TaskResults.Count -gt 0) {
                try {
                    $csvPath = Get-CSVFileName -OutputPath $OutputCSV
                    if ($csvPath) {
                        # Ensure parent directory exists
                        $parentDir = Split-Path $csvPath -Parent
                        if (-not [string]::IsNullOrWhiteSpace($parentDir) -and -not (Test-Path $parentDir -PathType Container)) {
                            New-Item -ItemType Directory -Path $parentDir -Force -ErrorAction Stop | Out-Null
                        }
                        
                        # Prepare CSV data with sanitized values
                        $csvData = $script:TaskResults | ForEach-Object {
                            [PSCustomObject]@{
                                TaskName           = Sanitize-CSVValue $_.TaskName
                                TaskPath           = Sanitize-CSVValue $_.TaskPath
                                State              = Sanitize-CSVValue $_.State
                                RunAsUser          = Sanitize-CSVValue $_.RunAsUser
                                LogonType          = Sanitize-CSVValue $_.LogonType
                                RunLevel           = Sanitize-CSVValue $_.RunLevel
                                Author             = Sanitize-CSVValue $_.Author
                                Description        = Sanitize-CSVValue $_.Description
                                LastRunTime        = if ($_.LastRunTime -is [DateTime]) { $_.LastRunTime.ToString("yyyy-MM-dd HH:mm:ss") } else { "" }
                                NextRunTime        = if ($_.NextRunTime -is [DateTime]) { $_.NextRunTime.ToString("yyyy-MM-dd HH:mm:ss") } else { "" }
                                TaskFilePath       = Sanitize-CSVValue $_.TaskFilePath
                                TaskFileExists     = $_.TaskFileExists
                                TaskFileSHA256     = Sanitize-CSVValue $_.TaskFileSHA256
                                TaskFileCreated    = if ($_.TaskFileCreated -is [DateTime]) { $_.TaskFileCreated.ToString("yyyy-MM-dd HH:mm:ss") } else { "N/A" }
                                TaskFileModified   = if ($_.TaskFileModified -is [DateTime]) { $_.TaskFileModified.ToString("yyyy-MM-dd HH:mm:ss") } else { "N/A" }
                                ExecutablePath     = Sanitize-CSVValue $_.ExecutablePath
                                ExecutableExists   = $_.ExecutableExists
                                ExecutableSHA256   = Sanitize-CSVValue $_.ExecutableSHA256
                                ExecutableModified = if ($_.ExecutableModified -is [DateTime]) { $_.ExecutableModified.ToString("yyyy-MM-dd HH:mm:ss") } else { "N/A" }
                                Arguments          = Sanitize-CSVValue $_.Arguments
                                ScriptFilePath     = Sanitize-CSVValue $_.ScriptFilePath
                                ScriptFileExists   = $_.ScriptFileExists
                                ScriptFileSHA256   = Sanitize-CSVValue $_.ScriptFileSHA256
                                WorkingDirectory   = Sanitize-CSVValue $_.WorkingDirectory
                                TriggerTypes       = Sanitize-CSVValue $_.TriggerTypes
                                Hostname           = Sanitize-CSVValue $_.Hostname
                            }
                        }
            
                        # Export to CSV
                        $csvData | Export-Csv -Path $csvPath -NoTypeInformation -Encoding UTF8 -ErrorAction Stop
            
                        if (-not $Quiet) {
                            Write-Host "`nResults exported to CSV: $csvPath" -ForegroundColor Green
                        }
                        Write-Verbose "[INFO]: CSV export successful: $csvPath"
                    }
                }
                catch {
                    Write-Warning "Failed to export CSV: $($_.Exception.Message)"
                    Write-Verbose "[ERROR]: CSV export failed: $($_.Exception.Message)"
                }
            }
            elseif (-not [string]::IsNullOrWhiteSpace($OutputCSV) -and $script:TaskResults.Count -eq 0) {
                if (-not $Quiet) {
                    Write-Host ""
                    Write-Host "[!] No results to export to CSV (no tasks matched criteria)." -ForegroundColor Yellow
                }
            }

            # Summary and return logic
            if (-not $Quiet) {
                Write-Host ""
                Write-Host ""
                Write-Host "----------------------------------------" -ForegroundColor Gray
            }

            Write-Verbose "[INFO]: Processed $taskCount tasks, found $matchCount matching results."
            if ($Search) {
                Write-Verbose "[INFO]: Search filter applied: '$Search'" 
            }
            if ($Path) {
                Write-Verbose "[INFO]: Path filter applied: '$Path'"
            }
            if ($dateFilterActive) {
                Write-Verbose "[INFO]: Date range filter applied: $($startDateFilter.ToString('yyyy-MM-dd HH:mm:ss')) to $($endDateFilter.ToString('yyyy-MM-dd HH:mm:ss'))"
            }
            if (-not $IncludeDisabled) {
                Write-Verbose "[INFO]: Disabled tasks excluded." 
            }
            if (-not [string]::IsNullOrWhiteSpace($OutputCSV)) {
                Write-Verbose "[INFO]: CSV output requested: $OutputCSV"
            }

            # Complete progress
            Write-Progress -Activity "Enumerating Scheduled Tasks" -Status "Complete" -PercentComplete 100 -Completed

            # Return objects only if PassThru is specified
            if ($PassThru) {
                return $script:TaskResults.ToArray()
            }
        }
        catch {
            Write-Host "[ERROR]: Failed to enumerate scheduled tasks: $($_.Exception.Message)" -ForegroundColor Red
            if ($PassThru) {
                return @()
            }
        }
    }
}


function Hunt-Registry {
    <#
.SYNOPSIS
Hunt-Registry searches Windows registry for specified strings and autorun persistence locations. Default Mode: RunKeys.

.DESCRIPTION
Hunt-Registry is a DFIR function that searches the Windows registry for specified strings across keys, values, and data. 
It can also enumerate all autorun registry locations commonly used for persistence. The function supports searching 
specific registry hives, loading unloaded user profiles, and exporting results to CSV format.

Default Behavior: When called without parameters, Hunt-Registry runs in RunKeys mode to enumerate autorun locations.

.PARAMETER Search
Array of strings to search for in registry keys, value names, and value data. Not required when using -RunKeys (default mode).

.PARAMETER Type
Specifies what to search: Key, Value, StringValue, BinaryValue, DWordValue, QWordValue, MultiStringValue, ExpandStringValue, or All.

.PARAMETER Hive
Specifies which registry hive to search: HKLM, HKCU, HKCR, HKU, HKCC, or All.

.PARAMETER Path
Array of registry paths to limit search scope. Supports wildcards and multiple formats:
- PowerShell format: "HKLM:\Software\Microsoft\Windows"
- Registry format: "Registry::HKEY_LOCAL_MACHINE\Software\Microsoft"
- Relative format: "Software\Microsoft\Windows" (combined with -Hive parameter)
Significantly improves performance by limiting search scope.

.PARAMETER RunKeys
Switch to retrieve all autorun registry locations instead of searching for specific strings. This is the default mode when no Search parameter is provided.

.PARAMETER LoadHives
Switch to load unloaded user registry hives. Requires administrator privileges.

.PARAMETER PassThru
Switch to return results as PowerShell objects instead of just displaying them.

.PARAMETER OutputCSV
Path to export results to CSV. Can be a file path or directory path (will auto-generate filename).

.PARAMETER Quiet
Switch to suppress console output (errors and warnings still shown).

.EXAMPLE
Hunt-Registry
Retrieves all autorun registry locations (default RunKeys mode).

.EXAMPLE
Hunt-Registry -Search @("malware", "backdoor") -Type All
Searches all registry hives for keys, values, or data containing "malware" or "backdoor".

.EXAMPLE
Hunt-Registry -RunKeys -OutputCSV "C:\Reports\"
Retrieves all autorun registry locations and exports to CSV in C:\Reports\ directory.

.EXAMPLE
Hunt-Registry -Search @("powershell.exe") -Hive HKLM -Type StringValue -PassThru -Quiet
Searches HKLM for string values containing "powershell.exe", returns objects silently.

.EXAMPLE
Hunt-Registry -Search @("evil.exe") -LoadHives -PassThru
Searches all hives including unloaded user profiles for "evil.exe".

.EXAMPLE
Hunt-Registry -Search "malware" -Path "HKLM:\Software\Microsoft\Windows"
Searches only the specified registry path for "malware", improving performance.

.EXAMPLE
Hunt-Registry -Search "*.exe" -Path "Software\Microsoft\Windows\*\Run*" -Hive HKLM
Searches Run keys under Windows using wildcard paths for scoped analysis.
#>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [string[]]$Search = @(),

        [Parameter(Mandatory = $false)]
        [ValidateSet('Key', 'Value', 'StringValue', 'BinaryValue', 'DWordValue', 'QWordValue', 'MultiStringValue', 'ExpandStringValue', 'All')]
        [string]$Type = 'All',

        [Parameter(Mandatory = $false)]
        [ValidateSet('HKLM', 'HKCU', 'HKCR', 'HKU', 'HKCC', 'All')]
        [string]$Hive = 'All',

        [Parameter(Mandatory = $false)]
        [string[]]$Path = @(),

        [Parameter(Mandatory = $false)]
        [switch]$RunKeys,

        [Parameter(Mandatory = $false)]
        [switch]$LoadHives,

        [Parameter(Mandatory = $false)]
        [switch]$PassThru,

        [Parameter(Mandatory = $false)]
        [string]$OutputCSV,

        [Parameter(Mandatory = $false)]
        [switch]$Quiet
    )

    # Store hive parameter in script scope to avoid validation conflicts
    $script:HiveFilter = $Hive

    # Initialize variables
    $hostname = $env:COMPUTERNAME
    $results = @()

    # Known Run keys from Hunt-Persistence - Comprehensive autorun locations
    $runKeyPaths = @(
        'SOFTWARE\Microsoft\Windows\CurrentVersion\Run',
        'SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce',
        'SOFTWARE\Microsoft\Windows\CurrentVersion\RunServices',
        'SOFTWARE\Microsoft\Windows\CurrentVersion\RunServicesOnce',
        'SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run',
        'SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx',
        'SOFTWARE\Microsoft\Windows\CurrentVersion\RunEx',
        'SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run',
        'SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\RunOnce',
        'SOFTWARE\Microsoft\Windows NT\CurrentVersion\Terminal Server\Install\Software\Microsoft\Windows\CurrentVersion\Run',
        'SOFTWARE\Microsoft\Windows NT\CurrentVersion\Terminal Server\Install\Software\Microsoft\Windows\CurrentVersion\RunOnce',
        'SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\System',
        'SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit',
        'SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell',
        'SOFTWARE\Microsoft\Windows\CurrentVersion\ShellServiceObjectDelayLoad',
        'SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\SharedTaskScheduler',
        'SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\ShellExecuteHooks',
        'SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\ShellIconOverlayIdentifiers',
        'SOFTWARE\Microsoft\Active Setup\Installed Components'
    )


    function ConvertTo-SafeCSV {
        param($Results)
        
        if (-not $Results -or $Results.Count -eq 0) {
            return @()
        }
    
        try {
            foreach ($result in $Results) {
                if (-not $result) { continue }
                
                # Sanitize each property to be Excel-safe with null checks
                if ($result.PSObject.Properties.Name -contains 'KeyPath') {
                    $result.KeyPath = Format-ExcelSafeString $result.KeyPath
                }
                if ($result.PSObject.Properties.Name -contains 'ValueName') {
                    $result.ValueName = Format-ExcelSafeString $result.ValueName
                }
                if ($result.PSObject.Properties.Name -contains 'ValueData') {
                    # Handle value data specially - could be complex types
                    try {
                        if ($null -ne $result.ValueData) {
                            if ($result.ValueData -is [string]) {
                                $result.ValueData = Format-ExcelSafeString $result.ValueData
                            }
                            elseif ($result.ValueData -is [array]) {
                                $result.ValueData = Format-ExcelSafeString ($result.ValueData -join '; ')
                            }
                            else {
                                $result.ValueData = Format-ExcelSafeString $result.ValueData.ToString()
                            }
                        }
                        else {
                            $result.ValueData = ""
                        }
                    }
                    catch {
                        $result.ValueData = "[Data conversion error]"
                    }
                }
                if ($result.PSObject.Properties.Name -contains 'Hostname') {
                    $result.Hostname = Format-ExcelSafeString $result.Hostname
                }
                if ($result.PSObject.Properties.Name -contains 'Hive') {
                    $result.Hive = Format-ExcelSafeString $result.Hive
                }
                if ($result.PSObject.Properties.Name -contains 'ValueType') {
                    $result.ValueType = Format-ExcelSafeString $result.ValueType
                }
                if ($result.PSObject.Properties.Name -contains 'LastWriteTime') {
                    $result.LastWriteTime = Format-ExcelSafeString $result.LastWriteTime
                }
            }
            return $Results
        }
        catch {
            Write-Warning "Error sanitizing CSV data: $($_.Exception.Message)"
            return $Results
        }
    }

    function Export-ResultsToCSV {
        param(
            [array]$Results,
            [string]$OutputPath
        )

        try {
            # Determine output file path
            if (Test-Path $OutputPath -PathType Container -ErrorAction SilentlyContinue) {
                # It's a directory, generate filename
                $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
                $filename = "Hunt-Registry_Results_$timestamp.csv"
                $fullPath = Join-Path $OutputPath $filename
            }
            else {
                # It's a file path
                $directory = Split-Path $OutputPath -Parent
                if (-not [string]::IsNullOrEmpty($directory) -and !(Test-Path $directory -ErrorAction SilentlyContinue)) {
                    try {
                        New-Item -ItemType Directory -Path $directory -Force -ErrorAction Stop | Out-Null
                        Write-Verbose "Created directory: $directory"
                    }
                    catch {
                        Write-Warning "Could not create directory: $directory"
                        return $null
                    }
                }
                $fullPath = $OutputPath
            }

            # Ensure .csv extension
            if (![System.IO.Path]::HasExtension($fullPath) -or [System.IO.Path]::GetExtension($fullPath) -ne '.csv') {
                $fullPath += '.csv'
            }

            # Ensure parent directory exists before export
            $parentDir = Split-Path $fullPath -Parent
            if (-not [string]::IsNullOrWhiteSpace($parentDir) -and -not (Test-Path $parentDir -PathType Container)) {
                New-Item -ItemType Directory -Path $parentDir -Force -ErrorAction Stop | Out-Null
                Write-Verbose "Created parent directory: $parentDir"
            }

            # Sanitize results for Excel
            $safeResults = ConvertTo-SafeCSV $Results

            # Export to CSV with error handling
            $safeResults | Export-Csv -Path $fullPath -NoTypeInformation -Encoding UTF8 -ErrorAction Stop

            if (-not $Quiet) {
                Write-Host "[CSV] Results exported to: $fullPath" -ForegroundColor Green
            }

            return $fullPath
        }
        catch {
            Write-Warning "Failed to export CSV: $($_.Exception.Message)"
            return $null
        }
    }

    function Format-ExcelSafeString {
        param([string]$InputString)
    
        if ([string]::IsNullOrWhiteSpace($InputString)) {
            return ""
        }
        
        try {
            # Convert to string if needed (handles non-string types)
            $stringValue = $InputString.ToString()
            
            # Prevent Excel formula injection - prepend with single quote if starts with dangerous char
            if ($stringValue -match '^[=@+\-]') {
                $stringValue = "'" + $stringValue
            }
            
            # Remove control characters and non-printable characters
            $safeString = $stringValue -replace '[\x00-\x1F\x7F]', ''
            
            # Escape double quotes by doubling them (CSV standard)
            $safeString = $safeString -replace '"', '""'
            
            # Truncate if too long for Excel (32,767 character limit per cell)
            if ($safeString.Length -gt 32000) {
                $safeString = $safeString.Substring(0, 32000) + "...[TRUNCATED]"
            }
            
            return $safeString
        }
        catch {
            Write-Verbose "Error sanitizing string: $($_.Exception.Message)"
            return ""
        }
    }


    function New-RegistryResult {
        param(
            [string]$Hostname,
            [string]$HiveName,
            [string]$KeyPath,
            [string]$ValueName = $null,
            [string]$ValueType = $null,
            [string]$ValueData = $null,
            [string]$LastWriteTime = $null
        )
        
        return [PSCustomObject]@{
            Hostname      = $Hostname
            Hive          = $HiveName
            KeyPath       = $KeyPath
            ValueName     = $ValueName
            ValueType     = $ValueType
            ValueData     = $ValueData
            LastWriteTime = $LastWriteTime
        }
    }

    function Get-HiveNameFromPath {
        param([string]$HivePath)
        
        # Handle full Registry:: paths
        if ($HivePath -like "*Registry::HKEY_LOCAL_MACHINE*") {
            return "HKEY_LOCAL_MACHINE"
        }
        elseif ($HivePath -like "*Registry::HKEY_CURRENT_USER*") {
            return "HKEY_CURRENT_USER"
        }
        elseif ($HivePath -like "*Registry::HKEY_CLASSES_ROOT*") {
            return "HKEY_CLASSES_ROOT"
        }
        elseif ($HivePath -like "*Registry::HKEY_USERS*") {
            return "HKEY_USERS"
        }
        elseif ($HivePath -like "*Registry::HKEY_CURRENT_CONFIG*") {
            return "HKEY_CURRENT_CONFIG"
        }
        # Handle PowerShell drive paths (HKLM:\, HKCU:\, etc.)
        elseif ($HivePath -match '^HKLM:') {
            return "HKEY_LOCAL_MACHINE"
        }
        elseif ($HivePath -match '^HKCU:') {
            return "HKEY_CURRENT_USER"
        }
        elseif ($HivePath -match '^HKCR:') {
            return "HKEY_CLASSES_ROOT"
        }
        elseif ($HivePath -match '^HKU:') {
            return "HKEY_USERS"
        }
        elseif ($HivePath -match '^HKCC:') {
            return "HKEY_CURRENT_CONFIG"
        }
        else {
            return Split-Path $HivePath -Leaf
        }
    }

    function ConvertTo-RegistryPath {
        param(
            [string]$InputPath,
            [string]$BaseHive
        )
        
        if ([string]::IsNullOrWhiteSpace($InputPath)) {
            return $null
        }
        
        try {
            # Already in PowerShell provider format (HKLM:\, HKCU:\, etc.)
            if ($InputPath -match '^HK(LM|CU|CR|U|CC):') {
                return $InputPath
            }
            
            # Registry:: format - convert to PowerShell format
            if ($InputPath -match '^Registry::HKEY_LOCAL_MACHINE') {
                return $InputPath -replace '^Registry::HKEY_LOCAL_MACHINE', 'HKLM:'
            }
            if ($InputPath -match '^Registry::HKEY_CURRENT_USER') {
                return $InputPath -replace '^Registry::HKEY_CURRENT_USER', 'HKCU:'
            }
            if ($InputPath -match '^Registry::HKEY_CLASSES_ROOT') {
                return $InputPath -replace '^Registry::HKEY_CLASSES_ROOT', 'HKCR:'
            }
            if ($InputPath -match '^Registry::HKEY_USERS') {
                return $InputPath -replace '^Registry::HKEY_USERS', 'HKU:'
            }
            if ($InputPath -match '^Registry::HKEY_CURRENT_CONFIG') {
                return $InputPath -replace '^Registry::HKEY_CURRENT_CONFIG', 'HKCC:'
            }
            
            # Relative path - combine with BaseHive
            if (![string]::IsNullOrWhiteSpace($BaseHive)) {
                # Remove leading backslash if present
                $cleanPath = $InputPath.TrimStart('\')
                return "$BaseHive\$cleanPath"
            }
            
            Write-Verbose "Could not determine registry path format for: $InputPath"
            return $null
        }
        catch {
            Write-Verbose "Error converting registry path: $($_.Exception.Message)"
            return $null
        }
    }

    function Get-RegistryPathsToSearch {
        param(
            [string[]]$UserPaths,
            [string]$HiveFilter,
            [array]$AvailableHives
        )
        
        $pathsToSearch = [System.Collections.Generic.List[string]]::new()
        
        # If user specified paths, normalize and use them
        if ($UserPaths -and $UserPaths.Count -gt 0) {
            foreach ($userPath in $UserPaths) {
                if ([string]::IsNullOrWhiteSpace($userPath)) { continue }
                
                # Try to convert to proper format
                $convertedPath = ConvertTo-RegistryPath -InputPath $userPath -BaseHive ""
                
                # If conversion failed and we have a hive filter, try with hive prefix
                if (-not $convertedPath -and $HiveFilter -ne 'All') {
                    $hivePrefix = switch ($HiveFilter) {
                        'HKLM' { 'HKLM:' }
                        'HKCU' { 'HKCU:' }
                        'HKCR' { 'HKCR:' }
                        'HKU' { 'HKU:' }
                        'HKCC' { 'HKCC:' }
                        default { $null }
                    }
                    
                    if ($hivePrefix) {
                        $convertedPath = ConvertTo-RegistryPath -InputPath $userPath -BaseHive $hivePrefix
                    }
                }
                
                if ($convertedPath) {
                    # Handle wildcards - expand paths if wildcard present
                    if ($convertedPath -match '[\*\?]') {
                        try {
                            $expandedPaths = @(Get-Item -Path $convertedPath -ErrorAction SilentlyContinue)
                            foreach ($expandedPath in $expandedPaths) {
                                if ($expandedPath) {
                                    $pathsToSearch.Add($expandedPath.PSPath)
                                }
                            }
                        }
                        catch {
                            Write-Verbose "Could not expand wildcard path: $convertedPath"
                        }
                    }
                    else {
                        # Add path directly if no wildcards
                        if (Test-Path $convertedPath -ErrorAction SilentlyContinue) {
                            $pathsToSearch.Add($convertedPath)
                        }
                        else {
                            Write-Verbose "Path does not exist: $convertedPath"
                        }
                    }
                }
            }
        }
        else {
            # No user paths - use available hives (default behavior)
            foreach ($hive in $AvailableHives) {
                $pathsToSearch.Add($hive)
            }
        }
        
        return $pathsToSearch.ToArray()
    }

    function Search-RegistryRecursive {
        param(
            [string]$HivePath,
            [string[]]$SearchTerms,
            [string]$SearchType
        )

        $hiveResults = @()

        # Add progress tracking
        $totalKeys = 0
        $processedKeys = 0

        # Extract hive name from PSPath format
        $hiveName = Get-HiveNameFromPath -HivePath $HivePath

        try {
            # Get keys to search - include the target key itself plus subkeys
            $keysToSearch = [System.Collections.Generic.List[object]]::new()
            
            try {
                # First, add the target key itself (this is critical for searching values IN the specified key)
                $targetKey = Get-Item -Path $HivePath -ErrorAction SilentlyContinue
                if ($targetKey) {
                    $keysToSearch.Add($targetKey)
                }
                
                # Then add all subkeys recursively
                $subKeys = Get-ChildItem -Path $HivePath -Recurse -ErrorAction SilentlyContinue
                if ($subKeys) {
                    foreach ($subKey in $subKeys) {
                        $keysToSearch.Add($subKey)
                    }
                }
            }
            catch {
                Write-Verbose "Error enumerating keys for path: $HivePath"
            }
            
            $keys = $keysToSearch.ToArray()
            $totalKeys = $keys.Count
            
            # Early exit if no keys found
            if ($totalKeys -eq 0) {
                Write-Verbose "No keys found in path: $HivePath"
                return $hiveResults
            }
    
            if (-not $Quiet -and $totalKeys -gt 0) {
                Write-Progress -Activity "Searching Registry" -Status "Processing $hiveName" -PercentComplete 0
            }
    
            foreach ($key in $keys) {
                $processedKeys++
        
                if (-not $Quiet -and $totalKeys -gt 0 -and ($processedKeys % 100) -eq 0) {
                    $percentComplete = [math]::Round(($processedKeys / $totalKeys) * 100)
                    Write-Progress -Activity "Searching Registry" -Status "Processing $hiveName ($processedKeys of $totalKeys)" -PercentComplete $percentComplete
                }
            
                try {
                    $keyPath = $key.Name
            
                    # Get key last write time using .NET registry API
                    $keyLastWriteTime = $null
                    try {
                        # Extract the registry path components
                        $regPath = $key.Name
                        
                        # Determine hive and subkey path
                        $hiveMatch = $null
                        $subKeyPath = $null
                        
                        if ($regPath -match '^HKEY_LOCAL_MACHINE\\(.*)') {
                            $hiveMatch = [Microsoft.Win32.Registry]::LocalMachine
                            $subKeyPath = $matches[1]
                        }
                        elseif ($regPath -match '^HKEY_CURRENT_USER\\(.*)') {
                            $hiveMatch = [Microsoft.Win32.Registry]::CurrentUser
                            $subKeyPath = $matches[1]
                        }
                        elseif ($regPath -match '^HKEY_CLASSES_ROOT\\(.*)') {
                            $hiveMatch = [Microsoft.Win32.Registry]::ClassesRoot
                            $subKeyPath = $matches[1]
                        }
                        elseif ($regPath -match '^HKEY_USERS\\(.*)') {
                            $hiveMatch = [Microsoft.Win32.Registry]::Users
                            $subKeyPath = $matches[1]
                        }
                        elseif ($regPath -match '^HKEY_CURRENT_CONFIG\\(.*)') {
                            $hiveMatch = [Microsoft.Win32.Registry]::CurrentConfig
                            $subKeyPath = $matches[1]
                        }
                        
                        # Open the key and get LastWriteTime
                        if ($hiveMatch -and $subKeyPath) {
                            $regKey = $hiveMatch.OpenSubKey($subKeyPath, $false)
                            if ($regKey) {
                                try {
                                    # Use reflection to access internal LastWriteTime
                                    $regKeyType = [Microsoft.Win32.RegistryKey]
                                    $method = $regKeyType.GetMethod('GetLastWriteTime', [System.Reflection.BindingFlags]'Instance,NonPublic')
                                    if ($method) {
                                        $lastWrite = $method.Invoke($regKey, $null)
                                        if ($lastWrite -and $lastWrite -ne [DateTime]::MinValue) {
                                            $keyLastWriteTime = $lastWrite.ToString("yyyy-MM-dd HH:mm:ss")
                                        }
                                    }
                                }
                                finally {
                                    $regKey.Close()
                                }
                            }
                        }
                    }
                    catch {
                        Write-Verbose "Could not retrieve LastWriteTime for key: $($_.Exception.Message)"
                    }
                    
                    # Search in key names if applicable
                    if ($SearchType -eq 'All' -or $SearchType -eq 'Key') {
                        foreach ($searchTerm in $SearchTerms) {
                            if ($keyPath -like "*$searchTerm*") {
                                $hiveResults += New-RegistryResult -Hostname $hostname -HiveName $hiveName -KeyPath $keyPath -LastWriteTime $keyLastWriteTime
                            }
                        }
                    }
            
                    # Search in values if applicable
                    if ($SearchType -eq 'All' -or $SearchType -in @('Value', 'StringValue', 'BinaryValue', 'DWordValue', 'QWordValue', 'MultiStringValue', 'ExpandStringValue')) {
                        try {
                            $properties = Get-ItemProperty -Path $key.PSPath -ErrorAction SilentlyContinue
                            if ($properties) {
                                $psProperties = @('PSChildName', 'PSDrive', 'PSParentPath', 'PSPath', 'PSProvider')
                        
                                foreach ($prop in (Get-Member -MemberType NoteProperty -InputObject $properties)) {
                                    if ($psProperties.Contains($prop.Name)) { continue }
                            
                                    $valueName = $prop.Name
                                    $valueData = $properties.($prop.Name)
                                    $valueType = "Unknown"
                            
                                    # Determine value type from already-retrieved data (performance optimization)
                                    try {
                                        if ($null -ne $valueData) {
                                            $typeName = $valueData.GetType().Name
                                            $valueType = switch ($typeName) {
                                                'String' { 'String' }
                                                'String[]' { 'MultiString' }
                                                'Int32' { 'DWord' }
                                                'Int64' { 'QWord' }
                                                'Byte[]' { 'Binary' }
                                                default { $typeName }
                                            }
                                        }
                                    }
                                    catch {
                                        Write-Verbose "Error determining value type for $valueName : $($_.Exception.Message)"
                                    }
                            
                                    # Filter by value type if specified
                                    $typeMatch = $false
                                    switch ($SearchType) {
                                        'All' { $typeMatch = $true }
                                        'Value' { $typeMatch = $true }
                                        'StringValue' { $typeMatch = ($valueType -eq 'String') }
                                        'BinaryValue' { $typeMatch = ($valueType -eq 'Binary') }
                                        'DWordValue' { $typeMatch = ($valueType -eq 'DWord') }
                                        'QWordValue' { $typeMatch = ($valueType -eq 'QWord') }
                                        'MultiStringValue' { $typeMatch = ($valueType -eq 'MultiString') }
                                        'ExpandStringValue' { $typeMatch = ($valueType -eq 'String') }
                                    }
                            
                                    if ($typeMatch) {
                                        # Track if this value already matched to avoid duplicates
                                        $alreadyMatched = $false
                                        
                                        # Search in value names
                                        foreach ($searchTerm in $SearchTerms) {
                                            if ($valueName -like "*$searchTerm*") {
                                                $hiveResults += New-RegistryResult -Hostname $hostname -HiveName $hiveName -KeyPath $keyPath -ValueName $valueName -ValueType $valueType -ValueData $valueData -LastWriteTime $keyLastWriteTime
                                                $alreadyMatched = $true
                                                break
                                            }
                                        }
                                
                                        # Search in value data (only if not already matched)
                                        if (-not $alreadyMatched -and $null -ne $valueData) {
                                            try {
                                                $dataString = $null
                                                
                                                # Handle different data types safely
                                                if ($valueData -is [string]) {
                                                    $dataString = $valueData
                                                }
                                                elseif ($valueData -is [array]) {
                                                    # For arrays (like MultiString), join elements
                                                    $dataString = $valueData -join '; '
                                                }
                                                elseif ($valueData -is [byte[]]) {
                                                    # For binary data, convert to hex string (limited to first 1000 bytes)
                                                    $bytesToConvert = if ($valueData.Length -gt 1000) { $valueData[0..999] } else { $valueData }
                                                    $dataString = ($bytesToConvert | ForEach-Object { $_.ToString("X2") }) -join ''
                                                }
                                                else {
                                                    # Fallback for other types
                                                    $dataString = $valueData.ToString()
                                                }
                                                
                                                if (![string]::IsNullOrWhiteSpace($dataString)) {
                                                    foreach ($searchTerm in $SearchTerms) {
                                                        if ($dataString -like "*$searchTerm*") {
                                                            $hiveResults += New-RegistryResult -Hostname $hostname -HiveName $hiveName -KeyPath $keyPath -ValueName $valueName -ValueType $valueType -ValueData $valueData -LastWriteTime $keyLastWriteTime
                                                        }
                                                    }
                                                }
                                            }
                                            catch {
                                                Write-Verbose "Error searching value data for $valueName : $($_.Exception.Message)"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        catch { }
                    }
                }
                catch { continue }
            }
        }
        catch { }

        # Move the Write-Progress completion outside the loops - this was the critical bug
        if (-not $Quiet) {
            Write-Progress -Activity "Searching Registry" -Completed
        }

        return $hiveResults
    }

    function Get-RunKeysOnly {
        $runResults = @()
    
        try {
    
            if (-not $Quiet) {
                Write-Progress -Activity "Retrieving Autorun Keys" -Status "Processing registry hives" -PercentComplete 0
            }
        
            $hiveCount = 0
            $totalHives = $systemAndUsersHives.Count
        
            foreach ($registryHive in $systemAndUsersHives) {
                $hiveCount++
            
                if (-not $Quiet -and $totalHives -gt 0) {
                    $percentComplete = [math]::Round(($hiveCount / $totalHives) * 100)
                    Write-Progress -Activity "Retrieving Autorun Keys" -Status "Processing hive $hiveCount of $totalHives" -PercentComplete $percentComplete
                }
            
                # Extract hive name from PSPath format
                $hiveName = Get-HiveNameFromPath -HivePath $registryHive
    
                foreach ($runPath in $runKeyPaths) {
                    try {
                        $fullPath = "$registryHive\$runPath"
                        $runProps = Get-ItemProperty -Path $fullPath -ErrorAction SilentlyContinue
            
                        if ($null -ne $runProps) {
                            $psProperties = @('PSChildName', 'PSDrive', 'PSParentPath', 'PSPath', 'PSProvider')
                
                            foreach ($prop in (Get-Member -MemberType NoteProperty -InputObject $runProps)) {
                                if ($psProperties.Contains($prop.Name)) { continue }
                    
                                $runResults += New-RegistryResult -Hostname $hostname -HiveName $hiveName -KeyPath $runPath -ValueName $prop.Name -ValueType "String" -ValueData $runProps.($prop.Name) -LastWriteTime $null
                            }
                        }
                    }
                    catch { 
                        Write-Verbose "Error accessing run key $runPath in $hiveName : $($_.Exception.Message)"
                        continue 
                    }
                }
            }
        
            if (-not $Quiet) {
                Write-Progress -Activity "Retrieving Autorun Keys" -Completed
            }
        }
        catch {
            Write-Warning "Error retrieving run keys: $($_.Exception.Message)"
            if (-not $Quiet) {
                Write-Progress -Activity "Retrieving Autorun Keys" -Completed
            }
        }

        return $runResults
    }

    function Write-ColoredRegistryResult {
        param($RegistryResult)
        
        if (-not $RegistryResult) { return }
        
        Write-Host ""
        Write-Host "----------------------------------------" -ForegroundColor Gray     
        
        if ($RegistryResult.Hive) {
            Write-Host "Hive             : " -NoNewline -ForegroundColor Yellow
            Write-Host $RegistryResult.Hive -ForegroundColor White
        }
        
        if ($RegistryResult.KeyPath) {
            Write-Host "Key Path         : " -NoNewline -ForegroundColor Yellow
            Write-Host $RegistryResult.KeyPath -ForegroundColor Cyan
        }
        
        if ($RegistryResult.ValueName) {
            Write-Host "Value Name       : " -NoNewline -ForegroundColor Yellow
            Write-Host $RegistryResult.ValueName -ForegroundColor DarkYellow
            
            if ($RegistryResult.ValueType) {
                Write-Host "Value Type       : " -NoNewline -ForegroundColor Yellow
                Write-Host $RegistryResult.ValueType -ForegroundColor White
            }
            
            if ($null -ne $RegistryResult.ValueData) {
                Write-Host "Value Data       : " -NoNewline -ForegroundColor Yellow
                
                try {
                    # Format value data based on type
                    if ($RegistryResult.ValueData -is [string]) {
                        $displayData = $RegistryResult.ValueData
                    }
                    elseif ($RegistryResult.ValueData -is [array]) {
                        $displayData = $RegistryResult.ValueData -join '; '
                    }
                    elseif ($RegistryResult.ValueData -is [byte[]]) {
                        # Show first 32 bytes of binary data as hex
                        $bytesToShow = if ($RegistryResult.ValueData.Length -gt 32) { 
                            $RegistryResult.ValueData[0..31] 
                        }
                        else { 
                            $RegistryResult.ValueData 
                        }
                        $displayData = ($bytesToShow | ForEach-Object { $_.ToString("X2") }) -join ' '
                        if ($RegistryResult.ValueData.Length -gt 32) {
                            $displayData += "... ($($RegistryResult.ValueData.Length) bytes total)"
                        }
                    }
                    else {
                        $displayData = $RegistryResult.ValueData.ToString()
                    }
                    
                    # Truncate if too long for display
                    if ($displayData.Length -gt 500) {
                        $displayData = $displayData.Substring(0, 500) + "...[TRUNCATED]"
                    }
                    
                    Write-Host $displayData -ForegroundColor Red
                }
                catch {
                    Write-Host "[Error displaying data]" -ForegroundColor Red
                }
            }
        }
        
        if ($RegistryResult.LastWriteTime) {
            Write-Host "Last Write Time  : " -NoNewline -ForegroundColor Yellow
            Write-Host $RegistryResult.LastWriteTime -ForegroundColor DarkGray
        }

    }

    # Get registry hives using shared helper
    try {
        if (Get-Command Get-RegistryHivesForAnalysis -ErrorAction SilentlyContinue) {
            $systemAndUsersHives = Get-RegistryHivesForAnalysis -LoadUnloadedHives:$LoadHives -HiveFilter:$script:HiveFilter -Quiet:$Quiet
        }
        else {
            Write-Error "Required helper function 'Get-RegistryHivesForAnalysis' not found. Ensure ThreatHunter module is properly loaded."
            if ($PassThru) { return @() }
            return
        }
        
        if (-not $systemAndUsersHives -or $systemAndUsersHives.Count -eq 0) {
            Write-Error "No registry hives available for analysis"
            if ($PassThru) { return @() }
            return
        }
    }
    catch {
        Write-Error "Failed to load registry hives: $($_.Exception.Message)"
        if ($PassThru) { return @() }
        return
    }
    
    # Main execution logic
    try {
        Write-Verbose "Starting Hunt-Registry execution..."
        
        # Determine mode: Default to RunKeys if no Search specified
        $effectiveRunKeysMode = $RunKeys -or ($Search.Count -eq 0)
        
        # Handle RunKeys mode (default mode when no Search provided)
        if ($effectiveRunKeysMode) {
            if (-not $Quiet) {
                Write-Host "[INFO] Retrieving all autorun registry locations..." -ForegroundColor Yellow
            }
            
            $results = Get-RunKeysOnly
        }
        else {
            # Search mode - Search parameter already validated by logic above
            
            # if (-not $Quiet) {
            #     Write-Host "[INFO] Searching registry for: $($Search -join ', ')" -ForegroundColor Yellow
            #     Write-Host "[INFO] Search Type: $Type, Hive: $script:HiveFilter" -ForegroundColor Cyan
            #     if ($Path -and $Path.Count -gt 0) {
            #         Write-Host "[INFO] Limited to paths: $($Path -join ', ')" -ForegroundColor Cyan
            #     }
            # }
            
            # Determine paths to search - either user-specified or all hives
            $searchPaths = Get-RegistryPathsToSearch -UserPaths $Path -HiveFilter $script:HiveFilter -AvailableHives $systemAndUsersHives
            
            if (-not $searchPaths -or $searchPaths.Count -eq 0) {
                Write-Warning "No valid registry paths to search. Verify path format and permissions."
                if ($PassThru) {
                    return @()
                }
                return
            }
            
            # Search each path
            foreach ($registryPath in $searchPaths) {
                try {
                    if (-not $Quiet) {
                        # Extract hive name for display
                        $displayName = Get-HiveNameFromPath -HivePath $registryPath
                        
                        # Show more detail if it's a specific path vs full hive
                        if ($registryPath -match '\\') {
                            $pathParts = $registryPath -split '\\'
                            if ($pathParts.Count -gt 2) {
                                $displayName = "$displayName\...\$($pathParts[-1])"
                            }
                        }
                        
                        Write-Host "[SEARCH] Processing: $displayName" -ForegroundColor Cyan
                    }
        
                    $hiveResults = Search-RegistryRecursive -HivePath $registryPath -SearchTerms $Search -SearchType $Type
                    if ($hiveResults) {
                        $results += $hiveResults
                    }
                }
                catch {
                    Write-Verbose "Error searching path $registryPath : $($_.Exception.Message)"
                    continue
                }
            }
        }
        
        # Display results
        if ($results.Count -gt 0) {
            if (-not $Quiet) {
                Write-Host "`n[RESULTS] Found $($results.Count) registry matches" -ForegroundColor Green
                
                foreach ($result in $results) {
                    Write-ColoredRegistryResult $result
                }
                
                # Print closing separator
                Write-Host ""
                Write-Host "----------------------------------------" -ForegroundColor Gray
            }
            
            # Export to CSV if requested
            if ($OutputCSV) {
                $csvPath = Export-ResultsToCSV -Results $results -OutputPath $OutputCSV
                if ($csvPath -and $PassThru) {
                    # Add CSV path property to results for PassThru
                    foreach ($result in $results) {
                        $result | Add-Member -MemberType NoteProperty -Name 'CSVExportPath' -Value $csvPath -Force
                    }
                }
            }
            
            if ($PassThru) {
                return $results
            }
        }
        else {
            if (-not $Quiet) {
                Write-Host "`n[INFO] No registry matches found" -ForegroundColor Yellow
            }
            
            # No CSV export for empty results (avoid creating empty files)
            
            if ($PassThru) {
                return @()
            }
        }
    }
    catch {
        Write-Error "Hunt-Registry failed: $($_.Exception.Message)"
        if ($PassThru) {
            return @()
        }
    }
    finally {
        # Cleanup loaded hives
        if ($LoadHives) {
            try {
                if (Get-Command Dismount-AllRegistryHives -ErrorAction SilentlyContinue) {
                    Dismount-AllRegistryHives -Quiet:$Quiet
                }
                else {
                    Write-Verbose "Dismount-AllRegistryHives function not available for cleanup"
                }
            }
            catch {
                Write-Warning "Failed to dismount registry hives: $($_.Exception.Message)"
            }
        }
    }
}


function Hunt-Services {
    <#
    .SYNOPSIS
    Hunt-Services enumerates and analyzes Windows services for DFIR investigations.
    
    .DESCRIPTION
    Hunt-Services provides comprehensive analysis of Windows services including:
    - Service metadata (name, display name, status, start type)
    - Executable file analysis with SHA256 hashes and timestamps (SHA256 in default output)
    - Service configuration details (account, dependencies)
    - Search filtering across all service properties
    - CSV export with Excel-compatible sanitization
    - Silent operation mode for automation
    - Concise display by default, expandable with -More switch
    - svchost.exe service DLL resolution via registry analysis
    
    This function is designed for digital forensics, incident response, threat hunting,
    and security auditing activities where comprehensive service analysis is required.
    
    .PARAMETER Search
    Filter results using wildcard patterns. Searches across service names, paths, descriptions,
    accounts, and all other service properties. Case-insensitive matching.
    
    .PARAMETER Type
    Filter services by start type: Automatic, Manual, Disabled, Boot, System, or All.
    
    .PARAMETER SortOrder
    Sort services by executable last modified date. Options: NewestFirst (default) or OldestFirst.
    Services without modification dates appear last in NewestFirst, first in OldestFirst.
    
    .PARAMETER More
    Display all available fields including account, description, last modified date,
    dependencies, and additional metadata. Default output shows only core fields.
    
    .PARAMETER PassThru
    Return PowerShell objects for further processing instead of just displaying results.
    All fields are included in objects regardless of -More switch.
    
    .PARAMETER Quiet
    Suppress console output except for errors and warnings.
    
    .PARAMETER OutputCSV
    Export results to CSV format. Accepts either:
    - Full file path: "C:\Analysis\services.csv"
    - Directory path: "C:\Analysis\" (auto-generates filename with timestamp)
    All fields are exported regardless of -More switch.
    
    .EXAMPLE
    Hunt-Services
    Display all Windows services with concise output (core fields only).
    
    .EXAMPLE
    Hunt-Services -More
    Display all Windows services with full details including hashes and timestamps.
    
    .EXAMPLE
    Hunt-Services -Search "*malware*" -Type Automatic -More
    Search for automatic services containing "malware" with full field display.
    
    .EXAMPLE
    Hunt-Services -OutputCSV "C:\DFIR\Analysis\"
    Export all service analysis to auto-generated CSV file with all fields.
    
    .EXAMPLE
    $suspiciousServices = Hunt-Services -Search "*persist*" -PassThru -Quiet
    Silently collect services with "persist" in any field, return as objects with all fields.
    
    .EXAMPLE
    Hunt-Services -Type Disabled -More -OutputCSV ".\disabled_services.csv"
    Find all disabled services with full details and export to CSV.
    
    .EXAMPLE
    Hunt-Services -SortOrder OldestFirst -More
    Display services sorted by oldest executable modification date first.
    
    .EXAMPLE
    Hunt-Services -Search "*svchost*" -SortOrder NewestFirst
    Find services matching "svchost" sorted by newest modifications first.
    
    .NOTES
    Requirements: PowerShell 5.0+, Windows
    Privileges: Administrator recommended for complete service enumeration
    Output: Displays forensic analysis or returns PSCustomObjects via -PassThru
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [string[]]$Search = @(),

        [Parameter(Mandatory = $false)]
        [ValidateSet('Automatic', 'Manual', 'Disabled', 'Boot', 'System', 'All')]
        [string]$Type = 'All',

        [Parameter(Mandatory = $false)]
        [ValidateSet('NewestFirst', 'OldestFirst')]
        [string]$SortOrder = 'NewestFirst',

        [Parameter(Mandatory = $false)]
        [switch]$More,

        [Parameter(Mandatory = $false)]
        [switch]$PassThru,

        [Parameter(Mandatory = $false)]
        [switch]$Quiet,

        [Parameter(Mandatory = $false)]
        [string]$OutputCSV = ""
    )

    

    # Get the true service executable (including DLLs for svchost services)
    function Get-ServiceExecutable {
        param([string]$ServiceName, [string]$CommandLine)
        
        if ([string]::IsNullOrWhiteSpace($ServiceName) -or [string]::IsNullOrWhiteSpace($CommandLine)) {
            return $CommandLine
        }
        
        try {
            $cmdLineExe = Get-FileFromCommandLine -CommandLine $CommandLine
            
            if ($cmdLineExe -and $cmdLineExe -match 'svchost\.exe$') {
                try {
                    # Sanitize service name for registry path (remove potentially dangerous chars)
                    $sanitizedServiceName = $ServiceName -replace '[\\\/\:\*\?\"\<\>\|]', '_'
                    
                    # Method 1: Check Parameters subkey for ServiceDll
                    $regPath = "HKLM:\SYSTEM\CurrentControlSet\Services\$sanitizedServiceName\Parameters"
                    if (Test-Path $regPath -ErrorAction SilentlyContinue) {
                        try {
                            $serviceDll = (Get-ItemProperty $regPath -Name ServiceDll -ErrorAction SilentlyContinue).ServiceDll
                            if (![string]::IsNullOrWhiteSpace($serviceDll)) {
                                $expandedPath = [Environment]::ExpandEnvironmentVariables($serviceDll)
                                if (![string]::IsNullOrWhiteSpace($expandedPath)) {
                                    return $expandedPath
                                }
                            }
                        }
                        catch {
                            Write-Verbose "Error reading ServiceDll from Parameters: $($_.Exception.Message)"
                        }
                    }
                    
                    # Method 2: Check main service key for ServiceDll
                    $regPath2 = "HKLM:\SYSTEM\CurrentControlSet\Services\$sanitizedServiceName"
                    if (Test-Path $regPath2 -ErrorAction SilentlyContinue) {
                        $serviceReg = Get-ItemProperty $regPath2 -ErrorAction SilentlyContinue
                        
                        if ($serviceReg.ServiceDll) {
                            return [Environment]::ExpandEnvironmentVariables($serviceReg.ServiceDll)
                        }
                        
                        # Method 3: Extract DLL path from Description field (for services like AarSvc_2cf489)
                        if ($serviceReg.Description -and $serviceReg.Description -match '@([^,]+\.dll)') {
                            $dllPath = [Environment]::ExpandEnvironmentVariables($matches[1])
                            if (Test-Path $dllPath -ErrorAction SilentlyContinue) {
                                return $dllPath
                            }
                        }
                        
                        # Method 4: Try service name as DLL name (remove suffix after underscore)
                        $baseName = $ServiceName -replace '_.*$', ''
                        $possibleDll = "$env:SystemRoot\system32\$baseName.dll"
                        if (Test-Path $possibleDll -ErrorAction SilentlyContinue) {
                            return $possibleDll
                        }
                        
                        # Method 5: Try full service name as DLL
                        $possibleDll2 = "$env:SystemRoot\system32\$ServiceName.dll"
                        if (Test-Path $possibleDll2 -ErrorAction SilentlyContinue) {
                            return $possibleDll2
                        }
                    }
                }
                catch {
                    Write-Verbose "Could not retrieve service DLL for $ServiceName"
                }
                return $cmdLineExe
            }
            
            return $cmdLineExe
        }
        catch {
            return $CommandLine
        }
    }

    # Get SHA256 hash
    function Get-FileSHA256 {
        param([string]$FilePath)
        
        if ([string]::IsNullOrWhiteSpace($FilePath)) {
            return $null
        }
        
        try {
            if (Test-Path $FilePath -PathType Leaf -ErrorAction SilentlyContinue) {
                $fileInfo = Get-Item $FilePath -Force -ErrorAction Stop
                
                # Skip files larger than 500MB to prevent memory issues
                if ($fileInfo.Length -gt 524288000) {
                    Write-Verbose "File too large for hash calculation: $FilePath ($([math]::Round($fileInfo.Length / 1MB, 2)) MB)"
                    return "File Too Large"
                }
                
                $hash = Get-FileHash -Path $FilePath -Algorithm SHA256 -ErrorAction Stop
                if ($hash -and $hash.Hash) {
                    return $hash.Hash.ToLower()
                }
            }
            return $null
        }
        catch [System.UnauthorizedAccessException] {
            Write-Verbose "Access denied for hash calculation: $FilePath"
            return "Access Denied"
        }
        catch [System.IO.IOException] {
            Write-Verbose "File locked or IO error: $FilePath"
            return "File Locked"
        }
        catch {
            Write-Verbose "Hash calculation error for $FilePath`: $($_.Exception.Message)"
            return $null
        }
    }

    # Test search matches - optimized with early return
    function Test-ServiceMatches {
        param($Service, $ServiceDetails, $Search)
        
        if (-not $Search -or $Search.Count -eq 0) { 
            return $true 
        }
        
        if (-not $Service) {
            return $false
        }
        
        # Build search fields array with null checks
        $searchFields = @()
        if ($Service.Name) { $searchFields += $Service.Name }
        if ($Service.DisplayName) { $searchFields += $Service.DisplayName }
        if ($Service.Status) { $searchFields += $Service.Status.ToString() }
        if ($Service.StartType) { $searchFields += $Service.StartType.ToString() }
        
        if ($ServiceDetails) {
            if ($ServiceDetails.StartName) { $searchFields += $ServiceDetails.StartName }
            if ($ServiceDetails.Description) { $searchFields += $ServiceDetails.Description }
            if ($ServiceDetails.PathName) { $searchFields += $ServiceDetails.PathName }
        }
        
        # Search logic - any match in any field returns true
        foreach ($searchString in $Search) {
            if ([string]::IsNullOrWhiteSpace($searchString)) {
                continue
            }
            
            foreach ($field in $searchFields) {
                try {
                    if ($field -like "*$searchString*") {
                        return $true
                    }
                }
                catch {
                    Write-Verbose "Search match error: $($_.Exception.Message)"
                    continue
                }
            }
        }
        
        return $false
    }

    # Sanitize CSV values
    function Sanitize-CSVValue {
        param([string]$Value)
        
        if ([string]::IsNullOrWhiteSpace($Value)) { 
            return "" 
        }
        
        try {
            # Remove control characters and problematic chars
            $sanitized = $Value -replace '[\x00-\x1F\x7F]', ' '
            $sanitized = $sanitized -replace '["\r\n\t]', ' '
            
            # Prevent Excel formula injection - prepend with single quote if starts with dangerous char
            if ($sanitized -match '^[=+\-@]') {
                $sanitized = "'" + $sanitized
            }
            
            # Trim and limit length
            $sanitized = $sanitized.Trim()
            
            if ($sanitized.Length -gt 32000) {
                $sanitized = $sanitized.Substring(0, 32000) + "...[TRUNCATED]"
            }
            
            return $sanitized
        }
        catch {
            Write-Verbose "CSV sanitization error: $($_.Exception.Message)"
            return ""
        }
    }

    # Get CSV filename
    function Get-CSVFileName {
        param([string]$OutputPath)
        
        if ([string]::IsNullOrWhiteSpace($OutputPath)) { 
            return $null 
        }
        
        try {
            # Check if path is a directory
            if (Test-Path $OutputPath -PathType Container -ErrorAction SilentlyContinue) {
                $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
                return Join-Path $OutputPath "Hunt-Services_Results_$($env:COMPUTERNAME)_$timestamp.csv"
            }
            
            # Check if it's a CSV file path
            if ($OutputPath -match '\.csv$') {
                $parentDir = Split-Path $OutputPath -Parent
                
                # If no parent directory or parent exists, return path
                if ([string]::IsNullOrWhiteSpace($parentDir) -or (Test-Path $parentDir -PathType Container -ErrorAction SilentlyContinue)) {
                    return $OutputPath
                }
                
                # Try to create parent directory
                try {
                    New-Item -ItemType Directory -Path $parentDir -Force -ErrorAction Stop | Out-Null
                    Write-Verbose "[INFO]: Created directory: $parentDir"
                    return $OutputPath
                }
                catch {
                    Write-Warning "Could not create directory: $parentDir"
                    return $null
                }
            }
            
            # Invalid path format
            Write-Warning "Invalid OutputCSV path specified: $OutputPath"
            return $null
        }
        catch {
            Write-Warning "Error processing OutputCSV path: $($_.Exception.Message)"
            return $null
        }
    }

    # Main execution
    try {
        if (-not $Quiet) {
            Write-Host "[+] Enumerating Windows services..." -ForegroundColor Green
        }
        
        $services = Get-Service -ErrorAction Stop
        if ($Type -ne 'All') {
            $services = $services | Where-Object { $_.StartType -eq $Type }
        }

        $results = [System.Collections.Generic.List[PSObject]]::new()
        $totalServices = $services.Count
        $processedCount = 0
        $matchCount = 0
        
        foreach ($service in $services) {
            $processedCount++
            
            if ($processedCount % 50 -eq 0) {
                Write-Progress -Activity "Processing Services" -Status "$processedCount of $totalServices" -PercentComplete (($processedCount / $totalServices) * 100)
            }
            
            try {
                $serviceDetails = Get-CimInstance -ClassName Win32_Service -Filter "Name='$($service.Name)'" -ErrorAction SilentlyContinue
                
                if (-not (Test-ServiceMatches -Service $service -ServiceDetails $serviceDetails -Search $Search)) {
                    continue
                }
                
                $matchCount++
                
                # Get true executable path (including service DLLs)
                $truePath = $null
                $sha256 = $null
                $lastModified = $null
                
                if ($serviceDetails -and $serviceDetails.PathName) {
                    $extractedPath = Get-ServiceExecutable -ServiceName $service.Name -CommandLine $serviceDetails.PathName
                    if ($extractedPath -and (Test-Path $extractedPath -ErrorAction SilentlyContinue)) {
                        $truePath = $extractedPath
                        $fileInfo = Get-Item $extractedPath -ErrorAction SilentlyContinue
                        if ($fileInfo) {
                            $sha256 = Get-FileSHA256 -FilePath $extractedPath
                            $lastModified = $fileInfo.LastWriteTime.ToString("yyyy-MM-dd HH:mm:ss")
                        }
                    }
                    elseif ($extractedPath) {
                        $truePath = $extractedPath
                    }
                }
                
                $serviceResult = [PSCustomObject]@{
                    ServiceName    = $service.Name
                    DisplayName    = $service.DisplayName
                    Status         = $service.Status
                    StartType      = $service.StartType
                    Account        = if ($serviceDetails -and $serviceDetails.StartName) { $serviceDetails.StartName } else { $null }
                    Description    = if ($serviceDetails -and $serviceDetails.Description) { $serviceDetails.Description } else { $null }
                    CommandLine    = if ($serviceDetails -and $serviceDetails.PathName) { $serviceDetails.PathName } else { $null }
                    ExecutablePath = $truePath
                    SHA256         = $sha256
                    LastModified   = $lastModified
                    Dependencies   = if ($service.DependentServices -and $service.DependentServices.Count -gt 0) { ($service.DependentServices.Name -join '; ') } else { $null }
                    CanStop        = $service.CanStop
                    Hostname       = $env:COMPUTERNAME
                }
                
                $results.Add($serviceResult)
            }
            catch {
                Write-Verbose "Error processing service '$($service.Name)': $($_.Exception.Message)"
                continue
            }
        }
        
        Write-Progress -Activity "Processing Services" -Completed
        
        # Handle no results case
        if ($matchCount -eq 0 -and -not $Quiet) {
            Write-Host "[!] No services matched the specified criteria" -ForegroundColor Yellow
        }
        
        # Sort results by LastModified date
        if ($results.Count -gt 0) {
            try {
                if ($SortOrder -eq 'NewestFirst') {
                    # Sort descending - newest first, nulls last
                    $results = [System.Collections.Generic.List[PSObject]]::new(
                        ($results | Sort-Object { 
                            if ($_.LastModified) { 
                                [DateTime]::ParseExact($_.LastModified, "yyyy-MM-dd HH:mm:ss", $null) 
                            } 
                            else { 
                                [DateTime]::MinValue 
                            }
                        } -Descending)
                    )
                }
                else {
                    # Sort ascending - oldest first, nulls first
                    $results = [System.Collections.Generic.List[PSObject]]::new(
                        ($results | Sort-Object { 
                            if ($_.LastModified) { 
                                [DateTime]::ParseExact($_.LastModified, "yyyy-MM-dd HH:mm:ss", $null) 
                            } 
                            else { 
                                [DateTime]::MaxValue 
                            }
                        })
                    )
                }
            }
            catch {
                Write-Verbose "Error sorting results: $($_.Exception.Message)"
                # Continue with unsorted results
            }
        }
        
        # Display results
        if (-not $Quiet -and $results.Count -gt 0) {
            #Write-Host "[+] Displaying $($results.Count) service matches..." -ForegroundColor Cyan
            
            foreach ($result in $results) {
                Write-Host ""
                Write-Host "----------------------------------------" -ForegroundColor Gray
                
                # Core fields - always displayed
                Write-Host "Service Name     : " -NoNewline -ForegroundColor Yellow
                Write-Host $result.ServiceName -ForegroundColor Cyan
                
                if ($result.DisplayName) {
                    Write-Host "Display Name     : " -NoNewline -ForegroundColor Yellow
                    Write-Host $result.DisplayName -ForegroundColor White
                }
                
                Write-Host "Status           : " -NoNewline -ForegroundColor Yellow
                $statusColor = switch ($result.Status) {
                    'Running' { 'Green' }
                    'Stopped' { 'Red' }
                    'Paused' { 'Yellow' }
                    default { 'DarkGray' }
                }
                Write-Host $result.Status -ForegroundColor $statusColor
                
                # Display Command Line only in -More mode or if different from ExecutablePath
                if ($result.CommandLine) {
                    $showCommandLine = $More
                    
                    # In default mode, only show if meaningfully different from ExecutablePath
                    if (-not $More -and $result.ExecutablePath) {
                        $normalizedCmd = $result.CommandLine.Trim().Trim('"').Trim("'")
                        $normalizedExe = $result.ExecutablePath.Trim().Trim('"').Trim("'")
                        
                        # Show if they're different after normalization
                        if ($normalizedCmd -ne $normalizedExe) {
                            $showCommandLine = $true
                        }
                    }
                    
                    if ($showCommandLine) {
                        Write-Host "Command Line     : " -NoNewline -ForegroundColor Yellow
                        Write-Host $result.CommandLine -ForegroundColor Red
                    }
                }
                
                # Always display Executable Path if available
                if ($result.ExecutablePath) {
                    Write-Host "Executable Path  : " -NoNewline -ForegroundColor Yellow
                    Write-Host $result.ExecutablePath -ForegroundColor Green
                }
                
                if ($result.SHA256) {
                    Write-Host "SHA256           : " -NoNewline -ForegroundColor Yellow
                    Write-Host $result.SHA256 -ForegroundColor Gray
                }
                
                if ($result.LastModified) {
                    Write-Host "Last Modified    : " -NoNewline -ForegroundColor Yellow
                    Write-Host $result.LastModified -ForegroundColor DarkGray
                }
                
                # Additional fields - only with -More switch
                if ($More) {
                    Write-Host "Start Type       : " -NoNewline -ForegroundColor Yellow
                    Write-Host $result.StartType -ForegroundColor White
                    
                    if ($result.Account) {
                        Write-Host "Account          : " -NoNewline -ForegroundColor Yellow
                        Write-Host $result.Account -ForegroundColor White
                    }
                    
                    if ($result.Description) {
                        Write-Host "Description      : " -NoNewline -ForegroundColor Yellow
                        Write-Host $result.Description -ForegroundColor DarkGray
                    }
                    
                    if ($result.Dependencies) {
                        Write-Host "Dependencies     : " -NoNewline -ForegroundColor Yellow
                        Write-Host $result.Dependencies -ForegroundColor DarkYellow
                    }
                    
                    Write-Host "Can Stop         : " -NoNewline -ForegroundColor Yellow
                    Write-Host $result.CanStop -ForegroundColor DarkGray
                }
            }
        }
        
        # CSV Export
        if (-not [string]::IsNullOrWhiteSpace($OutputCSV) -and $results.Count -gt 0) {
            try {
                $csvPath = Get-CSVFileName -OutputPath $OutputCSV
                if ($csvPath) {
                    # Ensure parent directory exists
                    $parentDir = Split-Path $csvPath -Parent
                    if (-not [string]::IsNullOrWhiteSpace($parentDir) -and -not (Test-Path $parentDir -PathType Container)) {
                        New-Item -ItemType Directory -Path $parentDir -Force -ErrorAction Stop | Out-Null
                    }
                    
                    $csvData = $results | ForEach-Object {
                        [PSCustomObject]@{
                            ServiceName    = Sanitize-CSVValue $_.ServiceName
                            DisplayName    = Sanitize-CSVValue $_.DisplayName
                            Status         = Sanitize-CSVValue $_.Status
                            StartType      = Sanitize-CSVValue $_.StartType
                            Account        = if ($_.Account) { Sanitize-CSVValue $_.Account } else { "" }
                            Description    = if ($_.Description) { Sanitize-CSVValue $_.Description } else { "" }
                            CommandLine    = if ($_.CommandLine) { Sanitize-CSVValue $_.CommandLine } else { "" }
                            ExecutablePath = if ($_.ExecutablePath) { Sanitize-CSVValue $_.ExecutablePath } else { "" }
                            SHA256         = if ($_.SHA256) { Sanitize-CSVValue $_.SHA256 } else { "" }
                            LastModified   = if ($_.LastModified) { $_.LastModified } else { "" }
                            Dependencies   = if ($_.Dependencies) { Sanitize-CSVValue $_.Dependencies } else { "" }
                            CanStop        = $_.CanStop
                            Hostname       = Sanitize-CSVValue $_.Hostname
                        }
                    }
                    
                    $csvData | Export-Csv -Path $csvPath -NoTypeInformation -Encoding UTF8 -ErrorAction Stop
                    
                    if (-not $Quiet) {
                        Write-Host "[+] Results exported to CSV: $csvPath" -ForegroundColor Green
                    }
                    Write-Verbose "[INFO]: CSV export successful: $csvPath"
                }
                else {
                    Write-Warning "CSV export failed: Unable to determine output path"
                }
            }
            catch {
                Write-Warning "Failed to export CSV: $($_.Exception.Message)"
                Write-Verbose "[ERROR]: CSV export failed: $($_.Exception.Message)"
            }
        }
        elseif (-not [string]::IsNullOrWhiteSpace($OutputCSV) -and $results.Count -eq 0) {
            if (-not $Quiet) {
                Write-Host "[!] No results to export to CSV (no services matched criteria)" -ForegroundColor Yellow
            }
        }
        
        # Summary
        if (-not $Quiet) {
            Write-Host ""
            Write-Host "----------------------------------------" -ForegroundColor Gray
            Write-Host "[+] Processed $processedCount services, found $matchCount matches" -ForegroundColor Green
        }
        
        if ($PassThru) {
            return $results.ToArray()
        }
    }
    catch {
        Write-Error "Hunt-Services failed: $($_.Exception.Message)"
        if ($PassThru) { return @() }
    }
}


function Hunt-VirusTotal {
    <#
    .SYNOPSIS
    Hunt-VirusTotal - DFIR function for VirusTotal file analysis using direct API calls
    
    .DESCRIPTION
    This function provides VirusTotal capabilities for DFIR investigations:
    - Automatically queries hash existence and uploads if not found
    - Monitors upload analysis status until completion
    - Uses direct REST API calls (no module dependencies)
    - Displays results in standardized DFIR format with rich context
    - Supports MD5, SHA1, and SHA256 hashes
    - Handles rate limiting gracefully
    
    Note: Email files (.eml) and archives may be processed by VirusTotal,
    resulting in different file hashes than the original upload.
    
    .PARAMETER FilePath
    Path to file for analysis
    
    .PARAMETER Hash
    File hash (MD5, SHA1, SHA256) to query VirusTotal
    
    .PARAMETER ApiKey
    VirusTotal API key (optional - will prompt if not provided)
    
    .PARAMETER Force
    Force upload even if file already exists in VirusTotal
    
    .PARAMETER More
    Show all available fields from VirusTotal response
    
    .PARAMETER UploadStatus
    Check status of analysis by Analysis ID
    
    .PARAMETER AnalysisId
    Analysis ID to check status for (used with -UploadStatus)
    
    .PARAMETER OutputCSV
    Output results to CSV file
    
    .PARAMETER PassThru
    Return results as PowerShell objects for further processing
    
    .PARAMETER Quiet
    Suppress console output
    
    .PARAMETER ClearSavedKey
    Delete saved API key from session
    
    .EXAMPLE
    Hunt-VirusTotal -FilePath "C:\suspect\malware.exe"
    
    .EXAMPLE
    Hunt-VirusTotal -Hash "e3c925286ccafd07fb61bd6a12a2ee94" -More
    
    .EXAMPLE
    Hunt-VirusTotal -FilePath "C:\suspect\file.exe" -OutputCSV
    
    .EXAMPLE
    Hunt-VirusTotal -Hash "abc123..." -PassThru | Where-Object {$_.Malicious -gt 0}
    
    .EXAMPLE
    Hunt-VirusTotal -FilePath "C:\batch\*.exe" -Quiet -PassThru
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        [string]$FilePath,
        
        [Parameter(Mandatory = $false)]
        [string]$Hash,
        
        [Parameter(Mandatory = $false)]
        [string]$ApiKey,
        
        [Parameter(Mandatory = $false)]
        [switch]$Force,
        
        [Parameter(Mandatory = $false)]
        [switch]$More,
        
        [Parameter(Mandatory = $false)]
        [switch]$UploadStatus,
        
        [Parameter(Mandatory = $false)]
        [string]$AnalysisId,
        
        [Parameter(Mandatory = $false)]
        [string]$OutputCSV,
        
        [Parameter(Mandatory = $false)]
        [switch]$PassThru,
        
        [Parameter(Mandatory = $false)]
        [switch]$Quiet,
        
        [Parameter(Mandatory = $false)]
        [switch]$ClearSavedKey
    )

    # Check for administrator privileges
    $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
    if (-not $isAdmin -and -not $Quiet) {
        Write-Warning "Not running as Administrator. Some file access may be limited."
    }

    # Handle ClearSavedKey first
    if ($ClearSavedKey) {
        if ($Global:HuntVTApiKey) {
            Remove-Variable -Name "HuntVTApiKey" -Scope Global -ErrorAction SilentlyContinue
            if (-not $Quiet) { Write-Host "[+] API key cleared from session" -ForegroundColor Green }
        }
        else {
            if (-not $Quiet) { Write-Host "[!] No saved API key found" -ForegroundColor Yellow }
        }
        return
    }



    function Invoke-VTFileQuery {
        param([string]$FileHash, [string]$VTApiKey)
    
        try {
            $uri = "https://www.virustotal.com/api/v3/files/$FileHash"
            $headers = @{
                'x-apikey' = $VTApiKey
                'accept'   = 'application/json'
            }
        
            $response = Invoke-RestMethod -Uri $uri -Headers $headers -Method Get -TimeoutSec 30 -ErrorAction Stop
            return $response
        }
        catch {
            if ($_.Exception.Response -and $_.Exception.Response.StatusCode -eq 429) {
                Write-Host "[!] Rate limit exceeded. Waiting 60 seconds..." -ForegroundColor Yellow
                Start-Sleep 60
                return $null
            }
            if ($_.Exception.Response -and $_.Exception.Response.StatusCode -eq 404) {
                return $null
            }
            if ($_.Exception.Response -and $_.Exception.Response.StatusCode -eq 401) {
                Write-Error "Authentication failed. Check your API key."
                return $null
            }
            if ($_.Exception.Response -and $_.Exception.Response.StatusCode -eq 403) {
                Write-Error "Access forbidden. Your API key may not have sufficient permissions."
                return $null
            }
            Write-Verbose "VT Query Error: $($_.Exception.Message)"
            throw $_
        }
    }

    function Invoke-VTFileUpload {
        param([string]$FileToUpload, [string]$VTApiKey)
    
        try {
            $fileInfo = Get-Item $FileToUpload -ErrorAction Stop
        
            if ($fileInfo.Length -gt 33554432) {
                throw "File too large for direct upload (>32MB)"
            }
        
            $uri = "https://www.virustotal.com/api/v3/files"
            $headers = @{ 'x-apikey' = $VTApiKey }
        
            $fileBytes = [System.IO.File]::ReadAllBytes($FileToUpload)
            $fileName = Split-Path $FileToUpload -Leaf
            $boundary = [System.Guid]::NewGuid().ToString()
            $LF = "`r`n"
        
            $bodyStart = "--$boundary$LF" + 
            "Content-Disposition: form-data; name=`"file`"; filename=`"$fileName`"$LF" +
            "Content-Type: application/octet-stream$LF$LF"
            $bodyEnd = "$LF--$boundary--$LF"
        
            $bodyStartBytes = [System.Text.Encoding]::UTF8.GetBytes($bodyStart)
            $bodyEndBytes = [System.Text.Encoding]::UTF8.GetBytes($bodyEnd)
        
            $totalBytes = New-Object byte[] ($bodyStartBytes.Length + $fileBytes.Length + $bodyEndBytes.Length)
            [System.Array]::Copy($bodyStartBytes, 0, $totalBytes, 0, $bodyStartBytes.Length)
            [System.Array]::Copy($fileBytes, 0, $totalBytes, $bodyStartBytes.Length, $fileBytes.Length)
            [System.Array]::Copy($bodyEndBytes, 0, $totalBytes, $bodyStartBytes.Length + $fileBytes.Length, $bodyEndBytes.Length)
        
            $headers['Content-Type'] = "multipart/form-data; boundary=$boundary"
        
            $response = Invoke-RestMethod -Uri $uri -Headers $headers -Method Post -Body $totalBytes -TimeoutSec 60 -ErrorAction Stop
            return $response
        }
        catch {
            if ($_.Exception.Response -and $_.Exception.Response.StatusCode -eq 429) {
                Write-Host "[!] Rate limit exceeded during upload. Waiting 60 seconds..." -ForegroundColor Yellow
                Start-Sleep 60
                throw "Rate limit exceeded - try again later"
            }
            throw $_
        }
    }

    function Monitor-VTAnalysis {
        param([string]$AnalysisId, [string]$VTApiKey, [switch]$Quiet, [switch]$PassThru, [string]$OutputCSV, [switch]$More)

        $maxWaitTime = 300
        $checkInterval = 15
        $elapsedTime = 0
    
        if (-not $Quiet) { Write-Host "[+] Monitoring analysis status..." -ForegroundColor Green }
        Write-Progress -Activity "VirusTotal Analysis" -Status "Waiting for analysis completion..." -PercentComplete 50

        while ($elapsedTime -lt $maxWaitTime) {
            try {
                $uri = "https://www.virustotal.com/api/v3/analyses/$AnalysisId"
                $headers = @{
                    'x-apikey' = $VTApiKey
                    'accept'   = 'application/json'
                }
            
                $response = Invoke-RestMethod -Uri $uri -Headers $headers -Method Get -TimeoutSec 30 -ErrorAction Stop
            
                if ($response.data.attributes.status -eq "completed") {
                    if (-not $Quiet) { Write-Host "[+] Analysis completed!" -ForegroundColor Green }
                
                    if ($response.meta -and $response.meta.file_info -and $response.meta.file_info.sha256) {
                        $fileHash = $response.meta.file_info.sha256
                        if (-not $Quiet) { Write-Host "[+] Final file hash: $fileHash" -ForegroundColor Cyan }
                    
                        try {
                            $vtReport = Invoke-VTFileQuery -FileHash $fileHash -VTApiKey $VTApiKey
                            if ($vtReport) {
                                Write-Progress -Activity "VirusTotal Analysis" -Status "Processing final results..." -PercentComplete 90
                                $result = Convert-VTResponse -VTReport $vtReport -Hash $fileHash -HashType "SHA256"
        
                                if ($result) {
                                    if (-not $Quiet) {
                                        Display-VTReport -Result $result -More:$More
                                    }
        
                                    if ($OutputCSV) {
                                        Export-VTResultsToCSV -Results @($result) -OutputPath $OutputCSV
                                    }
        
                                    Write-Progress -Activity "VirusTotal Analysis" -Completed
                                    return $result
                                }
                                else {
                                    if (-not $Quiet) { Write-Host "[!] Failed to process analysis results" -ForegroundColor Red }
                                }
                            }
                            else {
                                if (-not $Quiet) { Write-Host "[!] Failed to retrieve final report" -ForegroundColor Red }
                            }
                        }
                        catch {
                            if (-not $Quiet) { Write-Host "[!] Error retrieving final report: $($_.Exception.Message)" -ForegroundColor Red }
                        }
                    }
                    else {
                        if (-not $Quiet) { Write-Host "[!] Analysis completed but no file hash returned" -ForegroundColor Yellow }
                    }
                    Write-Progress -Activity "VirusTotal Analysis" -Completed
                    return
                }
                else {
                    if (-not $Quiet) { Write-Host "[+] Status: $($response.data.attributes.status) (${elapsedTime}s elapsed)" -ForegroundColor Yellow }
                    Start-Sleep $checkInterval
                    $elapsedTime += $checkInterval
                }
            }
            catch {
                if ($_.Exception.Response -and $_.Exception.Response.StatusCode -eq 429) {
                    if (-not $Quiet) { Write-Host "[!] Rate limit hit during monitoring. Waiting 60 seconds..." -ForegroundColor Yellow }
                    Start-Sleep 60
                    $elapsedTime += 60
                    continue
                }
                if (-not $Quiet) { Write-Host "[!] Error checking status: $($_.Exception.Message)" -ForegroundColor Red }
                break
            }
        }
    
        if ($elapsedTime -ge $maxWaitTime) {
            if (-not $Quiet) { Write-Host "[!] Analysis timeout - check manually: https://www.virustotal.com/gui/analysis/$AnalysisId" -ForegroundColor Yellow }
            Write-Progress -Activity "VirusTotal Analysis" -Completed
        }
    }

    function Convert-VTResponse {
        param($VTReport, $Hash, $HashType, $FilePath = "")

        if (-not $VTReport -or -not $VTReport.data -or -not $VTReport.data.attributes) {
            Write-Error "Invalid VirusTotal response data"
            return $null
        }
    
        $attrs = $VTReport.data.attributes
        $stats = $attrs.last_analysis_stats
        
        # Validate stats object exists
        if (-not $stats) {
            Write-Error "Missing analysis statistics in VirusTotal response"
            return $null
        }
    
        $result = [PSCustomObject]@{
            Hash             = $Hash
            HashType         = $HashType
            FilePath         = $FilePath
            Malicious        = if ($null -ne $stats.malicious) { $stats.malicious } else { 0 }
            Suspicious       = if ($null -ne $stats.suspicious) { $stats.suspicious } else { 0 }
            Undetected       = if ($null -ne $stats.undetected) { $stats.undetected } else { 0 }
            Harmless         = if ($null -ne $stats.harmless) { $stats.harmless } else { 0 }
            Total            = if ($stats.malicious -or $stats.suspicious -or $stats.undetected -or $stats.harmless) { ($stats.malicious + $stats.suspicious + $stats.undetected + $stats.harmless) } else { 0 }
            Filename         = $attrs.meaningful_name
            FileType         = $attrs.type_description
            Size             = $attrs.size
            SizeMB           = if ($attrs.size) { [math]::Round($attrs.size / 1MB, 2) } else { $null }
            FirstSeen        = if ($attrs.first_submission_date) { [DateTimeOffset]::FromUnixTimeSeconds($attrs.first_submission_date) } else { $null }
            LastAnalysis     = if ($attrs.last_analysis_date) { [DateTimeOffset]::FromUnixTimeSeconds($attrs.last_analysis_date) } else { $null }
            Reputation       = $attrs.reputation
            Tags             = if ($attrs.tags) { $attrs.tags -join '; ' } else { $null }
            ThreatNames      = $null
            SandboxVerdicts  = $null
            Signatures       = $null
            SignatureInfo    = $null
            DetectionResults = $null
            ReportURL        = "https://www.virustotal.com/gui/file/$Hash"
            MD5              = $attrs.md5
            SHA1             = $attrs.sha1
            SHA256           = $attrs.sha256
            RawResponse      = $VTReport
        }
    
        # Extract threat names
        if ($attrs.popular_threat_classification -and $attrs.popular_threat_classification.suggested_threat_label) {
            $result.ThreatNames = $attrs.popular_threat_classification.suggested_threat_label
        }
    
        # Extract sandbox verdicts
        if ($attrs.sandbox_verdicts) {
            $sandboxResults = @()
            foreach ($sandbox in $attrs.sandbox_verdicts.PSObject.Properties) {
                $verdict = $sandbox.Value
                $sandboxResults += "$($sandbox.Name): $($verdict.category)"
            }
            $result.SandboxVerdicts = $sandboxResults -join '; '
        }
    
        # Extract signature info
        if ($attrs.signature_info) {
            $sigInfo = $attrs.signature_info
            $sigDetails = @()
            if ($sigInfo.verified) { $sigDetails += "Verified: $($sigInfo.verified)" }
            if ($sigInfo.signers) { $sigDetails += "Signers: $($sigInfo.signers)" }
            $result.SignatureInfo = $sigDetails -join '; '
        }
    
        # Extract detection results for malicious/suspicious
        if ($attrs.last_analysis_results) {
            $detections = $attrs.last_analysis_results.PSObject.Properties | 
            Where-Object { $_.Value.category -in @("malicious", "suspicious") } | 
            ForEach-Object { "$($_.Name): $($_.Value.result)" }
            $result.DetectionResults = $detections -join '; '
        }
    
        return $result
    }

    function Display-VTReport {
        param($Result, [switch]$More)
    
        Write-Host ""
        Write-Host "----------------------------------------" -ForegroundColor Gray
        Write-Host "$($Result.HashType) Hash      : " -NoNewline -ForegroundColor Yellow
        Write-Host $Result.Hash -ForegroundColor White
    
        $detectionColor = if ($Result.Malicious -gt 0) { "Red" } elseif ($Result.Suspicious -gt 0) { "Yellow" } else { "Green" }
        Write-Host "Detections       : " -NoNewline -ForegroundColor Yellow
        Write-Host "$($Result.Malicious)/$($Result.Total) malicious, $($Result.Suspicious) suspicious" -ForegroundColor $detectionColor
    
        if ($Result.Filename) {
            Write-Host "Filename         : " -NoNewline -ForegroundColor Yellow
            Write-Host $Result.Filename -ForegroundColor White
        }
    
        if ($Result.FileType) {
            Write-Host "File Type        : " -NoNewline -ForegroundColor Yellow
            Write-Host $Result.FileType -ForegroundColor White
        }
    
        if ($Result.Size) {
            Write-Host "Size             : " -NoNewline -ForegroundColor Yellow
            Write-Host "$($Result.Size) bytes ($($Result.SizeMB) MB)" -ForegroundColor DarkGray
        }
    
        if ($Result.ThreatNames) {
            Write-Host "Threat Names     : " -NoNewline -ForegroundColor Yellow
            Write-Host $Result.ThreatNames -ForegroundColor Red
        }
    
        if ($Result.Tags) {
            Write-Host "Tags             : " -NoNewline -ForegroundColor Yellow
            Write-Host $Result.Tags -ForegroundColor Red
        }
    
        if ($Result.SandboxVerdicts) {
            Write-Host "Sandbox Verdicts : " -NoNewline -ForegroundColor Yellow
            Write-Host $Result.SandboxVerdicts -ForegroundColor DarkYellow
        }
    
        if ($Result.SignatureInfo) {
            Write-Host "Signature Info   : " -NoNewline -ForegroundColor Yellow
            Write-Host $Result.SignatureInfo -ForegroundColor White
        }
    
        if ($null -ne $Result.Reputation) {
            Write-Host "Reputation       : " -NoNewline -ForegroundColor Yellow
            try {
                $repColor = if ($Result.Reputation -lt 0) { "Red" } elseif ($Result.Reputation -eq 0) { "Yellow" } else { "Green" }
                $repValue = if ($Result.Reputation -gt 0) { "+$($Result.Reputation)" } else { $Result.Reputation }
                Write-Host $repValue -ForegroundColor $repColor
            }
            catch {
                Write-Host $Result.Reputation -ForegroundColor Yellow
            }
        }

        if ($Result.FirstSeen) {
            Write-Host "First Seen       : " -NoNewline -ForegroundColor Yellow
            Write-Host $Result.FirstSeen.ToString('yyyy-MM-dd HH:mm:ss UTC') -ForegroundColor DarkGray
        }
    
        if ($Result.LastAnalysis) {
            Write-Host "Last Analysis    : " -NoNewline -ForegroundColor Yellow
            Write-Host $Result.LastAnalysis.ToString('yyyy-MM-dd HH:mm:ss UTC') -ForegroundColor DarkGray
        }
    
        Write-Host "Report URL       : " -NoNewline -ForegroundColor Yellow
        Write-Host $Result.ReportURL -ForegroundColor Cyan
    
        if ($Result.DetectionResults -and ($Result.Malicious -gt 0 -or $Result.Suspicious -gt 0)) {
            Write-Host ""
            Write-Host "--- Detection Engines ---" -ForegroundColor Red
            $detections = $Result.DetectionResults -split '; ' 
            foreach ($detection in $detections) {
                if ($detection) {
                    $parts = $detection -split ': ', 2
                    if ($parts.Count -eq 2) {
                        Write-Host "$($parts[0])".PadRight(20) -NoNewline -ForegroundColor Yellow
                        Write-Host ": " -NoNewline -ForegroundColor Yellow
                        Write-Host $parts[1] -ForegroundColor Red
                    }
                }
            }
        }
    
        if ($More) {
            Write-Host ""
            Write-Host "--- RAW DATA ---" -ForegroundColor Magenta
            $attrs = $Result.RawResponse.data.attributes
            $processedFields = @('meaningful_name', 'type_description', 'size', 'md5', 'sha1', 'sha256', 
                'first_submission_date', 'last_analysis_date', 'last_analysis_stats', 
                'last_analysis_results', 'reputation', 'tags', 'popular_threat_classification',
                'sandbox_verdicts', 'signature_info')
        
            foreach ($property in $attrs.PSObject.Properties) {
                if ($property.Name -notin $processedFields -and $null -ne $property.Value) {
                    $value = if ($property.Value -is [array]) { 
                        $property.Value -join '; ' 
                    }
                    elseif ($property.Value -is [object] -and $property.Value.GetType().Name -eq 'PSCustomObject') {
                        $property.Value | ConvertTo-Json -Compress
                    }
                    else { 
                        $property.Value.ToString() 
                    }
                
                    if ($value.Length -gt 10000) { $value = $value.Substring(0, 10000) + "..." }
                
                    Write-Host "$($property.Name)".PadRight(20) -NoNewline -ForegroundColor DarkCyan
                    Write-Host ": " -NoNewline -ForegroundColor Yellow
                    Write-Host $value -ForegroundColor Gray
                }
            }
        }
    
        Write-Host "----------------------------------------`n" -ForegroundColor Gray
    }

    function Export-VTResultsToCSV {
        param($Results, [string]$OutputPath)

        if (-not $Results -or $Results.Count -eq 0) {
            Write-Warning "No results to export to CSV"
            return
        }
    
        if ([string]::IsNullOrWhiteSpace($OutputPath)) {
            $csvPath = "VT_Results_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv"
        }
        elseif ((Test-Path $OutputPath -PathType Container) -or ($OutputPath -match '[\\/]$')) {
            $csvPath = Join-Path $OutputPath "VT_Results_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv"
            if (-not (Test-Path (Split-Path $csvPath -Parent))) {
                New-Item -ItemType Directory -Path (Split-Path $csvPath -Parent) -Force | Out-Null
            }
        }
        else {
            $csvPath = $OutputPath
            $parentPath = Split-Path $csvPath -Parent
            if ($parentPath -and -not (Test-Path $parentPath)) {
                New-Item -ItemType Directory -Path $parentPath -Force | Out-Null
            }
        }
    
        # Sanitize data for Excel
        try {
            $sanitizedResults = $Results | ForEach-Object {
                $originalObj = $_
                $newObj = @{}
                
                foreach ($prop in $originalObj.PSObject.Properties) {
                    try {
                        if ($null -ne $prop.Value) {
                            $value = $prop.Value.ToString()
                            # Escape leading equals sign to prevent formula execution
                            if ($value.StartsWith("=") -or $value.StartsWith("+") -or $value.StartsWith("-") -or $value.StartsWith("@")) {
                                $value = "'" + $value
                            }
                            # Truncate if too long (Excel limit is 32,767 characters per cell)
                            if ($value.Length -gt 32000) {
                                $value = $value.Substring(0, 32000) + "..."
                            }
                            $newObj[$prop.Name] = $value
                        }
                        else {
                            $newObj[$prop.Name] = ""
                        }
                    }
                    catch {
                        Write-Verbose "Failed to sanitize property $($prop.Name): $($_.Exception.Message)"
                        $newObj[$prop.Name] = ""
                    }
                }
                [PSCustomObject]$newObj
            }
        }
        catch {
            Write-Error "Failed to sanitize data for CSV export: $($_.Exception.Message)"
            return
        }
    
        $csvData = $sanitizedResults | Select-Object Hash, HashType, FilePath, Malicious, Suspicious, Undetected, 
        Harmless, Total, Filename, FileType, Size, SizeMB, FirstSeen, 
        LastAnalysis, Reputation, Tags, ThreatNames, SandboxVerdicts, 
        SignatureInfo, DetectionResults, ReportURL, MD5, SHA1, SHA256
    
        try {
            $csvData | Export-Csv -Path $csvPath -NoTypeInformation -ErrorAction Stop
            Write-Host "[+] Results exported to: $csvPath" -ForegroundColor Green
        }
        catch {
            Write-Error "Failed to export CSV: $($_.Exception.Message)"
        }
    }


    # Handle UploadStatus
    if ($UploadStatus) {
        if (-not $AnalysisId) {
            Write-Error "AnalysisId parameter required with -UploadStatus"
            return
        }
        
        if (-not $ApiKey -and $Global:HuntVTApiKey) {
            $ApiKey = $Global:HuntVTApiKey
        }
        if (-not $ApiKey) {
            Write-Error "API key required for status check"
            return
        }
        
        return Monitor-VTAnalysis -AnalysisId $AnalysisId -VTApiKey $ApiKey -Quiet:$Quiet -PassThru:$PassThru -OutputCSV:$OutputCSV -More:$More
    }

    # Input validation
    if (-not $FilePath -and -not $Hash) {
        Write-Error "Either -FilePath or -Hash parameter is required"
        return
    }

    if ($FilePath -and (Test-Path $FilePath -PathType Container)) {
        Write-Error "FilePath cannot be a directory. Please specify a file path."
        return
    }
    
    if ($FilePath -and -not (Test-Path $FilePath -PathType Leaf -ErrorAction SilentlyContinue)) {
        Write-Error "File not found: $FilePath"
        return
    }
    
    # Test connectivity
    try {
        $null = Test-Connection -ComputerName "www.virustotal.com" -Count 1 -Quiet -ErrorAction Stop
    }
    catch {
        Write-Error "Cannot reach VirusTotal. Check internet connection."
        return
    }
    
    # Handle API key
    if (-not $ApiKey -and $Global:HuntVTApiKey) {
        $ApiKey = $Global:HuntVTApiKey
    }
    
    if (-not $ApiKey) {
        if (-not $Quiet) {
            Write-Host "`n[!] VirusTotal API key required" -ForegroundColor Yellow
            Write-Host "Get free API key: https://www.virustotal.com/gui/join-us" -ForegroundColor Cyan
        }
        $promptResult = Read-Host "`nEnter your VirusTotal API key"
        
        if ([string]::IsNullOrWhiteSpace($promptResult)) {
            if (-not $Quiet) { Write-Host "[!] No API key provided - exiting" -ForegroundColor Red }
            return
        }
        
        $ApiKey = $promptResult.Trim()
        $Global:HuntVTApiKey = $ApiKey
        if (-not $Quiet) { Write-Host "[+] API key saved for session" -ForegroundColor Green }
    }
    
    # Calculate hash if needed and validate hash format
    if ($FilePath -and -not $Hash) {
        try {
            $hashResult = Get-FileHash -Algorithm SHA256 -Path $FilePath -ErrorAction Stop
            $Hash = $hashResult.Hash
        }
        catch {
            Write-Error "Failed to calculate hash: $($_.Exception.Message)"
            return
        }
    }
    
    # Validate and identify hash type
    if ($null -ne $Hash) {
        $Hash = $Hash -replace '[^a-fA-F0-9]', ''
        
        if ([string]::IsNullOrWhiteSpace($Hash)) {
            Write-Error "Invalid hash: No valid hexadecimal characters found"
            return
        }
        
        $hashType = switch ($Hash.Length) {
            32 { "MD5" }
            40 { "SHA1" }
            64 { "SHA256" }
            default { 
                Write-Error "Invalid hash format. Supported: MD5 (32), SHA1 (40), SHA256 (64) characters. Received: $($Hash.Length) characters"
                return
            }
        }
    }
    
    # Main execution logic
    try {
        if (-not $Quiet) { Write-Host "[+] Querying VirusTotal for: $Hash" -ForegroundColor Green }
        Write-Progress -Activity "VirusTotal Analysis" -Status "Querying hash database..." -PercentComplete 10
        $vtReport = Invoke-VTFileQuery -FileHash $Hash -VTApiKey $ApiKey
        
        if ($vtReport -and $vtReport.data -and -not $Force) {
            Write-Progress -Activity "VirusTotal Analysis" -Status "Processing results..." -PercentComplete 80
            # File exists, process and display report
            $result = Convert-VTResponse -VTReport $vtReport -Hash $Hash -HashType $hashType -FilePath $FilePath
    
            if (-not $Quiet) {
                Display-VTReport -Result $result -More:$More
            }
    
            if ($OutputCSV) {
                Export-VTResultsToCSV -Results @($result) -OutputPath $OutputCSV
            }
    
            Write-Progress -Activity "VirusTotal Analysis" -Completed
    
            if ($PassThru) {
                return $result
            }
            return
        }
        else {
            # File doesn't exist or Force specified
            if ($FilePath) {
                if ($vtReport -and $Force) {
                    if (-not $Quiet) { Write-Host "[!] File exists but forcing upload..." -ForegroundColor Yellow }
                }
                else {
                    if (-not $Quiet) { Write-Host "[!] Hash not found in VirusTotal" -ForegroundColor Yellow }
                }
                
                Write-Progress -Activity "VirusTotal Analysis" -Status "Uploading file..." -PercentComplete 30
                if (-not $Quiet) { Write-Host "[+] Uploading file for analysis..." -ForegroundColor Green }
                $uploadResult = Invoke-VTFileUpload -FileToUpload $FilePath -VTApiKey $ApiKey

                if ($uploadResult -and $uploadResult.data) {
                    if (-not $Quiet) {
                        Write-Host "[+] Upload successful, monitoring analysis..." -ForegroundColor Green
                        Write-Host "[+] Analysis URL: https://www.virustotal.com/gui/analysis/$($uploadResult.data.id)" -ForegroundColor Cyan
                    }
    
                    $result = Monitor-VTAnalysis -AnalysisId $uploadResult.data.id -VTApiKey $ApiKey -Quiet:$Quiet -PassThru:$true -OutputCSV:$OutputCSV -More:$More
                    Write-Progress -Activity "VirusTotal Analysis" -Completed
    
                    if ($PassThru) {
                        return $result
                    }
                    return
                }
                else {
                    if (-not $Quiet) { Write-Host "[!] Upload failed" -ForegroundColor Red }
                    Write-Progress -Activity "VirusTotal Analysis" -Completed
                }
            }
            else {
                if (-not $Quiet) { Write-Host "[!] Hash not found and no file path provided for upload" -ForegroundColor Yellow }
                Write-Progress -Activity "VirusTotal Analysis" -Completed
            }
        }
    }
    catch {
        Write-Progress -Activity "VirusTotal Analysis" -Completed
        Write-Error "Error: $($_.Exception.Message)"
    }
}
